 2/1: a =
 2/2: a =CC
 4/1: a = "foo"
 4/2: import recon_CS
 4/3: recon_CS()
 4/4: recon_CS.recon_CS()
 4/5: reload(recon_CS)
 4/6: recon_CS.recon_CS()
 4/7: reload(recon_CS)
 4/8: recon_CS.recon_CS()
 4/9: a = recon_CS.recon_CS()
4/10: a
4/11: import matplotlib.pyplot as plt
4/12: a['x']
4/13: im = a['x']
4/14: im
4/15: im.shape = (256,256)
4/16: im
4/17: plt.imshow(abs(im))
4/18: plt.show()
4/19: recon_CS.recon_CS(TVWeight=0)
4/20: recon_CS.recon_CS(XFMWeight=0)
4/21: recon_CS.recon_CS()
4/22: reload(recon_CS)
4/23: recon_CS.recon_CS()
4/24: reload(recon_CS)
4/25: recon_CS.recon_CS()
4/26: reload(recon_CS)
4/27: recon_CS.recon_CS()
4/28: recon_CS.recon_CS(XFMWeight=1)
4/29: x = recon_CS.recon_CS(XFMWeight=1)
4/30: plt.imshow(abs(x['x']))
4/31: abs(x['x']).shape
4/32: abs(x['x']).shape = (256,256)
4/33: plt.imshow(abs(x['x']))
4/34: x['x'].shape = (256,256)
4/35: plt.imshow(abs(x['x']))
4/36: plt.show()
4/37: x = recon_CS.recon_CS(XFMWeight=0.1)
4/38: x = recon_CS.recon_CS(XFMWeight=0.5)
4/39: reload(recon_CS)
4/40: x = recon_CS.recon_CS(XFMWeight=0.5)
4/41: reload(recon_CS)
4/42: x = recon_CS.recon_CS(XFMWeight=0.5)
4/43: x = recon_CS.recon_CS(XFMWeight=0.5,TVWeight=0)
4/44: reload(recon_CS)
4/45: x = recon_CS.recon_CS(XFMWeight=0.5,TVWeight=0)
4/46: print('obj %.4d',1.23)
4/47: print('obj %4d',1.23)
4/48: print('obj %d',1.23)
4/49: print('obj %.2f',%1.23)
4/50: print('obj %.2f' %1.23)
4/51: reload(recon_CS)
4/52: x = recon_CS.recon_CS(XFMWeight=0.5,TVWeight=0)
 5/1: import rwt
 5/2: rwt.__file__
 5/3: rwt.__package__
 5/4: rwt.__path__
 5/5: x = recon_CS.recon_CS(XFMWeight=0.5,TVWeight=0)
 5/6: obj: 3140.25
 5/7: tv: 0.00
 5/8: xfm: 24461.07
 5/9: obj: 5536.49
5/10: tv: 0.00
5/11: xfm: 106697.66
5/12: obj: 3151.09
5/13: tv: 0.00
5/14: xfm: 27572.97
5/15: obj: 3140.56
5/16: tv: 0.00
5/17: xfm: 24585.67
5/18: obj: 3140.26
5/19: tv: 0.00
5/20: xfm: 24466.13
5/21: obj: 3140.25
5/22: tv: 0.00
5/23: xfm: 24461.27
5/24: obj: 3140.25
5/25: tv: 0.00
5/26: xfm: 24461.07
5/27: obj: 3140.25
5/28: tv: 0.00
5/29: xfm: 24461.07
5/30: obj: 5536.49
5/31: tv: 0.00
5/32: xfm: 106697.66
5/33: obj: 3189.01
5/34: tv: 0.00
5/35: xfm: 33437.75
5/36: obj: 3143.08
5/37: tv: 0.00
5/38: xfm: 25480.56
5/39: obj: 3140.55
5/40: tv: 0.00
5/41: xfm: 24579.75
5/42: obj: 3140.29
5/43: tv: 0.00
5/44: xfm: 24474.94
5/45: obj: 3140.26
5/46: tv: 0.00
5/47: xfm: 24462.69
5/48: obj: 3140.25
5/49: tv: 0.00
5/50: xfm: 24461.25
5/51: obj: 3140.25
5/52: tv: 0.00
5/53: xfm: 24461.09
5/54: obj: 3140.25
5/55: tv: 0.00
5/56: xfm: 24461.07
5/57: obj: 3140.25
5/58: tv: 0.00
5/59: xfm: 24461.07
5/60: obj: 3140.25
5/61: tv: 0.00
5/62: xfm: 24461.07
5/63: obj: 3140.25
5/64: tv: 0.00
5/65: xfm: 24461.07
 6/1: ls
 6/2: import transforms as tf
 6/3: from __future__ import division
 6/4: import numpy as np
 6/5: import scipy as sp
 6/6: import matplotlib.pyplot as plt
 6/7: import os.path
 6/8: import transforms as tf
 6/9: import scipy.ndimage.filters
6/10: import grads
6/11: import sampling as samp
6/12: import direction as d
6/13: from scipy import optimize as opt
6/14: EPS = np.finfo(float).eps
6/15: filename =
6/16: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
6/17: filename
6/18: strtag = ['spatial','spatial']
6/19: TVWeight = 0.01
6/20: XFMWeight = 0.01
6/21: im = np.load(filename)
6/22: im
6/23: plt.imshow(im)
6/24: plt.show()
6/25: N
6/26:  N = np.array(im.shape)
6/27: N = np.array(im.shape)
6/28: %paste
6/29: pctg = 0.25
6/30: strtag
6/31: im_TV = tf.TV(im,N,strtag,dirWeight = 0)
6/32: im_TV.shape
6/33: grads.gTV(im)
6/34: grads.gXFM(im,N)
6/35: im.shape
6/36: im.shape = im.size
6/37: im.shape = 1,im.size
6/38: im.shape = (1,im.size)
6/39: im.shape
6/40: im.size
6/41: im.shape = 1,65536
6/42: im.flatten
6/43: im.shape
6/44: im.flatten()
6/45: im.shape
6/46: im.ravel()
6/47: im.shape
6/48: im = im.ravel()
6/49: im.shape
6/50: grads.gXFM(im,N)
6/51: im.shape
6/52: im.reshape(256,256)
6/53: im.reshape(65535)
6/54: im.reshape(65536)
6/55: im.;shape
6/56: im.shape
6/57: im.shape = 65536,1
6/58: im.shape
6/59: im.reshape(256,256)
6/60: im.shape
6/61: a = im.reshape(256,256)
6/62: a is im
6/63: im_TV
6/64: np.tanh(0+0j)
6/65: np.tanh(0+1j)
6/66: x
6/67: x = np.linspace(-5,5)
6/68: x
6/69: x = np.linspace(-5,5,1000)
6/70: y0 = np.tanh(x)
6/71: y1 = np.tanh(0.5*x)
6/72: y2 = np.tanh(2*x)
6/73: plt.plot(x,y0,x,y1,x,y2)
6/74: plt.show()
6/75: plt.plot(x,y0,x,y1,x,y2)
6/76: plt.legend(['1','0.5','2'])
6/77: plt.show()
6/78: np.tanh(im_TV)
6/79: plt.imshow(np.tanh(im_TV))
6/80: plt.imshow(abs(np.tanh(im_TV)))
6/81: im_TV.shape
6/82: plt.imshow(abs(np.tanh(im_TV)[i,:,;]))
6/83: plt.imshow(abs(np.tanh(im_TV)[i,:,:]))
6/84: plt.imshow(abs(np.tanh(im_TV)[1,:,:]))
6/85: plt.show()
6/86: im_TV
6/87: im_TV.shape
6/88: a = np.sum(im_TV,axis=0)
6/89: a.shape
6/90: import rwt.wavelets as wv
6/91: wv.WAVELETS_DICT
6/92: wv.WAVELETS_DICT()
6/93: wv.WAVELETS_DICT
6/94:
def dot_product_threshold_with_weights(filename,
                          threshold = 0.1,
                          sigma = 0.35/2):
        dirs = np.loadtxt(filename)
        num_vecs = dirs.shape[0]
        cnt = 0
6/95:     locs = np.array([])
6/96:     vals = []
6/97:
    for i in xrange(0,num_vecs):
            for j in xrange(1,num_vecs):
                    dp = np.dot(dirs[i,:],dirs[j,:])
6/98:
            if dp >= threshold:
                    cnt = cnt + 1
                    locs[cnt,:] = np.vstack([locs, [i, j]])
                    vals[cnt] = np.vstack([vals, np.exp((dp**2 - 1)/(2*sigma**2))])
6/99:     return locs, vals
6/100: %paste
6/101: %paste
6/102: dot_product_with_mins('/home/asalerno/Documents/pyDirectionCompSense/GradientVectorMag.txt')
6/103: dirs = load('GradientVectorMag.txt')
6/104: dirs = np.load('GradientVectorMag.txt')
6/105: dirs = loadtxt('GradientVectorMag.txt')
6/106: dirs = np.loadtxt('GradientVectorMag.txt')
6/107: dirs
6/108: inds = dot_product_with_mins(dirs)
6/109: inds
6/110: inds.shape
6/111: inds.index(3)
6/112: inds.index
6/113: (inds==3).index
6/114: inds
6/115: np.where(inds == 1)
6/116: a = zeros(inds.shape)
6/117: a = np.zeros(inds.shape)
6/118: np.where(inds == 1)
6/119: a[np.where(inds == 1)] = 1
6/120: a
6/121: np.where(inds == 1)
6/122: a[-1,:] = -1
6/123: a
6/124: a[1,:] = -1
6/125: a
6/126: a = np.zeros([30,inds.shape])
6/127: a = np.zeros(np.hstack([30,inds.shape]))
6/128: a
6/129: a[0,np.where(inds == 1)] = 1
6/130: a[0,:,:]
6/131: a
6/132: a = np.zeros(np.hstack([30,inds.shape]))
6/133: a
6/134: a[0,:,:]
6/135: a[0,np.where(inds == 1)] = 1
6/136: a[0]
6/137: %paste
6/138: inds
6/139: test = gDir_lookupTable(inds)
6/140: %paste
6/141: test = gDir_lookupTable(inds)
6/142: test
6/143: test[0,:,:]
6/144: max(inds)
6/145: np.max(inds)
6/146: inds
6/147: lt = np.zeros([rows,cols])
6/148: lt = np.zeros(inds.shape)
6/149: lt
6/150: lt[np.where(inds==0)] = 1
6/151: lt
6/152: inds
6/153: %paste
6/154: dot_product_with_mins(dirs)
6/155: inds
6/156: test = dot_product_with_mins(dirs)
6/157: test
6/158: test[:,1]
6/159: test[:,0]
6/160: test[0,:]
6/161: %paste
6/162: test = dot_product_with_mins(dirs)
6/163: test
6/164: %paste
6/165: test,dp = dot_product_with_mins(dirs)
6/166: dp
6/167: dirs
6/168: dirs[0,:]
6/169: np.dot(dirs[0,:],dirs[0,:])
6/170: dp[0,0]
6/171: dp[1,1]
6/172: dp[2,2]
6/173: dp
6/174: dp(np.argsort(dp))
6/175: dp[np.argsort(dp)]
6/176: dp[np.argsort(dp)][0,0]
6/177: dp[np.argsort(dp)]
6/178: dp[np.argsort(dp)].shape
6/179: np.argsort(dp).shape
6/180: np.argsort(dp)
6/181: np.argsort(dp,axis=0)
6/182: inds
6/183: np.argsort(dp)
6/184: inds
6/185: dp[0,5]
6/186: np.argsort(abs(dp))
6/187: %paste
6/188: test = dot_product_with_mins(dirs)
6/189: test
6/190: %paste
6/191: test
6/192: test
6/193: test = dot_product_with_mins(dirs)
6/194: test
6/195: %paste
6/196: inds = dot_product_with_mins(dirs)
6/197: inds
6/198: rows,cols = inds.shape
6/199: %paste
6/200: lookupTable = np.zeros([rows,rows,cols])
6/201: lt = np.zeros([rows,cols])
6/202: lt
6/203:
for i in xrange(rows):
            lt[i,:] = -1
            lt[np.where(inds==i)] = 1
6/204:
for i in xrange(rows):
            lt[i,:] = -1
            lt[np.where(inds==i)] = 1
            lookupTable[i,:,:] = lt
6/205: lookupTable
6/206: rows,cols = inds.shape
6/207:     lookupTable = np.zeros([rows,rows,cols])
6/208: lt = np.zeros([rows,cols])
6/209: lookupTable = np.zeros([rows,rows,cols])
6/210: i = 0
6/211: lt[i,:] = -1
6/212: lt
6/213: np.where(inds==i)
6/214: np.indicies(np.where(inds==i))
6/215: np.indices(np.where(inds==i))
6/216: rows,cols = np.where(inds==i)
6/217:
for j in xrange(rows.size):
    lt[rows[j],cols[j]] = 1
6/218: lt
6/219: lookupTable[i,:,:] = lt
6/220: lookupTable[0,:,:]
6/221: %paste
6/222: test = gDir_lookupTable(inds)
6/223: test
6/224: test[0,:,:]
6/225: test[29,:,:]
6/226: %paste
6/227: test = gDir_lookupTable(inds)
6/228: %paste
6/229: test = gDir_lookupTable(inds)
6/230: rows,cols = inds.shape
6/231: lookupTable = np.zeros([rows,rows,cols])
6/232: i
6/233: lt = np.zeros([rows,cols])
6/234: lt
6/235: lt[i,:] = -1
6/236: lt
6/237: x,y = np.where(inds==i)
6/238: x
6/239:
for j in xrange(x.size):
        lt[rows[j],cols[j]] = 1
 7/1: filename =
 7/2: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
 7/3: strtag = ['spatial','spatial']
 7/4: TVWeight = 0.01
 7/5: XFMWeight = 0.01
 7/6: dirWeight = 0
 7/7: ItnLim = 150
 7/8: epsilon = 1
 7/9: l1smooth = 1e-15
7/10: xfmNorm = 1
7/11: scaling_factor = 4
7/12: L = 2
7/13: method = 'CG'
7/14: dirFile = None
7/15: nmins = None
7/16: np.random.seed(2000)
7/17: %paste
7/18: %paste
7/19: np.random.seed(2000)
7/20: im = np.load(filename)
7/21: plt.imshow(im)
7/22: plt.show()
7/23: plt.show('gray')
7/24: plt.imshow(im,cmap='gray')
7/25: plt.show()
7/26: strtag = strtag.lower()
7/27: strtag
7/28:
for i in len(strtag):
    strtag[i] = strtag[i].lower()
7/29: strtag
7/30:
for i in range(len(strtag)):
            strtag[i] = strtag[i].lower()
7/31: strtag
7/32: strtag = ['SPAtial','spaTIal']
7/33:
for i in range(len(strtag)):
            strtag[i] = strtag[i].lower()
7/34: strtag
7/35: N = np.array(im.shape) #image Size
7/36: tupleN = tuple(N)
7/37: pctg = 0.25 # undersampling factor
7/38: P = 5 # Variable density polymonial degree
7/39: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[0])
7/40: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[1])
7/41: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[1,N[0],N[1]])
7/42: ipydb
7/43: ipdb
7/44: pdb
7/45: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[1,N[0],N[1]])
7/46: reload(samp)
7/47: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[1,N[0],N[1]])
7/48: reload(samp)
7/49: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[1,N[0],N[1]])
7/50: reload(samp)
7/51: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[1,N[0],N[1]])
7/52: reload(samp)
7/53: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[1,N[0],N[1]])
7/54: plt.imshow(pdf)
7/55: plt.show()
7/56: pdf[0,0]
7/57: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[0])
7/58: n
7/59: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[0])
7/60: reload(samp)
7/61: reload(samp)
7/62: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[0])
7/63: pdf
7/64: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[1,256,256])
7/65: pdf
7/66: reload(samp)
7/67: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[1,256,256])
7/68: reload(samp)
7/69: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[1,256,256])
7/70: reload(samp)
7/71: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[1,256,256])
7/72: k = samp.genSampling(pdf,10,60)[0].astype(int)
7/73: plt.imshow(k)
7/74: plt.show()
7/75: np.sum(k)/k.size
7/76: dirFile
7/77: dirs = None
7/78: M = None
7/79: data = np.fft.ifftshift(k)*tf.fft2c(im)
7/80: imshow(data)
7/81:
plt.show(tf.fft2c(im).real()()
q
7/82: plt.show(tf.fft2c(im).real())
7/83: plt.show(tf.fft2c(im).real)
7/84: plt.imshow(tf.fft2c(im).real)
7/85: plt.show()
7/86: plt.imshow(tf.fft2c(im).real)
7/87: plt.clim(0,1)
7/88: plt.show()
7/89: plt.imshow(abs(tf.fft2c(im)))
7/90: plt.show()
7/91: plt.imshow(abs(tf.fft2c(im)))
7/92: plt.clim(0,1)
7/93: plt.show()
7/94: plt.imshow(im)
7/95: plt.show()
7/96: plt.imshow(np.fft.fft2(im).real)
7/97: plt.show()
7/98: plt.imshow(np.fft.fft2(im).real,clim=(0,1))
7/99: plt.show()
7/100: plt.imshow(abs(np.fft.fft2(im)))
7/101: plt.clim(0,1)
7/102: plt.show()
7/103: plt.imshow(im)
7/104: plt.show()
7/105: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
7/106: im[125,68]
7/107: IM = np.fft.fft2(im)
7/108: plt.imshow(abs(im),clim=(0,1))
7/109: plt.show
7/110: plt.show()
7/111: plt.imshow(abs(IM),clim=(0,1))
7/112: plt.show()
7/113: data = np.fft.ifftshift(k)*tf.fft2c(im)
7/114: plt.imshow(abs(data))
7/115: plt.show()
7/116: plt.imshow(np.fft.fftshift(abs(data)))
7/117:
plt.show()(
)
7/118: plt.show()
7/119: plt.imshow(np.fft.fftshift(abs(data)))
7/120: plt.show()
7/121: import scipy.io
7/122: scipy.io.savemat('k.mat',k)
7/123: scipy.io.savemat('k.mat','k')
7/124: scipy.io.savemat('k.mat',{'k': k})
7/125: k
7/126: plt.imshow(np.fft.fftshift(abs(data)),cmap='gray')
7/127: plt.show()
7/128: plt.imshow(np.fft.fftshift(abs(data)),cmap='gray',clim=[0,1])
7/129: plt.show()
7/130: plt.imshow(im)
7/131: plt.show()
7/132: k
7/133: plt.imshow(k)
7/134: plt.show()
7/135: plt.imshow(k,cmap='k')
7/136: plt.imshow(k,cmap='gray')
7/137: plt.show()
7/138: plt.imshow(data.real)
7/139: plt.show()
7/140: plt.imshow(data.real,cmap='gray')
7/141: plt.show()
7/142: plt.imshow(data.real,cmap='gray',clim=(0,1))
7/143: plt.show()
7/144: data.real[64,111]
7/145: data.real[65,112]
7/146: data.real[111,64]
7/147: import scipy.io as sio
7/148: scipy.io.savemat('fftim.mat',{'fftim': data})
7/149: data = np.fft.ifftshift(k)*np.fft.fft2(im)
7/150: scipy.io.savemat('fftim.mat',{'fftim': data})
7/151: data = np.fft.ifftshift(k)*tf.fft2c(im)
7/152: scipy.io.savemat('fftim.mat',{'fftim': data})
7/153: im_scan = tf.ifft2c(data)
7/154: scipy.io.savemat('im_scan.mat',{'im_scan': im_scan})
7/155: imshow(data.real)
7/156: plt.imshow(data.real)
7/157: plt.show()
7/158: plt.imshow(pdf)
7/159: plt.show()
7/160: im_scan = tf.ifft2c(data)
7/161: data/np.fft.ifftshift(pdf)
7/162: im_dc =  tf.ifft2c(data/np.fft.ifftshift(pdf))
7/163: scipy.io.savemat('im_dc.mat',{'im_dc': im_dc})
7/164: plt.imshow(im_dc.real,cmap='gray',clim=(0,1))
7/165: plt.show
7/166: plt.show()
7/167: XFMWeight
7/168: XFMWeight = 0
7/169: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/170: %paste
7/171: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/172: reload(grads)
7/173: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/174: reload(grads)
7/175: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/176: %paste
7/177: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/178: %paste
7/179: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/180: XFMWeight = 0.0000000001
7/181: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/182: reload(tf)
7/183: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/184: plt.imshow(im_result.real)
7/185: im_result
7/186: im_result{x}
7/187: im_result['x']
7/188: plt.imshow(im_result['x'].real)
7/189: im_result['x'].shape
7/190: im_result['x'].shape = (256,256)
7/191: plt.imshow(im_result['x'].real)
7/192: plt.show()
7/193: data
7/194: data
7/195: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/196: reload(grads)
7/197: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/198: grads.gObj(im_dc,N,data,k)
7/199: x = im_dc
7/200: data_from_scanner = data
7/201: x0 = x.reshape(N)
7/202: x0
7/203: x0.shape
7/204: data_from_scanner.shape = N
7/205: data_from_scanner
7/206: plt.imshow(x0)
7/207: plt.imshow(x0.real)
7/208: plt.show()
7/209: plt.imshow(np.fft.fftshift(x0).real)
7/210: plt.show
7/211: plt.show()
7/212: reload(grads)
7/213: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/214: x_data = samp_mask*np.fft.fftshift(tf.fft2c(x0))
7/215: x_data
7/216: x0
7/217: x_data = samp_mask*np.fft.fftshift(tf.fft2c(x0))
7/218: samp_mask = k
7/219: x_data = samp_mask*np.fft.fftshift(tf.fft2c(x0))
7/220: plt.imshow(x_data.real)
7/221: plt.show()
7/222: plt.imshow(k)
7/223: plt.show()
7/224: plt.imshow(data_from_scanner.real)
7/225: data_from_scanner
7/226: data_from_scanner.shape
7/227: data_from_scanner.shape = N
7/228: plt.imshow(data_from_scanner.real)
7/229: plt.show()
7/230: reload(grads)
7/231: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/232: x_data = np.fft.fftshift(samp_mask*tf.fft2c(x0))
7/233: x_data
7/234: plt.imshow(np.fft.fft2(x_data - data_from_scanner).real))
7/235: plt.imshow(np.fft.fft2(x_data - data_from_scanner).real)
7/236: data_from_scanner.shape = N
7/237: plt.imshow(np.fft.fft2(x_data - data_from_scanner).real)
7/238: plt.show()
7/239: plt.imshow((np.fft.fft2(x_data) - np.fft.fft2(data_from_scanner)).real)
7/240: plt.show()
7/241: plt.imshow((np.fft.fft2(x_data) - np.fft.fft2(data_from_scanner)).real,cmap='gray',clim=(0,1))
7/242: plt.show()
7/243: max((np.fft.fft2(x_data) - np.fft.fft2(data_from_scanner)))
7/244: np.max((np.fft.fft2(x_data) - np.fft.fft2(data_from_scanner)))
7/245: np.min((np.fft.fft2(x_data) - np.fft.fft2(data_from_scanner)))
7/246: tf.ifft2c(data_from_scanner - x_data)
7/247: plt.imshow(tf.ifft2c(data_from_scanner - x_data).real)
7/248: plt.show()
7/249: plt.imshow(tf.ifft2c(data_from_scanner - x_data).real,cmap='gray')
7/250: plt.show()
7/251: plt.imshow(x_data.real,cmap='gray')
7/252: plt.show()
7/253: plt.imshow(np.fft.fft2(x_data),cmap='gray')
7/254: plt.imshow(np.fft.fft2(x_data).real,cmap='gray')
7/255: plt.show()
7/256: plt.imshow(np.fft.fft2(np.fft.fftshift(x_data)).real,cmap='gray')
7/257: plt.show()
7/258: samp_mask
7/259: k
7/260: %break
7/261: %help break
7/262: break?
7/263: ?break
7/264: ?bp
7/265: reload grads
7/266: reload(grads)
7/267: grads.gOBJ(im_dc,N,data,k)
7/268: grads.gObj(im_dc,N,data,k)
7/269: reload(grads)
7/270: grads.gObj(im_dc,N,data,k)
7/271: g = grads.gObj(im_dc,N,data,k)
7/272: plt.imshow(g.real,cmap='gray',clim=(0,1))
7/273: plt.show()
7/274: plt.rcParams['image.cmap'] = 'gray'
7/275: plt.rcParams['image.clim'] = (0,1)
7/276: plt.imshow(g.real,clim=(0,1))
7/277: plt.show()
7/278: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/279: plt.imshow(im_result['x'].real)
7/280: plt.imshow(im_result['x'].real)
7/281: im_result
7/282: im_result['x']
7/283: im_result['x'].real.reshape(256,256)
7/284: plt.imshow(im_result['x'].real.reshape(256,256))
7/285: plt.show()
7/286: TVWeight
7/287: XFMWeight
7/288: TVWeight = 1
7/289: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
7/290: plt.imshow(im_result['x'].real.reshape(256,256))
7/291: plt.show
7/292: plt.show()
7/293: %paste
7/294: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})['x'].reshape(256,256)
7/295: plt.imshow(im_result)
7/296: plt.imshow(im_result.real)
7/297: plt.show()
7/298: tf.TV(im)
7/299: tv = tf.TV(im,N,strtag)
7/300: tv.shape
7/301: plt.imshow(tv[0,:,:])
7/302: tv
7/303: plt.imshow(abs(tv[0,:,:]))
7/304: plt.show()
7/305: plt.imshow(abs(tv[1,:,:]))
7/306: plt.show()
7/307: tv = tf.TV(im_dc,N,strtag)
7/308: plt.imshow(abs(tv[1,:,:]))
7/309: plt.show()
7/310: gtv = grads.gTV(im_dc,N,strtag)
7/311: gtv = grads.gTV(im_dc,N,strtag,0)
7/312: gtv
7/313: gtv.shape
7/314: plt.imshow(abs(gtv))
7/315: plt.imshow((gtv))
7/316: plt.show()
7/317: plt.imshow((gtv),clim=(0,1))
7/318: plt.show()
7/319: gtv
7/320: plt.imshow((im_dc-gtv).real)
7/321: plt.show()
7/322: plt.imshow((im_dc-0.1*gtv).real)
7/323: plt.show()
7/324: a = 1
7/325:
if a:
    print(a)
 8/1: from __future__ import division
 8/2: import numpy as np
 8/3: import scipy as sp
 8/4: import matplotlib.pyplot as plt
 8/5: import os.path
 8/6: import transforms as tf
 8/7: import scipy.ndimage.filters
 8/8: import grads
 8/9: import sampling as samp
8/10: import direction as d
8/11: from scipy import optimize as opt
8/12: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
8/13: strtag = ['spatial','spatial']
8/14: TVWeight = 0.01
8/15: XFMWeight = 0.01
8/16: dirWeight = 0
8/17: #DirType = 2
8/18: ItnLim = 150
8/19: epsilon = 1
8/20: l1smooth = 1e-15
8/21: xfmNorm = 1
8/22: scaling_factor = 4
8/23: L = 2
8/24: method = 'CG'
8/25: dirFile = None
8/26: nmins = None
8/27: pwd
8/28: import os
8/29: os.chdir('/micehome/asalerno/Documents/pyDirectionCompSense/')
8/30: from __future__ import division
8/31: import numpy as np
8/32: import scipy as sp
8/33: import matplotlib.pyplot as plt
8/34: import os.path
8/35: import transforms as tf
8/36: import scipy.ndimage.filters
8/37: import grads
8/38: import sampling as samp
8/39: import direction as d
8/40: from scipy import optimize as opt
8/41: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
8/42: strtag = ['spatial','spatial']
8/43: TVWeight = 0.01
8/44: XFMWeight = 0.01
8/45: dirWeight = 0
8/46: #DirType = 2
8/47: ItnLim = 150
8/48: epsilon = 1
8/49: l1smooth = 1e-15
8/50: xfmNorm = 1
8/51: scaling_factor = 4
8/52: L = 2
8/53: method = 'CG'
8/54: dirFile = None
8/55: nmins = None
8/56: TVWeight = 0
8/57: XFMWeight = 0
8/58: np.random.seed(2000)
8/59: im = np.load(filename)
8/60: N = np.array(im.shape) #image Size
8/61:     tupleN = tuple(N)
8/62:     pctg = 0.25 # undersampling factor
8/63:     P = 5 # Variable density polymonial degree
8/64: N = np.array(im.shape) #image Size
8/65: pctg = 0.25
8/66: P = 5
8/67: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[0])
8/68: k = samp.genSampling(pdf,10,60)[0].astype(int)
8/69: data = np.fft.ifftshift(k)*tf.fft2c(im)
8/70: dirs = None
8/71: M = None
8/72: im_scan = tf.ifft2c(data)
8/73: im_dc = tf.ifft2c(data/np.fft.ifftshift(pdf)).flatten().copy()
8/74: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
8/75: %pase
8/76: %paste
8/77: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
 9/1: import os
 9/2: os.cwd()
 9/3: cwd
 9/4: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
 9/5: from __future__ import division
 9/6: import numpy as np
 9/7: import scipy as sp
 9/8: import matplotlib.pyplot as plt
 9/9: import os.path
9/10: import transforms as tf
9/11: import scipy.ndimage.filters
9/12: import grads
9/13: import sampling as samp
9/14: import direction as d
9/15: from scipy import optimize as opt
9/16: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
9/17: strtag = ['spatial','spatial']
9/18: TVWeight = 0.01
9/19: XFMWeight = 0.01
9/20: dirWeight = 0
9/21: #DirType = 2
9/22: ItnLim = 150
9/23: epsilon = 1
9/24: l1smooth = 1e-15
9/25: xfmNorm = 1
9/26: scaling_factor = 4
9/27: L = 2
9/28: method = 'CG'
9/29: dirFile = None
9/30: nmins = None
9/31: TVWeight = 0
9/32: XFMWeight = 0
9/33: %paste
9/34: np.random.seed(2000)
9/35: im = np.load(filename)
9/36: plt.imshow(im)
9/37: plt.show()
9/38:  N = np.array(im.shape)
9/39: N = np.array(im.shape)
9/40: pctg = 0.25
9/41: P = 5
9/42: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[0])
9/43: plt.imshow(pdf)
9/44: plt.show()
9/45: k = samp.genSampling(pdf,10,60)[0].astype(int)
9/46: plt.imshow(k)
9/47: plt.show()
9/48: dirs = None
9/49: M = None
9/50: data = np.fft.ifftshift(k)*tf.fft2c(im)
9/51: im_scan = tf.ifft2c(data)
9/52: plt.imshow(im_scan.real)
9/53: plt.show()
9/54: im_dc = tf.ifft2c(data/np.fft.ifftshift(pdf)).flatten().copy()
9/55: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
9/56: im_after = im_result['x'].reshape(256,256)
9/57: plt.imshow((im_result - im_scan).real)
9/58: plt.imshow((im_after - im_scan).real)
9/59: plt.show()
9/60: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':0.001,'disp':1})
8/78: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-10,'disp':1})
8/79: %psate
8/80: %paste
8/81: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-10,'disp':1})
8/82: plt.imshow(data.real)
8/83: plt.imshow(data.reshape(256,256).real)
8/84: plt.show()
8/85: plt.imshow(tf.fft2c(im).real)
8/86: plt.show()
8/87: %paste
8/88: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-10,'disp':1})
8/89: %paste
8/90: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-10,'disp':1})
8/91:
def optfun(x,N,lam1,lam2,data,k,strtag,dirWeight = 0,dirs = None,M = None,nmins = 0,scaling_factor = 4,L = 2):
        '''
        This is the optimization function that we're trying to optimize. We are optimizing x here, and testing it within the funcitons that we want, as called by the functions that we've created
        '''
        data.shape = N
        x.shape = N
        obj_data = tf.ifft2c(data - np.fft.fftshift(k)*tf.fft2c(x))
        obj = np.sqrt(np.sum(obj_data*obj_data.conj())) #L2 Norm
        tv = np.sum(abs(tf.TV(x,N,strtag,dirWeight,dirs,nmins,M))) #L1 Norm
        xfm = np.sum(abs(tf.xfm(x,scaling_factor,L))) #L1 Norm
        x.shape = (x.size,) # Not the most efficient way to do this, but we need the shape to reset.
        data.shape = (data.size,)
        print('obj: %.2f' % abs(obj))
        print('tv: %.2f' % abs(lam1*tv))
        print('xfm: %.2f' % abs(lam2*xfm))
        return abs(obj + lam1*tv + lam2*xfm)
8/92: %paste
8/93:
def optfun(x,N,lam1,lam2,data,k,strtag,dirWeight = 0,dirs = None,M = None,nmins = 0,scaling_factor = 4,L = 2):
        '''
        This is the optimization function that we're trying to optimize. We are optimizing x here, and testing it within the funcitons that we want, as called by the functions that we've created
        '''
        data.shape = N
        x.shape = N
        obj_data = tf.ifft2c(data - np.fft.fftshift(k)*tf.fft2c(x))
        obj = np.sqrt(np.sum(obj_data*obj_data.conj())) #L2 Norm
        tv = np.sum(abs(tf.TV(x,N,strtag,dirWeight,dirs,nmins,M))) #L1 Norm
        xfm = np.sum(abs(tf.xfm(x,scaling_factor,L))) #L1 Norm
        x.shape = (x.size,) # Not the most efficient way to do this, but we need the shape to reset.
        data.shape = (data.size,)
        print('obj: %.2f' % abs(obj))
        print('tv: %.2f' % abs(lam1*tv))
        print('xfm: %.2f' % abs(lam2*xfm))
        return abs(obj + lam1*tv + lam2*xfm)
8/94: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-10,'disp':1})
8/95:
def derivative_fun(x,N,lam1,lam2,data,k,strtag,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2):
        '''
        This is the function that we're going to be optimizing via the scipy optimization pack. This is the function that represents Compressed Sensing
        '''
        gObj = grads.gObj(x,N,data,k) # Calculate the obj function
        gTV = grads.gTV(x,N,strtag,dirWeight,dirs,nmins,M) # Calculate the TV gradient
        gXFM = tf.ixfm(grads.gXFM(tf.xfm(x),N)) # Calculate the wavelet gradient
        x.shape = (x.size,)
        return (gObj + lam1*gTV + lam2*gXFM).flatten()
8/96: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-10,'disp':1})
8/97: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1,'disp':1})
8/98: im_post = im_result['x
8/99: im_post = im_result['x'].reshape(256,256)
8/100: imshow(im_post-im_dc)
8/101: plt.imshow((im_post-im_dc).real)
8/102: plt.imshow((im_post-im_dc.reshape(256,256)).real)
8/103: plt.show()
8/104: im_post
8/105: np.max(im_post-im_dc)
8/106: np.max(im_post-im_dc.reshape(256,256))
8/107: im_post == im_dc.reshape(256,256)
8/108: np.all(im_post == im_dc.reshape(256,256))
8/109: im_dc - im_scan
8/110: im_dc.shape = 256,256
8/111: im_dc - im_scan
8/112: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1,'disp':1})
8/113: im_result
8/114: plt.imshow(im_result['jac'].reshape(256,256))
8/115: plt.imshow(im_result['jac'].reshape(256,256).real)
8/116: plt.show()
8/117: jac = im_result['jac'].reshape(256,256)
8/118: im_jac = im_dc + jac
8/119: (im_dc - im_scan) == jac
8/120: (im_dc - im_scan) == -jac
8/121: np.max((im_dc - im_scan) -jac)
8/122: np.max((im_dc - im_scan) + jac)
8/123: np.max((im_dc - im_scan))
8/124: np.max((im_dc - im_result))
8/125: im_result
8/126: jac
8/127: im_result
8/128: x = im_result['x'].reshape(256,256)
8/129: x
8/130: np.max((im_dc - x))
10/1: from __future__ import division
10/2: import numpy as np
10/3: import scipy as sp
10/4: import matplotlib.pyplot as plt
10/5: import os.path
10/6: import transforms as tf
10/7: import scipy.ndimage.filters
10/8: import grads
10/9: import sampling as samp
10/10: import direction as d
10/11: from scipy import optimize as opt
10/12: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
10/13: strtag = ['spatial','spatial']
10/14: TVWeight = 0.01
10/15: XFMWeight = 0.01
10/16: dirWeight = 0
10/17: #DirType = 2
10/18: ItnLim = 150
10/19: epsilon = 1
10/20: l1smooth = 1e-15
10/21: xfmNorm = 1
10/22: scaling_factor = 4
10/23: L = 2
10/24: method = 'CG'
10/25: dirFile = None
10/26: nmins = None
10/27: os.path
10/28: os.path()
10/29: getcwd()
10/30: os,getcwd()
10/31: os.getcwd()
11/1: from __future__ import division
11/2: import numpy as np
11/3: import scipy as sp
11/4: import matplotlib.pyplot as plt
11/5: import os.path
11/6: os.chdir('home/asalerno/Documents/pyDirectionCompSense/')
11/7: import transforms as tf
11/8: import scipy.ndimage.filters
11/9: import grads
11/10: import sampling as samp
11/11: import direction as d
11/12: from scipy import optimize as opt
11/13: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
11/14: strtag = ['spatial','spatial']
11/15: TVWeight = 0.01
11/16: XFMWeight = 0.01
11/17: dirWeight = 0
11/18: #DirType = 2
11/19: ItnLim = 150
11/20: epsilon = 1
11/21: l1smooth = 1e-15
11/22: xfmNorm = 1
11/23: scaling_factor = 4
11/24: L = 2
11/25: method = 'CG'
11/26: dirFile = None
11/27: nmins = None
11/28: os.chdir('.')
11/29: os.chdir('home/asalerno/Documents/pyDirectionCompSense/')
11/30: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
11/31: import transforms as tf
11/32: import scipy.ndimage.filters
11/33: import grads
11/34: import sampling as samp
11/35: import direction as d
11/36: from scipy import optimize as opt
11/37: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
11/38: strtag = ['spatial','spatial']
11/39: TVWeight = 0.01
11/40: XFMWeight = 0.01
11/41: dirWeight = 0
11/42: #DirType = 2
11/43: ItnLim = 150
11/44: epsilon = 1
11/45: l1smooth = 1e-15
11/46: xfmNorm = 1
11/47: scaling_factor = 4
11/48: L = 2
11/49: method = 'CG'
11/50: dirFile = None
11/51: nmins = None
11/52: np.random.seed(2000)
11/53: im = np.load(filename)
11/54: np.random.seed(2000)
11/55: im = np.load(filename)
11/56:
for i in range(len(strtag)):
        strtag[i] = strtag[i].lower()
11/57: N = np.array(im.shape) #image Size
11/58: tupleN = tuple(N)
11/59: pctg = 0.25 # undersampling factor
11/60: P = 5 # Variable density polymonial degree
11/61: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[0]) # Currently not working properly for the cylindrical case -- can fix at home
11/62: # Set the sampling pattern -- checked and this gives the right percentage
11/63: k = samp.genSampling(pdf,10,60)[0].astype(int)
11/64: plt.imshow(pdf)
11/65: plt.show()
11/66: plt.rcParams['image.cmap'] = 'gray'
11/67: plt.imshow(pdf)
11/68: plt.show()
11/69: TVWeight = 0
11/70: xfmWeight = 0
11/71: k = samp.genSampling(pdf,10,60)[0].astype(int)
11/72: # Diffusion information that we need
11/73:
if dirFile:
        dirs = np.loadtxt(dirFile)
        M = d.calc_Mid_Matrix(dirs,nmins=4)
    else:
            dirs = None
            M = None
11/74: # Here is where we build the undersampled data
11/75: data = np.fft.ifftshift(k)*tf.fft2c(im)
11/76: #ph = phase_Calculation(im,is_kspace = False)
11/77: #data = np.fft.ifftshift(np.fft.fftshift(data)*ph.conj());
11/78: # IMAGE from the "scanner data"
11/79: im_scan = tf.ifft2c(data)
11/80: # Primary first guess. What we're using for now. Density corrected
11/81: im_dc = tf.ifft2c(data/np.fft.ifftshift(pdf)).flatten().copy()
11/82: plt.imshow(im)
11/83: plt.show()
11/84: plt.imshow(abs(im_dc))
11/85: plt.imshow(abs(im_dc.reshape(256,256)))
11/86: plt.show()
11/87: im_dc
11/88: test = im_dc.reshape(256,256).copy()
11/89: test
11/90: import scipy as sp
11/91: sp.misc.imfilter(test,'blur')
11/92: areal = sp.misc.imfilter(test.real,'blur')
11/93: aimag = sp.misc.imfilter(test.imag,'blur')
11/94: a = areal + aimag
11/95: a
11/96: a = areal + aimag*j
11/97: a = areal + aimag*1j
11/98: a
11/99: kernel = tf.matlab_style_gauss2D()
11/100: kernel
11/101: kernel = tf.matlab_style_gauss2D(shape = (5,5))
11/102: kernel
11/103: import cv2
11/104: cv2.filter2D(im,-1,kernel)
11/105: cv2.filter2D(test,-1,kernel)
11/106: test
11/107: cv2.filter2D(test,-1,kernel)
11/108: cv2.filter2D(test,-1,kernel)
11/109: test.dtype
11/110: a = cv2.filter2D(test.real,-1,kernel) + cv2.filter2D(test.imag,-1,kernel)*1j
11/111: a = cv2.filter2D(test.real,-1,kernel)
11/112: a = cv2.filter2D(test.real,-1,kernel)
11/113: test.shape
11/114: cv2.blur(im_dc.shape(256,256))
11/115: cv2.blur(im_dc.reshape(256,256))
11/116: cv2.blur(im_dc.reshape(256,256),(5,5))
11/117: cv2.blur(im_dc.real,(5,5))
11/118: im_dc.shape
11/119: cv2.blur(im_dc.real.reshape(256,256),(5,5))
11/120: cv2.blur(im,(5,5))
11/121: im.real.dtype
11/122: im_dc.real.dtype
11/123: im_dc.real.shape
11/124: im.shape
11/125: im_dc.real.reshape(256,256).shape
11/126: im_dc.shape
11/127: test.shape
11/128: cv2.blur(test,(5,5))
11/129: cv2.blur(test.real,(5,5))
11/130: cv2.blur(test,(1,1))
11/131: cv2.blur(test.real,(1,1))
11/132: cv2.blur(test.real,(256,256))
11/133: test
11/134: cv2.blur(abs(test),(1,1))
11/135: cv2.blur(abs(test.real),(1,1))
11/136: cv2.blur(im,(1,1))
11/137: cv2.blur(im-1,(1,1))
11/138: im.dtype()
11/139: im.dtype
11/140: test.dtype
11/141: test.real.dtype
11/142: cv2.GaussianBlur(im,(5,5),0)
11/143: cv2.GaussianBlur(test,(5,5),0)
11/144: cv2.GaussianBlur(test.real,(5,5),0)
11/145: cv2.GaussianBlur(test.imag,(5,5),0)
11/146: cv2.GaussianBlur(test.real+5,(5,5),0)
11/147: cv2.GaussianBlur(test.real+4,(5,5),0)
11/148: cv2.GaussianBlur(test.real+1,(5,5),0)
11/149: cv2.GaussianBlur(test.real+0,(5,5),0)
11/150: cv2.GaussianBlur(test.real,(5,5),0)
11/151: cv2.GaussianBlur(test.real+0.,(5,5),0)
11/152: cv2.GaussianBlur(test.real*1.,(5,5),0)
11/153: cv2.GaussianBlur(test*1.,(5,5),0)
11/154: filtdata = cv2.GaussianBlur(test.real*1,(5,5),0) + cv2.GaussianBlur(test.imag*1,(5,5),0)*1j;
11/155: ph = conj(filtdata)/(abs(filtdata)+EPS)
11/156: ph = np.conj(filtdata)/(abs(filtdata)+EPS)
11/157: ph = np.conj(filtdata)/(abs(filtdata))
11/158: ph
11/159: ph.sum()
11/160: ph = conj(filtdata)/(abs(filtdata)+EPS)
11/161: cv2.GaussianBlur(im,(5,5),0)
11/162: cv2.GaussianBlur(im,(5,5),0).sum()
11/163: imfilter = cv2.GaussianBlur(im,(5,5),0)
11/164: filtdata = cv2.GaussianBlur(im,(5,5),0)
11/165: ph = conj(filtdata)/(abs(filtdata)+EPS)
11/166: ph = np.conj(filtdata)/(abs(filtdata)+EPS)
11/167: ph = np.conj(filtdata)/(abs(filtdata))
11/168: EPS = np.finfo(float).eps
11/169: ph = np.conj(filtdata)/(abs(filtdata)+EPS)
11/170: ph.sum()
11/171: reload(tf)
11/172: ph.sum()
11/173: reload(tf)
11/174: reload(tf)
11/175: reload(tf)
11/176: im
11/177: im_dc
11/178: data
11/179: plt.imshow(tf.ifft2c(data,ph).real)
11/180: plt.show()
11/181: plt.imshow(tf.ifft2c(data,ph).real,clim=0,1)
11/182: plt.imshow(tf.ifft2c(data,ph).real,clim=(0,1))
11/183: plt.show()
11/184: q
12/1: from __future__ import division
12/2: import numpy as np
12/3: import scipy as sp
12/4: import matplotlib.pyplot as plt
12/5: plt.rcParams['image.cmap'] = 'gray'
12/6: import os.path
12/7: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
12/8: import transforms as tf
12/9: import scipy.ndimage.filters
12/10: import grads
12/11: import sampling as samp
12/12: import direction as d
12/13: from scipy import optimize as opt
12/14: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
12/15: strtag = ['spatial','spatial']
12/16: TVWeight = 0.01
12/17: XFMWeight = 0.01
12/18: dirWeight = 0
12/19: #DirType = 2
12/20: ItnLim = 150
12/21: epsilon = 1
12/22: l1smooth = 1e-15
12/23: xfmNorm = 1
12/24: scaling_factor = 4
12/25: L = 2
12/26: method = 'CG'
12/27: dirFile = None
12/28: nmins = None
12/29: np.random.seed(2000)
12/30: im = np.load(filename)
12/31: plt.imshow(im)
12/32: plt.show()
12/33:
for i in range(len(strtag)):
        strtag[i] = strtag[i].lower()
12/34: N = np.array(im.shape) #image Size
12/35: tupleN = tuple(N)
12/36: pctg = 0.25 # undersampling factor
12/37: P = 5 # Variable density polymonial degree
12/38: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[0]) # Currently not working properly for the cylindrical case -- can fix at home
12/39: # Set the sampling pattern -- checked and this gives the right percentage
12/40: k = samp.genSampling(pdf,10,60)[0].astype(int)
12/41: # Diffusion information that we need
12/42:
if dirFile:
        dirs = np.loadtxt(dirFile)
        M = d.calc_Mid_Matrix(dirs,nmins=4)
    else:
            dirs = None
            M = None
12/43: # Here is where we build the undersampled data
12/44: %psate
12/45: %paste
12/46: data = np.fft.ifftshift(k)*tf.fft2c(im,ph)
12/47: ph = tf.matlab_style_gauss2D(im,shape=(5,5));
12/48: reload(tf)
12/49: ph = tf.matlab_style_gauss2D(im,shape=(5,5));
12/50: ph = tf.matlab_style_gauss2D(im,shape=(5,5));
12/51: reload(tf)
12/52: ph = tf.matlab_style_gauss2D(im,shape=(5,5));
12/53: ph
13/1: %paste
13/2: dirs
13/3: im
13/4: data = np.fft.ifftshift(k)*tf.fft2c(im,ph)
13/5: #ph = phase_Calculation(im,is_kspace = False)
13/6: #data = np.fft.ifftshift(np.fft.fftshift(data)*ph.conj());
13/7: # IMAGE from the "scanner data"
13/8: im_scan = tf.ifft2c(data,ph)
13/9: plt.imshow(im_scan.real)
13/10: plt.imshow(im_scan.real,clim=(0,1))
13/11: plt.show()
13/12: im_dc = tf.ifft2c(data/np.fft.ifftshift(pdf),ph).flatten().copy()
13/13: np.sum(im_dc-im_scan)
13/14: np.sum(im_dc-im_scan.flatten())
13/15: plt.imshow(im_dc.reshape(256,-1)-im_scan)
13/16: plt.imshow(im_dc.reshape(256,256)-im_scan)
13/17: plt.imshow(abs(im_dc.reshape(256,256)-im_scan))
13/18: plt.show()
13/19: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
13/20: %paste
13/21: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
13/22: %paste
13/23: reload grads
13/24: reload(grads)
13/25: reload(grads)
13/26: %paste
13/27: reload(tf)
13/28: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
13/29: im_result
13/30: plt.imshow(abs(im_result['x']))
13/31:
plt.imshow(abs(im_result['x'].reshape(256,256))
)
13/32: plt.show()
13/33: plt.imshow(abs((im_result['x']-im_dc).reshape(256,256)))
13/34: plt.show()
13/35: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-3,'disp':1})
13/36: TV
13/37: TVWeight
13/38: TVWeight = 0
13/39: XFMWeight = 0
13/40: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-3,'disp':1})
13/41: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-2,'disp':1})
13/42: np.max(im_result['x']-im_dc)
13/43: np.max(im_result['x']-im)
13/44: np.max(im_result['x'].reshape(256,256)-im)
13/45: plt.imshow(abs(im_result['x']))
13/46: plt.imshow(abs(im_result['x'].reshape(256,256)))
13/47: plt.show()
13/48: TVWeight = 0.01
13/49: XFMWeight = 0.01
13/50: XFMWeight = 0
13/51: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-3,'disp':1})
13/52: plt.imshow(abs(im_result['x'].reshape(256,256)))
13/53: plt.show()
13/54: TVWeight = 0.
13/55: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-3,'disp':1})
13/56: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-2,'disp':1})
13/57: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1,'disp':1})
13/58: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':0.1,'disp':1})
13/59: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':0.05,'disp':1})
13/60: im_res = im_result['x'].reshape(256,256).copy()
13/61: im_res
13/62: im_res[123,131]
13/63: im_res[123,132]
13/64: abs(im_res[123,131])
13/65: im_result
13/66: plt.imshow(abs(im_result['jac'].reshape(256,256)))
13/67: plt.show()
13/68: plt.imshow(abs(im_result['jac'].reshape(256,256)),clim=(0,1))
13/69: plt.show()
13/70: np.max(im_result['jac'])
13/71: np.max(im_result['x'])
13/72: ItnLim
13/73: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':0.07,'disp':1})
14/1: from __future__ import division
14/2: import numpy as np
14/3: import scipy as sp
14/4: import matplotlib.pyplot as plt
14/5: plt.rcParams['image.cmap'] = 'gray'
14/6: import os.path
14/7: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
14/8: import transforms as tf
14/9: import scipy.ndimage.filters
14/10: import grads
14/11: import sampling as samp
14/12: import direction as d
14/13: from scipy import optimize as opt
14/14: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
14/15: strtag = ['spatial','spatial']
14/16: TVWeight = 0.01
14/17: XFMWeight = 0.01
14/18: dirWeight = 0
14/19: #DirType = 2
14/20: ItnLim = 150
14/21: epsilon = 1
14/22: l1smooth = 1e-15
14/23: xfmNorm = 1
14/24: scaling_factor = 4
14/25: L = 2
14/26: method = 'CG'
14/27: dirFile = None
14/28: nmins = None
14/29: %paste
14/30: %cpaste
14/31: %paste
14/32: im_dc
14/33: plt.imshow(data.real)
14/34: plt.show()
14/35: plt.imshow(np.fft.ifftshift(pdf))
14/36: plt.show()
14/37: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
14/38: %paste
14/39: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
14/40: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
14/41: epsilon
14/42: epsilon = 0.1
14/43: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
14/44: TVWeight
14/45: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
14/46: XFMWeight = 0
14/47: reload(grads)
14/48: reload(tg)
14/49: reload(tf)
14/50: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
14/51: reload(grads)
14/52: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
14/53: reload(grads)
14/54: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
14/55: reload(grads)
14/56: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
14/57: TVWeight
14/58: reload(grads)
14/59: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
14/60: reload(grads)
14/61: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
14/62: np.max(im)
14/63: TV(im,N,strtag)
14/64: test = tf.TV(im,N,strtag)
14/65: test
14/66: test.shape
14/67: np.max(test)
14/68: plt.imshow(test[0,:,:],clim=(0,1))
14/69: np.max(test.imag)
14/70: plt.imshow(test[0,:,:].real,clim=(0,1))
14/71: plt.show()
14/72: plt.imshow(test[1,:,:].real,clim=(0,1))
14/73: plt.show()
14/74: plt.imshow(tf.iTV(test),clim=(0,1))
14/75: plt.imshow(tf.iTV(test).real,clim=(0,1))
14/76: plt.show()
14/77: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
14/78: reload(grads)
14/79: TVWeight
14/80: XFMWright
14/81: XFMWeight
14/82: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
15/1: from __future__ import division
15/2: import numpy as np
15/3: import scipy as sp
15/4: import matplotlib.pyplot as plt
15/5: plt.rcParams['image.cmap'] = 'gray'
15/6: import os.path
15/7: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
15/8: import transforms as tf
15/9: import scipy.ndimage.filters
15/10: import grads
15/11: import sampling as samp
15/12: import direction as d
15/13: from scipy import optimize as opt
15/14: from recon_CS import *
15/15: recon_CS(TVWeight = 0.01,XFMWeight= 0)
15/16: im = recon_CS(TVWeight = 0.01,XFMWeight= 0)
15/17: plt.imshow(abs(im['x']),clim=(0,1))
15/18: plt.imshow(abs(im['x'].reshape(256,256)),clim=(0,1))
15/19: plt.show()
15/20: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
15/21: strtag = ['spatial','spatial']
15/22: TVWeight = 0.01
15/23: XFMWeight = 0.01
15/24: dirWeight = 0
15/25: #DirType = 2
15/26: ItnLim = 150
15/27: epsilon = 1
15/28: l1smooth = 1e-15
15/29: xfmNorm = 1
15/30: scaling_factor = 4
15/31: L = 2
15/32: method = 'CG'
15/33: dirFile = None
15/34: nmins = None
15/35: np.random.seed(2000)
15/36: im = np.load(filename)
15/37:
for i in range(len(strtag)):
        strtag[i] = strtag[i].lower()
15/38: N = np.array(im.shape) #image Size
15/39: tupleN = tuple(N)
15/40: pctg = 0.25 # undersampling factor
15/41: P = 5 # Variable density polymonial degree
15/42: ph = tf.matlab_style_gauss2D(im,shape=(5,5));
15/43: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[0]) # Currently not working properly for the cylindrical case -- can fix at home
15/44: # Set the sampling pattern -- checked and this gives the right percentage
15/45: k = samp.genSampling(pdf,10,60)[0].astype(int)
15/46: # Diffusion information that we need
15/47:
if dirFile:
        dirs = np.loadtxt(dirFile)
        M = d.calc_Mid_Matrix(dirs,nmins=4)
    else:
            dirs = None
            M = None
15/48: # Here is where we build the undersampled data
15/49: data = np.fft.ifftshift(k)*tf.fft2c(im,ph)
15/50: #ph = phase_Calculation(im,is_kspace = False)
15/51: #data = np.fft.ifftshift(np.fft.fftshift(data)*ph.conj());
15/52: # IMAGE from the "scanner data"
15/53: im_scan = tf.ifft2c(data,ph)
15/54: # Primary first guess. What we're using for now. Density corrected
15/55: im_dc = tf.ifft2c(data/np.fft.ifftshift(pdf),ph).flatten().copy()
15/56: # Optimization algortihm -- this is where everything culminates together
15/57: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
15/58: dirs = None
15/59: M = None
15/60: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
15/61: XFMWeight = 0
15/62: TVWeight = 0.01
15/63: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
15/64: epsilon = 0.1
15/65: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
15/66: np.max(im_result['x']-im_dc)
15/67: epsilon = 0.5
15/68: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
15/69: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':.2,'disp':1})
15/70: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':.4,'disp':1})
15/71: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':.45,'disp':1})
15/72: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':.49,'disp':1})
15/73: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':.5,'disp':1})
15/74: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':.8,'disp':1})
15/75: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':.7,'disp':1})
15/76: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':.75,'disp':1})
15/77: plt.imshow(abs(im_result['x'].reshape(256,256)))
15/78: plt.show()
15/79: TVWeight
15/80: XFMWeight
15/81: plt.imshow(abs((im_result['x']-im_dc).reshape(256,256)))
15/82: plt.show()
15/83: TVWeight = 0
15/84: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':.75,'disp':1})
15/85: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':.1,'disp':1})
15/86: plt.imshow(abs((im_scanner-im_dc).reshape(256,256)))
15/87: plt.imshow(abs((im_scan-im_dc).reshape(256,256)))
15/88: plt.imshow(abs((im_scan-im_dc.reshape(256,256))))
15/89: plt.show()
15/90: plt.imshow(abs((im_scan-im_dc*ph.reshape(256,256))))
15/91: plt.imshow(abs((im_scan-(im_dc*ph).reshape(256,256))))
15/92: im_scan.shape
15/93:
plt.imshow(abs((im_scan-(im_dc.reshape(256,256)*ph)))
)
15/94: plt.show()
15/95: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':.75,'disp':1})
16/1: from __future__ import division
16/2: import numpy as np
16/3: import scipy as sp
16/4: import matplotlib.pyplot as plt
16/5: plt.rcParams['image.cmap'] = 'gray'
16/6: import os.path
16/7: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
16/8: import transforms as tf
16/9: import scipy.ndimage.filters
16/10: import grads
16/11: import sampling as samp
16/12: import direction as d
16/13: from scipy import optimize as opt
16/14: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
16/15: strtag = ['spatial','spatial']
16/16: TVWeight = 0.01
16/17: XFMWeight = 0.01
16/18: dirWeight = 0
16/19: #DirType = 2
16/20: ItnLim = 150
16/21: epsilon = 1
16/22: l1smooth = 1e-15
16/23: xfmNorm = 1
16/24: scaling_factor = 4
16/25: L = 2
16/26: method = 'CG'
16/27: dirFile = None
16/28: nmins = None
16/29: np.random.seed(2000)
16/30: im = np.load(filename)
16/31:
for i in range(len(strtag)):
        strtag[i] = strtag[i].lower()
16/32: N = np.array(im.shape) #image Size
16/33: tupleN = tuple(N)
16/34: pctg = 0.25 # undersampling factor
16/35: P = 5 # Variable density polymonial degree
16/36: ph = tf.matlab_style_gauss2D(im,shape=(5,5));
16/37: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[0]) # Currently not working properly for the cylindrical case -- can fix at home
16/38: # Set the sampling pattern -- checked and this gives the right percentage
16/39: k = samp.genSampling(pdf,10,60)[0].astype(int)
16/40: # Diffusion information that we need
16/41:
if dirFile:
        dirs = np.loadtxt(dirFile)
        M = d.calc_Mid_Matrix(dirs,nmins=4)
    else:
            dirs = None
            M = None
16/42: # Here is where we build the undersampled data
16/43: data = np.fft.ifftshift(k)*tf.fft2c(im,ph)
16/44: #ph = phase_Calculation(im,is_kspace = False)
16/45: #data = np.fft.ifftshift(np.fft.fftshift(data)*ph.conj());
16/46: # IMAGE from the "scanner data"
16/47: im_scan = tf.ifft2c(data,ph)
16/48: # Primary first guess. What we're using for now. Density corrected
16/49: im_dc = tf.ifft2c(data/np.fft.ifftshift(pdf),ph).flatten().copy()
16/50: # Optimization algortihm -- this is where everything culminates together
16/51: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
16/52: dir=None
16/53: %paste
16/54: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
16/55: dirs=None
16/56: M=None
16/57: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
16/58: reload(grads)
16/59: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
16/60: ph
16/61: plt.imshow(ph)
16/62: plt.imshow(ph.real)
16/63: plt.show()
16/64:
def derivative_fun(x,N,lam1,lam2,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2):
        '''
        This is the function that we're going to be optimizing via the scipy optimization pack. This is the function that represents Compressed Sensing
        '''
        import pdb; pdb.set_trace()
        gObj = grads.gObj(x,N,ph,data,k) # Calculate the obj function
        gTV = grads.gTV(x,N,strtag,dirWeight,dirs,nmins,M) # Calculate the TV gradient
        gXFM = tf.ixfm(grads.gXFM(tf.xfm(x),N)) # Calculate the wavelet gradient
        x.shape = (x.size,)
        return -(gObj + lam1*gTV + lam2*gXFM).flatten() # Export the flattened array
16/65: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
16/66:
def derivative_fun(x,N,lam1,lam2,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2):
        '''
        This is the function that we're going to be optimizing via the scipy optimization pack. This is the function that represents Compressed Sensing
        '''
        gObj = grads.gObj(x,N,ph,data,k) # Calculate the obj function
        gTV = grads.gTV(x,N,strtag,dirWeight,dirs,nmins,M) # Calculate the TV gradient
        gXFM = tf.ixfm(grads.gXFM(tf.xfm(x),N)) # Calculate the wavelet gradient
        x.shape = (x.size,)
        return -(gObj + lam1*gTV + lam2*gXFM).flatten() # Export the flattened array
16/67: ph
16/68: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L)
16/69: a
16/70: args
16/71: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L)
16/72: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
16/73: TVWeight = 0
16/74: XFMWeight = 0
16/75: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
16/76: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L)
16/77: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
16/78: im_res = im_result['x'].reshape(256,256);
16/79: np.max(im_res-im_dc(256,256))
16/80: np.max(im_res-im_dc.reshape(256,256))
16/81: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':0.2,'disp':1})
16/82: np.max(im_res-im_dc.reshape(256,256))
16/83: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':0.2,'disp':1})
17/1: from __future__ import division
17/2: import numpy as np
17/3: import scipy as sp
17/4: import matplotlib.pyplot as plt
17/5: plt.rcParams['image.cmap'] = 'gray'
17/6: import os.path
17/7: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
17/8: import transforms as tf
17/9: import scipy.ndimage.filters
17/10: import grads
17/11: import sampling as samp
17/12: import direction as d
17/13: from scipy import optimize as opt
17/14: from recon_CS import *
17/15: im_res = recon_CS(TVWeight = 1,XFMWeight = 0);
17/16: im_res = recon_CS(TVWeight = 0.01,XFMWeight = 0);
17/17: im_result, im_dc, im_scan = recon_CS(TVWeight = 0.01,XFMWeight = 0);
17/18: reload(recon_CS)
17/19: from recon_CS import *
17/20: im_result, im_dc, im_scan = recon_CS(TVWeight = 0.01,XFMWeight = 0);
17/21: from recon_CS import *
17/22: im_result, im_dc, im_scan = recon_CS(TVWeight = 0.01,XFMWeight = 0);
17/23: im_result, im_dc, im_scan = recon_CS(TVWeight = 0,XFMWeight = 0);
17/24: im_result, im_dc, im_scan = recon_CS(TVWeight = 0,XFMWeight = 0);
17/25: from recon_CS import *
17/26: im_result, im_dc, im_scan = recon_CS(TVWeight = 0,XFMWeight = 0);
17/27: res = recon_CS(TVWeight = 0,XFMWeight = 0);
17/28: res
17/29: from recon_CS import *
17/30: res = recon_CS(TVWeight = 0,XFMWeight = 0);
18/1: import os.path
18/2: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
18/3: import recon_CS as *
18/4: from recon_CS import *
18/5: recon_CS(TVWeight=0)
18/6: recon_CS(TVWeight=0,XFMWeight=0)
18/7: recon_CS(TVWeight=0.001,XFMWeight=0)
18/8: recon_CS(TVWeight=0.1,XFMWeight=0)
18/9: recon_CS(TVWeight=0.1,XFMWeight=0,epsilon=0.5)
18/10: recon_CS(TVWeight=0,XFMWeight=0)
18/11: recon_CS(TVWeight=0,XFMWeight=0)
18/12: a = np.arange(12).reshape(4,3)
18/13: a
18/14: np.roll(im,-1,axis = i)
18/15: np.roll(a,-1,axis = i)
18/16: np.roll(a,-1,axis = 0)
18/17: from recon_CS import *
18/18: res = recon_CS(TVWeight = 0,XFMWeight = 0);
18/19: res = recon_CS(TVWeight = 0.01,XFMWeight = 0);
18/20: res = recon_CS(TVWeight = 0.01,XFMWeight = 0);
18/21: from recon_CS import *
18/22: from recon_CS import *
18/23: res = recon_CS(TVWeight = 0.01,XFMWeight = 0);
18/24: reload(derivative_fun)
18/25: recon_CS.derivative_fun
18/26: import recon_CS as r
18/27: res = r.recon_CS(TVWeight = 0.01,XFMWeight = 0);
18/28: reload(r)
18/29: r
18/30: res = r.recon_CS(TVWeight = 0.01,XFMWeight = 0);
18/31: reload(r)
18/32: res = r.recon_CS(TVWeight = 0.01,XFMWeight = 0);
18/33: reload(tf)
18/34: res = r.recon_CS(TVWeight = 0.01,XFMWeight = 0);
18/35: reload(grads)
18/36: res = r.recon_CS(TVWeight = 0.01,XFMWeight = 0);
18/37: reload(grads)
18/38: res = r.recon_CS(TVWeight = 0.01,XFMWeight = 0);
18/39: res = r.recon_CS(TVWeight = 0.01,XFMWeight = 0);
19/1: from __future__ import division
19/2: import numpy as np
19/3: import scipy as sp
19/4: import matplotlib.pyplot as plt
19/5: import os.path
19/6: import transforms as tf
19/7: import scipy.ndimage.filters
19/8: import grads
19/9: import sampling as samp
19/10: import direction as d
19/11: from scipy import optimize as opt
19/12: plt.rcParams['image.cmap'] = 'gray'
19/13: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
19/14: import recon_CS as r
19/15: np.random.seed(2000)
19/16: im = np.load(filename)
19/17: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
19/18: strtag = ['spatial','spatial']
19/19: TVWeight = 0.01
19/20: XFMWeight = 0.01
19/21: dirWeight = 0
19/22: #DirType = 2
19/23: ItnLim = 150
19/24: epsilon = 1
19/25: l1smooth = 1e-15
19/26: xfmNorm = 1
19/27: scaling_factor = 4
19/28: L = 2
19/29: method = 'CG'
19/30: dirFile = None
19/31: nmins = None
19/32: im = np.load(filename)
19/33: plt.imshow(im)
19/34: plt.show()
19/35: r.recon_CS(XFMWeight=0)
18/40: q
21/1: import recon_CS as r
21/2: import os.path
21/3: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
21/4: import recon_CS as r
21/5: r.recon_CS(XFMWeight=0)
21/6: c
21/7: reload(r)
21/8: import recon_CS as r
21/9: reload(r)
21/10: reload(r)
21/11: im_res = r.recon_CS(XFMWeight=0)
21/12: reload(tf)
21/13: q
22/1: import os.path; os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
22/2: import recon_CS as r
22/3: im_res = r.recon_CS(XFMWeight=0)
22/4: im_res
22/5: plt.imshow(abs(im_res['x'].reshape(256,-1))); plt.colorbar(); plt.show()
22/6: import matplotlib.pyplot as plt
22/7: plt.imshow(abs(im_res['x'].reshape(256,-1))); plt.colorbar(); plt.show()
22/8: im_res = r.recon_CS(XFMWeight=0,TVWeight=1)
22/9: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.1)
22/10: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.01)
22/11: reload(tf)
22/12: reload(r)
22/13: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.01)
22/14: im_res
22/15: reload(r)
22/16: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.01)
22/17: reload(r)
22/18: reload(r)
22/19: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.01)
22/20: reload(r)
22/21: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.01,epsilon=0.1)
22/22: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.01,epsilon=0.01)
22/23: plt.imshow(im_res['x'].reshape(256,256))
22/24: plt.imshow(abs(im_res['x'].reshape(256,256)))
22/25: plt.show()
22/26: filename= '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
22/27: im = np.load(filename)
22/28: import numpy as np
22/29: np.random.seed(2000)
22/30: from __future__ import division
22/31: import numpy as np
22/32: import scipy as sp
22/33: import matplotlib.pyplot as plt
22/34: plt.rcParams['image.cmap'] = 'gray'
22/35: import os.path
22/36: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
22/37: import transforms as tf
22/38: import scipy.ndimage.filters
22/39: import grads
22/40: import sampling as samp
22/41: import direction as d
22/42: from scipy import optimize as opt
22/43: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
22/44: strtag = ['spatial','spatial']
22/45: TVWeight = 0.01
22/46: XFMWeight = 0.01
22/47: dirWeight = 0
22/48: #DirType = 2
22/49: ItnLim = 150
22/50: epsilon = 1
22/51: l1smooth = 1e-15
22/52: xfmNorm = 1
22/53: scaling_factor = 4
22/54: L = 2
22/55: method = 'CG'
22/56: dirFile = None
22/57: nmins = None
22/58: np.random.seed(2000)
22/59: im = np.load(filename)
22/60:
for i in range(len(strtag)):
        strtag[i] = strtag[i].lower()
22/61: N = np.array(im.shape) #image Size
22/62: tupleN = tuple(N)
22/63: pctg = 0.25 # undersampling factor
22/64: P = 5 # Variable density polymonial degree
22/65: ph = tf.matlab_style_gauss2D(im,shape=(5,5));
22/66: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[0]) # Currently not working properly for the cylindrical case -- can fix at home
22/67: # Set the sampling pattern -- checked and this gives the right percentage
22/68: k = samp.genSampling(pdf,10,60)[0].astype(int)
22/69: dirs = None
22/70: M = None
22/71: data = np.fft.ifftshift(k)*tf.fft2c(im,ph)
22/72: #ph = phase_Calculation(im,is_kspace = False)
22/73: #data = np.fft.ifftshift(np.fft.fftshift(data)*ph.conj());
22/74: # IMAGE from the "scanner data"
22/75: im_scan = tf.ifft2c(data,ph)
22/76: # Primary first guess. What we're using for now. Density corrected
22/77: im_dc = tf.ifft2c(data/np.fft.ifftshift(pdf),ph).flatten().copy()
22/78: np.save('im_dc.npy',im_dc)
22/79: im_dc.shape
22/80: im_dc = im_dc.reshape(256,256)
22/81: plt.rcParams['image.cmap'] = 'gray'
22/82: plt.imshow(abs(im_res['x'].reshape(256,256)-im_dc))
22/83: plt.show()
22/84: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.01,epsilon=0.001)
22/85: reload(tf)
22/86: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.01,epsilon=0.001)
22/87: reload(r)
22/88: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.01,epsilon=0.001)
22/89: reload(r)
22/90: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.01,epsilon=0.001)
22/91: reload(grads)
22/92: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.01,epsilon=0.001)
22/93: reload(grads)
22/94: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.01,epsilon=0.001)
22/95: plt.imshow(abs(im_res['x'].reshape(256,256)-im_dc))
22/96: plt.show()
22/97: plt.imshow(abs(im_res['x'].reshape(256,256)))
22/98: plt.show()
22/99: plt.imshow(abs(im_res['x'].reshape(256,256)))
22/100: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.1,epsilon=0.001)
22/101: im_res = r.recon_CS(XFMWeight=0,TVWeight=0.1,epsilon=0.001)
22/102: plt.imshow(abs(im_res['x'].reshape(256,256)))
22/103: plt.show()
22/104: plt.imshow(abs(im_res['x'].reshape(256,256)-im_dc))
22/105: plt.show()
22/106: a = None
22/107:
if a:
    print('Hi')
22/108:
if !a:
       print('Hi')
22/109:
if not a:
       print('Hi')
22/110: a['x'] = 1
22/111: del a
22/112: a
22/113: a['x'] = 1
22/114: a = {'x': 1}
22/115:
if a:
    print('Hi')
23/1: from __future__ import division
23/2: import numpy as np
23/3: import matplotlib.pyplot as plt
23/4: import os.path
23/5: os.chdir('/home/asalerno/pyDirectionCompSense/')
23/6: import transforms as tf
23/7: import scipy.ndimage.filters
23/8: import grads
23/9: import sampling as samp
23/10: plt.rcParams['image.cmap'] = 'gray'
23/11: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
23/12: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
23/13: EPS = np.finfo(float).eps
23/14:
def derivative_fun(x,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2):
        '''
        This is the function that we're going to be optimizing via the scipy optimization pack. This is the function that represents Compressed Sensing
        '''
        gObj = grads.gObj(x,N,ph,data,k) # Calculate the obj function
        gTV = grads.gTV(x,N,strtag,dirWeight,dirs,nmins,M) # Calculate the TV gradient
        gXFM = tf.ixfm(grads.gXFM(tf.xfm(x),N)) # Calculate the wavelet gradient
        x.shape = (x.size,)
        #import pdb; pdb.set_trace();
        return -(gObj + TVWeight*gTV + XFMWeight*gXFM).flatten() # Export the flattened array
23/15: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
23/16: strtag = ['spatial','spatial']
23/17: TVWeight = 0.01
23/18: XFMWeight = 0.01
23/19: dirWeight = 0
23/20: #DirType = 2
23/21: ItnLim = 150
23/22: epsilon = 1
23/23: l1smooth = 1e-15
23/24: xfmNorm = 1
23/25: scaling_factor = 4
23/26: L = 2
23/27: method = 'CG'
23/28: dirFile = None
23/29: nmins = None
23/30: XFMWeight = 0
22/116: im_dc
22/117: ls
23/31: im_dc = np.load('data/im_dc.npy')
23/32: im_dc
22/118: data
22/119: np.save('testingData/data.npy',data)
22/120: np.save('testingData/k.npy',k)
22/121: np.save('testingData/N.npy',N)
22/122: np.save('testingData/ph.npy',ph)
23/33: maxlsiter = 150;
23/34:         gTol = 1e-6;
23/35:         alpha = 0.01;
23/36:         beta = 0.6;
23/37:         t0 = 1;
23/38: maxlsiter = 150;
23/39: gTol = 1e-6;
23/40: alpha = 0.01;
23/41: beta = 0.6;
23/42: t0 = 1;
23/43: p = 1;
23/44: g0 = derivative_fun(x,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
22/123: np.save('testingData/strtag.npy',strtag)
23/45: %paste
23/46: g0 = derivative_fun(x,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
22/124: im_dc = tf.ifft2c(data/np.fft.ifftshift(pdf),ph=ph).flatten().copy()
22/125: im_dc.shape
23/47: g0 = derivative_fun(x.reshape(256,256),N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/48: gObj = grads.gObj(x,N,ph,data,k)
23/49: gObj = grads.gObj(x.reshape(N),N,ph,data,k)
23/50: import pdb
23/51: pdb.pm()
23/52: gObj = grads.gObj(x.reshape(N),N,ph,data,k)
23/53: gObj = grads.gObj(x.reshape(N),N,ph,data,k)
23/54: data.shape()
23/55: data.shape
23/56: gObj = grads.gObj(x.reshape(N),N,ph,data.reshape(N),k)
23/57: ph.shape
23/58: reload grads
23/59: reload(grads)
23/60: gObj = grads.gObj(x.reshape(N),N,ph,data.reshape(N),k)
23/61: reload(grads)
23/62: gObj = grads.gObj(x.reshape(N),N,ph,data.reshape(N),k)
23/63: N
22/126: N
23/64: N = 256,256
23/65: N
23/66: gObj = grads.gObj(x.reshape(N),N,ph,data.reshape(N),k)
23/67: g0 = derivative_fun(x.reshape(256,256),N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/68: l1smooth
23/69: x0.conj
23/70: g0 = derivative_fun(x.reshape(256,256),N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/71: g0
23/72: plt.imshow(abs(g0))
23/73: plt.imshow(abs(g0).reshape(256,-1))
23/74: plt.show()
23/75: %paste
23/76: g0 = derivative_fun(x.reshape(256,256),N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/77: %paste
23/78: g0 = derivative_fun(x.reshape(256,256),N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/79: reload(grads)
23/80: g0 = derivative_fun(x.reshape(256,256),N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/81: strtag
22/127: strtag
23/82: strtag = ['spatial','spatial']
23/83: strtag = ['spatial','spatial']
23/84: strtag
23/85: g0 = derivative_fun(x.reshape(256,256),N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/86: im_dcd
23/87: im_dc
23/88: test = tf.TV(im_dc,N,strtag)
23/89: test = tf.TV(im_dc.reshape(N),N,strtag)
23/90: test
23/91: plt.imshow(test(0,:,:))
23/92: plt.imshow(test[0,:,:])
23/93: plt.imshow(abs(test[0,:,:]))
23/94: plt.show()
23/95: import ipdb
23/96: reload(grads)
23/97: g0 = derivative_fun(x.reshape(256,256),N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/98: reload(grads)
23/99: g0 = derivative_fun(x.reshape(256,256),N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/100:
def derivative_fun(x,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2):
        '''
        This is the function that we're going to be optimizing via the scipy optimization pack. This is the function that represents Compressed Sensing
        '''
        gObj = grads.gObj(x,N,ph,data,k) # Calculate the obj function
        gTV = grads.gTV(x,N,strtag,dirWeight,dirs,nmins,M) # Calculate the TV gradient
        gXFM = tf.ixfm(grads.gXFM(tf.xfm(x),N)) # Calculate the wavelet gradient
        x.shape = (x.size,)
        #import pdb; pdb.set_trace();
        return -(gObj + TVWeight*gTV + XFMWeight*gXFM).flatten() # Export the flattened array
23/101: reload(grads)
23/102: g0 = derivative_fun(x.reshape(256,256),N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/103: strtag
23/104: gTV(x,N,strtag,dirWeight)
23/105: test = grads.gTV(x,N,strtag,dirWeight)
23/106: test
23/107: strtag
23/108: reload(grads)
23/109: reload(grads)
23/110: test = grads.gTV(x,N,strtag,dirWeight)
23/111: reload(grads)
23/112: test = grads.gTV(x,N,strtag,dirWeight)
23/113: reload(grads)
23/114: test = grads.gTV(x,N,strtag,dirWeight)
23/115: grads.gTV(im_dc,N,strtag,0)
24/1: import recon_CS as r
24/2: import os.path
24/3: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
24/4: import recon_CS as r
24/5: r.recon_CS()
23/116: test = grads.gTV(x,N,strtag,dirWeight)
23/117: reload(grads)
23/118: test = grads.gTV(x,N,strtag,dirWeight)
23/119: reload(grads)
23/120: test = grads.gTV(x,N,strtag,dirWeight)
23/121: plt.imshow(test)
23/122: plt.colorbar
23/123: plt.colorbar()
23/124: plt.show()
23/125: reload(grads)
23/126: test = grads.gTV(x,N,strtag,dirWeight)
23/127: c
23/128: plt.imshow(test)
23/129: plt.colorbar()
23/130: plt.show()
23/131: g0 = derivative_fun(x,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/132: plt.imshow(g0)
23/133: %paste
23/134: g0 = derivative_fun(x,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/135: reload(grads)
23/136: g0
23/137: plt.imshow(abs(g0))
23/138: plt.imshow(abs(g0).reshape(N))
23/139: plt.show()
23/140: plt.imshow(abs(g0).reshape(N))
23/141: plt.colorbar()
23/142: plt.show()
23/143: plt.imshow(abs(g0).reshape(N),clim=(0,1))
23/144: plt.show()
24/6: r.recon_CS()
24/7: reload(grads)
24/8: reload(r)
24/9: r.recon_CS()
24/10: import grads
24/11: r.recon_CS()
24/12: q
25/1: from __future__ import division
25/2: import numpy as np
25/3: import matplotlib.pyplot as plt
25/4: import os.path
25/5: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
25/6: import transforms as tf
25/7: import scipy.ndimage.filters
25/8: import grads
25/9: import sampling as samp
25/10: plt.rcParams['image.cmap'] = 'gray'
25/11: import recon_CS as r
25/12: r.recon_CS()
25/13: reload(r)
25/14: r
25/15: r.recon_CS()
25/16: im_res = r.recon_CS()
25/17: reload(grads)
25/18: im_res = r.recon_CS()
25/19: reload(r)
25/20: im_res = r.recon_CS()
25/21: N = np.hstack([1,N])
25/22: B
25/23: N
25/24: N = [256,256]
25/25: N = np.hstack([1,N])
25/26: N
25/27: x
25/28: im_dc.shape
25/29: im
25/30: im = np.load('data/SheppLogan256.npy')
25/31: im
25/32: im.shape
25/33: im[:,:,0]
23/145:
def preobjective(x,dx,N,TVWeight,strtag):
        
        if len(N) < 2:
                N = np.hstack([1,N])
                x.shape = N
23/146:     FTtx = np.zeros(N);
23/147:     FTtdx = np.zeros(N);
23/148:     Dtx = np.zeros(np.hstack([N[0],N[1],2,N[2]));
23/149:     Dtdx = np.zeros(DXFMtx.shape);
23/150:
    for kk in np.arange(N[0]):
            FTtx[kk,:,:] = tf.fft2c(x[kk,:,:])
            FTdx[kk,:,:] = tf.fft2c(dx[kk,:,:])
23/151:
    if TVWeight:
            for kk in np.arange(N[0]):
                    Dtx[kk,:,:] = tf.TV(x[kk,:,:],N,strtag)
                    Ddx[kk,:,:] = tf.TV(dx[kk,:,:],N,strtag)
23/152: %paste
23/153: %paste
23/154: %paste
23/155: N
23/156: x.
23/157: x
23/158: dx
23/159: g0
23/160: dx = -g0
23/161: preobjective(x,dx,N,TVWeight,strtag)
23/162: N
23/163: len(N)
23/164: %paste
23/165: %paste
23/166: len(N)
23/167: preobjective(x,dx,N,TVWeight,strtag)
23/168: %paste
23/169: preobjective(x,dx,N,TVWeight,strtag)
23/170: %paste
23/171: preobjective(x,dx,N,TVWeight,strtag)
23/172: preobjective(x,dx,N,TVWeight,strtag,ph)
23/173: %paste
23/174: g0 = derivative_fun(x,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/175: g0 = derivative_fun(x,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/176: XFMdata = dwt(x,4,2)[0]
23/177: XFMdata = dwt(x,4,2)[0]
23/178: import rwt
23/179: XFMdata = rwt.dwt(x,4,2)[0]
23/180: rwt.dwt(x,4,2)[0]
23/181: rwt.dwt(x,4,2)
23/182: edit rwt.dwt
23/183: rwt.dwt.__call__
23/184: rwt.dwt.__name__
23/185: rwt.dwt.__doc__
23/186: x
23/187: x.shape
23/188: x.shape = 256,256
23/189: g0 = derivative_fun(x,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight = 0,dirs = None,M = None,nmins = 0, scaling_factor = 4,L = 2)
23/190: c
23/191: ls
26/1: %paste
26/2: %paste
26/3: import recon_CS as r
26/4: r
26/5: opt.minimize
26/6: opt.minimize.__dict__
26/7: opt.minimize.__closure__
26/8: opt.minimize.__call__
26/9: opt.minimize.__init__
26/10: opt.minimize.__init__()
26/11: opt.minimize.__name__()
26/12: opt.minimize.__name__
26/13: opt.__file__
26/14: import optimize as o
26/15: o.minimize
27/1: from __future__ import division
27/2: import numpy as np
27/3: import scipy as sp
27/4: import matplotlib.pyplot as plt
27/5: plt.rcParams['image.cmap'] = 'gray'
27/6: import os.path
27/7: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
27/8: import transforms as tf
27/9: import scipy.ndimage.filters
27/10: import grads
27/11: import sampling as samp
27/12: import direction as d
27/13: #from scipy import optimize as opt
27/14: import optimize as opt
27/15: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
27/16: strtag = ['spatial','spatial']
27/17: TVWeight = 0.01
27/18: XFMWeight = 0.01
27/19: dirWeight = 0
27/20: #DirType = 2
27/21: ItnLim = 150
27/22: epsilon = 1
27/23: l1smooth = 1e-15
27/24: xfmNorm = 1
27/25: scaling_factor = 4
27/26: L = 2
27/27: method = 'CG'
27/28: dirFile = None
27/29: nmins = None
27/30: np.random.seed(2000)
27/31: im = np.load(filename)
27/32:
for i in range(len(strtag)):
    strtag[i] = strtag[i].lower()
27/33: %paste
27/34: data = np.fft.ifftshift(k)*tf.fft2c(im,ph=ph)
27/35: im_scan = tf.ifft2c(data,ph=ph)
27/36: plt.imshow(im_scan)
27/37: plt.imshow(abs(im_scan))
27/38: plt.show()
27/39: im_dc = tf.ifft2c(data/np.fft.ifftshift(pdf),ph=ph).flatten().copy()
27/40: plt.imshow(abs(im_dc))
27/41: plt.imshow(abs(im_dc).reshape(256,256))
27/42: plt.show()
27/43: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L)
27/44: opt
27/45: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
27/46: %paste
27/47: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
27/48: TVWeight = 0
27/49: TVWeight = 0.01
27/50: XFMWeight = 0
27/51: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
27/52: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L)
27/53: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
27/54: epsilon
27/55: epsilon = 0.1
27/56: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
27/57: im_res = im_result['x'].reshape(256,256);
27/58: plt.imshow(abs(im_res))
27/59: plt.show()
27/60: epsilon
27/61: epsilon = 0.01
27/62: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
27/63: reload(opt)
27/64: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
27/65: import optimize
27/66: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
27/67: reload(optimize)
27/68: from optimize import optimize
27/69: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
27/70: reload(r)
27/71: import recon_CS as r
27/72: r
27/73: r.recon_CS(XFMWeight=0)
27/74: r.recon_CS(XFMWeight=0,epsilon=0.0001)
27/75: reload(r)
27/76: r.recon_CS(XFMWeight=0,epsilon=0.0001)
28/1: %paste
28/2: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
28/3: %paste
28/4: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
28/5: %paste
28/6: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
28/7: XFMWeight
28/8: XFMWeight = 0
28/9: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
28/10: reload(r)
28/11: reload(opt)
28/12: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
28/13: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight=0,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':0.01,'disp':1})
28/14: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,0,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':0.01,'disp':1})
28/15: d
28/16: q
29/1: %paste
29/2: %paste
29/3: %paste
29/4: %paste
29/5: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
29/6: %paste
29/7: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
30/1:
a = \
1+1
30/2: a
30/3: %paste
30/4: %paste
30/5: %paste
30/6: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
30/7: XFMWeight = 0
30/8: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
30/9: epsilon = 0.01
30/10: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
30/11: import .optimize
30/12: import optimize
30/13: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
30/14: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
30/15: q
31/1: %paste
31/2: %paste
31/3: %paste
31/4: %paste
31/5: XFMWeight = 0
31/6: epsilon = 0.01
31/7: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
31/8: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
31/9: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
31/10: TVWeight
31/11: XFMWeight
31/12: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
31/13: plt.imshow(abs(im_result['x'].reshape(256,256)))
31/14: plt.show()
31/15: TVWeight = 0.1
31/16: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
31/17: c
31/18: c
31/19: plt.imshow(abs(im_result['x'].reshape(256,256)))
31/20: plt.show()
31/21: plt.imshow(abs(im_result['x'].reshape(256,256)))
31/22: plt.show()
31/23: TVWeight = 0.01
31/24: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
31/25: plt.imshow(abs(im_result['x'].reshape(256,256)))
31/26: plt.show()
31/27: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
31/28: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
31/29: plt.imshow(abs(im_result['x'].reshape(256,256)))
31/30: plt.show()
31/31: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
31/32: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
31/33: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
31/34: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
31/35: 1 != 1
31/36: import plt_slice
31/37: import plt_slice
31/38: plt_slice.plt_slice(im,im_dc.reshape(256,256),im_result['x'].reshape(256,256),slc = 125)
31/39: reload(plt_slice)
31/40: plt_slice.plt_slice(im,im_dc.reshape(256,256),im_result['x'].reshape(256,256),slc = 125)
31/41: reload(plt_slice)
31/42: plt_slice.plt_slice(im,im_dc.reshape(256,256),im_result['x'].reshape(256,256),slc = 125)
31/43: reload(plt_slice)
31/44: plt_slice.plt_slice(im,im_dc.reshape(256,256),im_result['x'].reshape(256,256),slc = 125)
31/45: reload(plt_slice)
31/46: plt_slice.plt_slice(im,im_dc.reshape(256,256),im_result['x'].reshape(256,256),slc = 125,title='TVWeight = 0.01')
31/47: epsilon
31/48: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-3,'disp':1})
31/49: c
31/50: plt_slice.plt_slice(im,im_dc.reshape(256,256),im_result['x'].reshape(256,256),slc = 125,title='TVWeight = 0.01')
31/51: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-3,'disp':1})
31/52: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-3,'disp':1})
31/53: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-3,'disp':1})
31/54: reload(recon_CS)
31/55: reload(opt)
31/56: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':1e-3,'disp':1})
31/57: c
31/58: opt
31/59: import optimize as opt
23/192: q
32/1: from __future__ import division
32/2: import numpy as np
32/3: import scipy as sp
32/4: import matplotlib.pyplot as plt
32/5: plt.rcParams['image.cmap'] = 'gray'
32/6: import os.path
32/7: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
32/8: import transforms as tf
32/9: import scipy.ndimage.filters
32/10: import grads
32/11: import sampling as samp
32/12: import direction as d
32/13: #from scipy import optimize as opt
32/14: import optimize as opt
32/15: plt.rcParams['image.cmap'] = 'gray'
32/16: %paste
32/17: %paste
32/18: epsilon
32/19: epsilon = 1e-3
32/20: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
32/21: XFMWeight
32/22: XFMWeight = 0
32/23: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
32/24: plt.imshow(abs(im_result)['x'].reshape(256,256))
32/25: plt.imshow(abs(im_result)['x'].reshape(256,256)))
32/26:
plt.imshow(abs(im_result['x'].reshape(256,256))
)
32/27: plt.show()
32/28: plt.imshow(im-abs(im_result['x'].reshape(256,256)))
32/29: plt.show()
32/30: plt.imshow(im-abs(im_result['x'].reshape(256,256)))
32/31: plt.colorbar()
32/32: plt.show()
32/33: im_res = im_result['x'].reshape(256,256)
32/34: np.mean(abs(im_res))
32/35: np.mean(abs(im))
32/36: np.median(abs(im))
32/37: np.median(abs(im_res))
32/38: np.max(abs(im_res))
32/39: from plt_slice import *
32/40: plt_slice(im,im_dc.reshape(256,256),im_result['x'].reshape(256,256),slc = 125,title='TVWeight = 0.01')
32/41: TVWeight = 00.1
32/42: TVWeight
32/43: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
32/44: plt.imshow(abs(im_result['x'].reshape(256,256)))
32/45: plt.show()
32/46: plt_slice(im,im_dc.reshape(256,256),im_result['x'].reshape(256,256),slc = 125,title='TVWeight = 0.01')
32/47: plt_slice(im,im_dc.reshape(256,256),im_result['x'].reshape(256,256),slc = 125,title='TVWeight = 0.1')
32/48: plt.imshow(abs(im_result['x'].reshape(256,256)))
32/49: plt.show
32/50: plt.show()
32/51: reload(opt)
32/52: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
33/1: %paste
33/2: %paste
33/3: TVWeight = 0.1
33/4: XFMWeight = 0
33/5: epsilon = 1e-3
33/6: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
33/7: plt.imshow(abs(im_result['x'].reshape(256,256)))
33/8: plt.show()
33/9: q
34/1: %paste
34/2: %paste
34/3: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
34/4: plt.imshow(abs(im_result['x'].reshape(256,256)))
34/5: plt.show()
34/6: TVWeight
34/7: TVWeight = 0.1
34/8: plt.imshow(abs(im_result['x'].reshape(256,256)))
34/9: im_result = opt.minimize(optfun, im_dc, args = (N,TVWeight,XFMWeight,data,k,strtag,dirWeight,dirs,M,nmins,scaling_factor,L,ph),method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
34/10: plt.imshow(abs(im_result['x'].reshape(256,256)))
34/11: plt.show()
31/60: im = np.zeros(8,8);
31/61: im = np.zeros([8,8]);
31/62: im
31/63: im[3:5,3:5] = 1;
31/64: im
35/1: %paste
35/2: %paste
35/3: plt.imshow(im)
35/4: plt.show()
35/5: im
35/6: N = np.array(im.shape) #image Size
35/7: tupleN = tuple(N)
35/8: pctg = 0.25 # undersampling factor
35/9: P = 5 # Variable density polymonial degree
35/10: ph = tf.matlab_style_gauss2D(im,shape=(5,5));
35/11: ph
35/12: pdf = samp.genPDF(N,P,pctg,radius = 0.1,cyl=[0]) # Currently not working properly for the cylindrical case -- can fix at home
35/13: # Set the sampling pattern -- checked and this gives the right percentage
35/14: k = samp.genSampling(pdf,10,60)[0].astype(int)
35/15: data = np.fft.ifftshift(k)*tf.fft2c(im,ph=ph)
35/16: #ph = phase_Calculation(im,is_kspace = False)
35/17: #data = np.fft.ifftshift(np.fft.fftshift(data)*ph.conj());
35/18: # IMAGE from the "scanner data"
35/19: im_scan = tf.ifft2c(data,ph=ph)
35/20: # Primary first guess. What we're using for now. Density corrected
35/21: im_dc = tf.ifft2c(data/np.fft.ifftshift(pdf),ph=ph).flatten().copy()
35/22: plt.imshow(im_dc)
35/23: plt.imshow(abs(im_dc))
35/24: plt.imshow(abs(im_dc.reshape(256,256)))
35/25: plt.imshow(abs(im_dc.reshape(8,8)))
35/26: plt.show()
35/27: im_dc
35/28: phg
35/29: ph
35/30: data
35/31: k
35/32: pdf
35/33: pdf = samp.genPDF(N,P,pctg,radius = 0.3,cyl=[0])
35/34: pdf
35/35: k = samp.genSampling(pdf,10,5)[0].astype(int)
35/36: k
35/37: k = samp.genSampling(pdf,50,2)[0].astype(int)
35/38: k
35/39: data = np.fft.ifftshift(k)*tf.fft2c(im,ph=ph)
35/40: im_scan = tf.ifft2c(data,ph=ph)
35/41: im_dcan
35/42: im_scan
35/43: plt.imshow(abs(im_scan))
35/44: plt.show()
35/45: im_dc = tf.ifft2c(data/np.fft.ifftshift(pdf),ph=ph).flatten().copy()
35/46: plt.imshow(abs(im_dc))
35/47: plt.imshow(abs(im_dc).reshape(8,8_)
35/48: plt.imshow(abs(im_dc).reshape(8,8))
35/49: plt.show()
35/50: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L)
35/51: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L)
35/52: dirs = None
35/53: M = None
35/54: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L)
35/55: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
35/56: im_res = im_result['x'].reshape(256,256);
35/57: im_res = im_result['x'].reshape(8,8);
35/58: rwt.wavelets('haar')
35/59: import rwt
35/60: rwt.wavelets('haar')
35/61: rwt.wavelets.haar
35/62: rwt.wavelets.waveletCoeffs('haar')
35/63: rwt.wavelets.daubcqf(2)
35/64: rwt.wavelets.daubcqf(2)[0]
35/65: im
35/66: h,L = rwt.wavelets.daubcqf(2)[0]
35/67: h,L = rwt.wavelets.daubcqf(2)
35/68: h
35/69: L
35/70: XFMdata = dwt(data_to_xfm,h,L)
35/71: XFMdata = rwt.dwt(data_to_xfm,h,L)[0]
35/72: data_to_xfm = im
35/73: XFMdata = rwt.dwt(data_to_xfm,h,L)[0]
35/74: XFMdata
35/75: XFMdata = rwt.dwt(data_to_xfm,h,2)[0]
35/76: XFMdata
35/77: plt.imshow(XFMdata)
35/78: plt.show()
35/79: XFMdata = rwt.dwt(data_to_xfm,h,L)[0]
35/80: plt.imshow(XFMdata)
35/81: plt.show()
35/82: XFMdata = rwt.dwt(data_to_xfm,h,1)[0]
35/83: plt.imshow(XFMdata)
36/1: %paste
36/2: %paste
36/3: %paste
36/4: scaling_factor
36/5: scaling_factor = 2
36/6: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,scaling_factor,L)
36/7: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
36/8: im_res = im_result['x'].reshape(8,8);
36/9: plt.imshow(im_res)
36/10: plt.imshow(abs(im_res))
36/11: plt.show()
36/12: reload(recon_CS)
36/13: from recon_CS import *
36/14: im_result = opt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
37/1: import simpleBox
37/2: %paste
34/12: im
34/13: im.shape
34/14: tv = tf.TV(im,ph)
34/15: tv = tf.TV(im,N,strtag)
34/16: tv
34/17: gtv = grads.gTV(x,N,strtag,0)
34/18: gtv = grads.gTV(im,N,strtag,0)
34/19: plt.imshow(gtv.real)
34/20: plt.show()
34/21: plt.imshow(gtv.real)
34/22: plt.imshow(gtv.real)
34/23: gtv = grads.gTV(im_dc,N,strtag,0)
34/24: plt.imshow(gtv.real)
34/25: plt.show()
34/26: plt.imshow(gtv.real)
34/27: plt.colorbar()
34/28: plt.show()
34/29: tv = tf.TV(im,N,strtag)
34/30: plt.imshow(tv[:,:,0])
34/31: plt.imshow(tv[:,:,0].real)
34/32: plt.show()
34/33: plt.show()
34/34: plt.imshow(tv[0,:,:].real)
34/35: plt.show()
34/36: tv[0,125,125]
34/37: tv[0,137,123]
34/38: TV_dataRoll = np.roll(tv[0,:,:],1,axis=0)
34/39: plt.imshow(TV_dataRoll)
34/40: tv.dtype
34/41: plt.imshow(TV_dataRoll.real)
34/42: plt.colorbar
34/43: plt.show()
34/44: plt.imshow(TV_dataRoll.real)
34/45: plt.colorbar()
34/46: plt.show()
34/47: plt.imshow(TV_dataRoll.real)
34/48: plt.show()
34/49: TV_dataRoll = np.roll(tv[1,:,:],1,axis=1)
34/50: plt.imshow(TV_dataRoll.real)
34/51: plt.show()
34/52: plt.imshow(-np.tanh(k*(tv[0,:,:])))
34/53: plt.imshow(-np.tanh(k*(tv[0,:,:])).real)
34/54: plt.show()
37/3: ls
38/1: %paste
38/2: EPS = np.finfo(float).eps
38/3: img_sz = N
38/4: img_sz = (256,256)
38/5: p = 5
38/6: pctg 0.25
38/7: pctg = 0.25
38/8: l_norm = 2
38/9: radius = 0.1
38/10: cyl = [1,180,180]
38/11: minval = 0.0
38/12: maxval = 1.0
38/13: val = 0.5
38/14:
if cyl[0] == 1:
        img_sz_hold = cyl[1:]
        cir = True
38/15: cir
38/16: img_sz_hold
38/17: %paste
38/18:
if cyl[0] == 1:
        img_sz_hold = cyl[1:]
        cir = True
39/1: %paste
39/2: zpad_mat
39/3: %paste
39/4: %paste
39/5: %paste
39/6: %paste
39/7: %paste
39/8: %paste
39/9: im_sz_hold
39/10: img_sz_hold
39/11: sx = img_sz_hold[0]
39/12: sy = img_sz_hold[1]
39/13: PCTG = int(np.floor(pctg*sx*sy))
39/14: PCTG
39/15: 180*180
39/16: 180*180*0.25
39/17: [x,y] = np.meshgrid(np.linspace(-1,1,sy),np.linspace(-1,1,sx))
39/18: x
39/19: y
39/20: r = np.sqrt(x**2 + y**2)
39/21: r
39/22: r.shape
39/23:
if cyl[0]:
    r[np.where(r > 1)] = 1
39/24: r
39/25: plt.imshow(r)
39/26: plt.show()
39/27: idx = np.where(r < radius)
39/28: plt.imshow(idx)
39/29: idx
39/30: radius
39/31: radius = 0.1
39/32: idx = np.where(r < radius)
39/33: idx
39/34: pdf = pdf = (1-r)**p
39/35: plt.imshow(pdf)
39/36: plt.show()
39/37: pdf[idx] = 1
39/38: plt.imshow(pdf)
39/39: plt.show()
39/40: %paste
39/41: plt.imshow(pdf)
39/42: plt.show()
39/43: pdf
39/44: pdf(np.array([]))
39/45: pdf(np.array())
39/46: pdf([])
39/47: pdf[np.array([])]
39/48: pdf[None]
39/49: outcyl = np.where(r > 1)
39/50: r[outcyl] = 1
39/51: %paste
39/52: plt.imshow(r)
39/53: plt.show()
39/54: %paste
39/55: %paste
40/1: %paste
40/2: r
40/3: np.sum(pdf)
40/4: PCTG
40/5: %paste
40/6: pdf
40/7: plt.imshow(pdf)
40/8: plt.show()
40/9:
if zpad_mat:
        pdf = zpad(img_sz,pdf)
40/10:  %paste
40/11: %paste
40/12:
if zpad_mat:
        pdf = zpad(img_sz,pdf)
40/13: plt.imshow(pdf)
40/14: plt.show()
40/15: %paste
40/16: genPDF((256,256),5,0.25,radius = 0.2,cyl = [1,180,180],disp=True)
40/17: img_sz = [256,256]
40/18: img_sz = [180,180]
40/19: dirFile = 'GradientVectorMag.txt'
40/20: engfile = None
40/21: import itertools
40/22: dirs = np.load(dirFile)
40/23: import os
40/24: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
40/25: dirs = np.load(dirFile)
40/26: dirs = np.loadtxt(dirFile)
40/27: dirs
40/28: n = int(dirs.shape[0])
40/29: n
40/30: r = np.zeros([n,n])
40/31: r
40/32:
for i in xrange(n):
    if dirs[i,2] < 0:
        dirs[i,:] = -dirs[i,:]
40/33:
dirs[i,2[
]]
40/34: dirs[i,2]
40/35: dirs
40/36:
for i in xrange(n):
    for j in xrange(n):
        r[i,j] = min(np.sqrt(np.sum((-dirs[i,:] - dirs[j,:])**2)),np.sqrt(np.sum((dirs[i,:] - dirs[j,:])**2)))
40/37: plt.imshow(r)
40/38: plt.show()
40/39: np.all(r.T == r)
40/40: invR = 1/(r+EPS)
40/41: EPS = np.finfo(float).eps
40/42: invR = 1/(r+EPS)
40/43: r1 = r.copy()
40/44: dirs = np.loadtxt(dirFile)
40/45:
for i in xrange(n):
    for j in xrange(n):
        r[i,j] = min(np.sqrt(np.sum((-dirs[i,:] - dirs[j,:])**2)),np.sqrt(np.sum((dirs[i,:] - dirs[j,:])**2)))
40/46: np.all(r1 == r)
40/47: k = int(np.floor(n*pctg))
40/48: k
40/49: n
40/50: combs = np.array(list(itertools.combinations(range(1,n+1),k)))
40/51: combs.shape
40/52: vecs = np.array(list(itertools.combinations(range(1,k+1),2)))
40/53: vecs.shape
40/54:
for i in xrange(combs.shape[0]):
    for j in xrange(vecs.shape[0]):
        engStart[i] = engStart[i] + invR[combs[i,vecs[j,0]-1]-1,combs[i,vecs[j,1]-1]-1]
40/55: engStart = np.zeros([combs.shape[0]])
40/56:
for i in xrange(combs.shape[0]):
    for j in xrange(vecs.shape[0]):
        engStart[i] = engStart[i] + invR[combs[i,vecs[j,0]-1]-1,combs[i,vecs[j,1]-1]-1]
40/57: plt.plot(engStart)
40/58: plt.show()
40/59: np.save('testingData/energies.npy',engStart)
40/60: ind = engStart.argsort()
40/61: ind
40/62: eng = engStart[ind]
40/63: eng
40/64: plt.plot(eng)
40/65: plt.show()
40/66: a = np.arange(12).reshape(4,3)
40/67: a
40/68: a[(0,3,1,2),:]
40/69: a[(0,3,1,2),]
40/70:  vecsind = combs[ind,]
40/71: vecsind = combs[ind,]
40/72: vecsind
40/73: dirs[2,:]
40/74: vecsind
40/75: eng
40/76: ind
40/77: engStart[ind[0]]
40/78: locs = np.zeros([n,nmins])
40/79: nmins = 4
40/80: n
40/81: locs = np.zeros([n,nmins])
40/82: vecsMin = np.zeros([k,n*nmins])
40/83: locs.shape
40/84: vecsMin.shape
40/85:
for i in range(n):
    locs[i,] = np.array(np.where(vecsInd == i+1))[0,0:nmins]
    vecsMin[...,nmins*i:nmins*(i+1)] = vecsInd[locs[i,].astype(int),...].T-1
40/86: vecsInd = vecsind
40/87: %paste
40/88:
for i in range(n):
    locs[i,] = np.array(np.where(vecsInd == i+1))[0,0:nmins]
    vecsMin[...,nmins*i:nmins*(i+1)] = vecsInd[locs[i,].astype(int),...].T-1
40/89: cyl
40/90: radius
40/91: engStart[0]
40/92: eng[1]
40/93: eng[0]
40/94: locs[1,]
40/95: locs[0,]
40/96: np.max(vecsInd)
40/97: np.min(vecsInd)
40/98: combs = np.array(list(itertools.combinations(range(0,n),k)))
40/99: vecs = np.array(list(itertools.combinations(range(0,k),2)))
40/100: engStart = np.zeros([combs.shape[0]])
40/101:
for i in xrange(combs.shape[0]):
    for j in xrange(vecs.shape[0]):
        engStart[i] = engStart[i] + invR[combs[i,vecs[j,0]],combs[i,vecs[j,1]]]
40/102: engStart[0]
40/103: np.save('testingData/energies.npy',engStart)
40/104:
for i in range(n):
    locs[i,] = np.array(np.where(vecsInd == i))[0,0:nmins]
    vecsMin[:,nmins*i:nmins*(i+1)] = vecsInd[locs[i,].astype(int),:].T
40/105: vecsMin = np.zeros([k,n*nmins])
40/106: i
40/107: locs[i,] = np.array(np.where(vecsInd == i))[0,0:nmins]
40/108: vecsInd == i
40/109: i
40/110: ind = engStart.argsort() # Sort from lowest energy (farthest apart) to highest
40/111: eng = engStart[ind] # Again, sort
40/112: vecsInd = combs[ind,] # This tells us the vectors that we're going to be using for our mins
40/113: locs = np.zeros([n,nmins]) # This gives us the mins for our individual vectors
40/114: vecsMin = np.zeros([k,n*nmins])
40/115:
for i in range(n):
    locs[i,] = np.array(np.where(vecsInd == i))[0,0:nmins]
    vecsMin[:,nmins*i:nmins*(i+1)] = vecsInd[locs[i,].astype(int),:].T
40/116: locs[0,:]
40/117: locs[36,:]
40/118: locs[26,:]
40/119: vecsMin = unique_rows(vecsMin.T).astype(int)
40/120: vecsMin
40/121: amts = np.zeros(n)
40/122:
for i in xrange(n):
    amts[i] = vecsMin[vecsMin == i].size
40/123: srt = amts.argsort()
40/124: cts = amts[srt]
40/125: cts
40/126: qEng = np.percentile(eng,20)
40/127: qEng
40/128: vecsUnique,vecs_idx = np.unique(vecsInd,return_index = True)
40/129: vecs_idx
40/130:
while cts[-1]/cts[0] >= 1.1:
        srt_hold = np.reshape(srt.copy(),(1,len(srt)))[0,:k]+1
        srt_hold.sort()
        # We need to add one here as index and direction number differ by a value of one
        indx = np.where(np.all(srt_hold == vecsInd,axis = 1))
41/1: img_sz = [256,256]
41/2: dirFile = 'GradientVectorMag.txt'
41/3: pctg = 0.25
41/4: cyl = [1,180,180]
41/5: radius = 0.2
41/6: nmins = 5
41/7: endSize = [256,256]
41/8: engfile = None
41/9: %paste
41/10: cts
41/11: srt
41/12: %paste
41/13: %paste
41/14: %paste
41/15: %paste
41/16: import os
41/17: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
41/18: %paste
41/19: %paste
41/20: %paste
41/21: vecsMin = unique_rows(vecsMin.T).astype(int)
41/22: amts = np.zeros(n)
41/23:
for i in xrange(n):
    amts[i] = vecsMin[vecsMin == i].size
41/24: srt = amts.argsort()
41/25: cts = amts[srt]
41/26: qEng = np.percentile(eng,20)
41/27: vecsUnique,vecs_idx = np.unique(vecsInd,return_index = True)
41/28: %paste
41/29: %paste
41/30: srt_hold = srt.copy().reshape(1,-1)[0,:k]
41/31: srt
41/32: srt_hold
41/33: srt_hold.sort()
41/34: srt_hold
41/35: indx = np.where(np.all(srt_hold == vecsInd,axis = 1))
41/36: indx
41/37: eng[indx]
41/38:
if eng[indx] < qEng:
    vecsMin = np.vstack([vecsMin,srt_hold])
41/39: vecsMin
41/40: srt_hold
41/41: %paste
41/42: vecs_Min
41/43: vecsMin
41/44: vecsMin.shape
41/45: vecsMin = unique_rows(vecsMin.T).astype(int)
41/46: amts = np.zeros(n)
41/47:
for i in xrange(n):
        amts[i] = vecsMin[vecsMin == i].size
    srt = amts.argsort()
    cts = amts[srt]
41/48:
for i in xrange(n):
        amts[i] = vecsMin[vecsMin == i].size
    srt = amts.argsort()
cts = amts[srt]
41/49: %paste
41/50: vecsUnique,vecs_idx = np.unique(vecsInd,return_index = True)
41/51: vecsInd
41/52: cts
41/53: srt
41/54: cts
41/55: vecsMin
41/56: vecsMin.shape
41/57: vecsMin = np.zeros([k,n*nmins])
41/58:
for i in range(n):
    locs[i,] = np.array(np.where(vecsInd == i))[0,0:nmins]
    vecsMin[:,nmins*i:nmins*(i+1)] = vecsInd[locs[i,].astype(int),:].T
41/59: vecsMin.shape
41/60: vecsMin = unique_rows(vecsMin.T).astype(int)
41/61: vecsMin
41/62: amts = np.zeros(n)
41/63: %paste
41/64: vecsUnique,vecs_idx = np.unique(vecsInd,return_index = True)
41/65: srt
41/66: cts
41/67: vecsMin.shape
41/68: nmins
41/69: srt
41/70: srt_hold = srt.copy().reshape(1,-1)[0,:k]
41/71: srt_hold
41/72: srt_hold = srt.copy().reshape(1,-1)[0,:k].sort()
41/73: srt_hold
41/74: srt_hold = srt.copy().reshape(1,-1)[0,:k]
41/75: srt_hold
41/76: srt_hold.sort()
41/77: srt_hold
41/78: indx = np.where(np.all(srt_hold == vecsInd,axis = 1))
41/79: indx
41/80: eng(indx)
41/81: eng[indx]
41/82: vecsMin = np.vstack([vecsMin,srt_hold])
41/83: vecsMin
41/84:
for i in xrange(30):
    amts[i] = vecsMin[vecsMin == i].size
41/85: %paste
41/86: %paste
41/87: vecsMin
41/88: vecsMin[:,0]
41/89: vecsMin[1,:]
41/90: vecsMin = np.zeros([k,n*nmins])
41/91: %paste
41/92: vecsMin = unique_rows(vecsMin.T).astype(int)
41/93: vecsMin
41/94: amts = np.zeros(n)
41/95: cts
41/96:
for i in xrange(n):
    amts[i] = vecsMin[vecsMin == i].size
41/97: srt = amts.argsort()
41/98: cts = amts[srt]
41/99: vecsUnique,vecs_idx = np.unique(vecsInd,return_index = True)
41/100: vecsUnique
41/101: srt_hold = srt.copy().reshape(1,len(srt))[0,:k]
41/102: srt_hold
41/103: srt_hold.sort()
41/104: indx = np.where(np.all(srt_hold == vecsInd,axis = 1))
41/105: vecsMin = np.vstack([vecsMin,srt_hold])
41/106:
for i in xrange(30):
    amts[i] = vecsMin[vecsMin == i].size
41/107: srt = amts.argsort()
41/108: cts = amts[srt]
41/109: cts
41/110: cts[-1]
41/111: cts[-1]/cts[0]
41/112: srt_hold = srt.copy().reshape(1,len(srt))[0,:k]
41/113: srt_hold
41/114: srt_hold.sort()
41/115: indx = np.where(np.all(srt_hold == vecsInd,axis = 1))
41/116: eng[indx] < qEng
41/117: vecsMin = np.vstack([vecsMin,srt_hold])
41/118:
for i in xrange(30):
    amts[i] = vecsMin[vecsMin == i].size
41/119: srt = amts.argsort()
41/120: cts = amts[srt]
41/121: cts
41/122: srt_hold = srt.copy().reshape(1,len(srt))[0,:k]
41/123: srt_hold.sort()
41/124: srt_hold
41/125: indx = np.where(np.all(srt_hold == vecsInd,axis = 1))
41/126: eng(indx)
41/127: eng[indx]
41/128: eng[indx] < qEng
41/129: vecsMin = np.vstack([vecsMin,srt_hold])
41/130: %paste
41/131: %paste
41/132: vecsMin = np.zeros([k,n*nmins])
41/133: %paste
41/134: vecsMin = unique_rows(vecsMin.T).astype(int)
41/135: amts = np.zeros(n)
41/136:
for i in xrange(n):
    amts[i] = vecsMin[vecsMin == i].size
41/137: srt = amts.argsort()
41/138: cts = amts[srt]
41/139: qEng
41/140: %paste
41/141: %paste
41/142:
while np.any(arr == 0):
    st = np.ceil(n*np.random.random(1))
    if not np.any(arr == st):
        arr[cnt] = st;
41/143:
while np.any(arr == 0):
    st = np.ceil(n*np.random.random(1))
    if not np.any(arr == st):
        arr[cnt] = st;
        print(arr)
41/144:
while np.any(arr == 0):
    st = np.ceil(n*np.random.random(1))
    if not np.any(arr == st):arr[-1] = st;
41/145:
while np.any(arr == 0):
    st = np.ceil(n*np.random.random(1))
    if not np.any(arr == st):
        arr[-1] = st;
41/146:
while np.any(arr == 0):
    st = np.ceil(n*np.random.random(1))
    if not np.any(arr == st):
        arr[cnt] = st;
        cnt+=1
41/147: arr
41/148: %paste
41/149: %paste
41/150: vecsMin
41/151: amts
41/152: %paste
41/153: amts
41/154: vecsMin
41/155: %paste
41/156: arr
41/157: vecsMin
41/158: amts
41/159: vecsMin = np.zeros([k,n*nmins])
41/160:
for i in range(n):
    locs[i,] = np.array(np.where(vecsInd == i))[0,0:nmins]
    vecsMin[:,nmins*i:nmins*(i+1)] = vecsInd[locs[i,].astype(int),:].T
41/161: vecsMin = unique_rows(vecsMin.T).astype(int)
41/162: amts = np.zeros(n)
41/163: %paste
41/164: %paste
41/165: vecsMin
41/166: amts
41/167: %paste
41/168: cts
41/169: 29/24
41/170: %paste
41/171: [x,y] = np.meshgrid(np.linspace(-1,1,img_sz[1]),np.linspace(-1,1,img_sz[0]))
41/172: r = np.sqrt(x**2 + y**2)
41/173: [rows,cols] = np.where(r <= 1) and np.where(r > radius)
41/174: rows
41/175: [rx,ry] = np.where(r <= radius)
41/176: img_sz
41/177: img_sz = [180,180]
41/178: samp = np.zeros(hstack([img_sz,n]))
41/179: samp = np.zeros(np.hstack([img_sz,n]))
41/180: nSets = np.hstack([vecsMin.size, 1])
41/181: vecsMin.size
41/182:
for i in xrange(rows):
    val = np.ceil(nSets*np.random.random(1))
    choice = vecsMin[val,]
    samp[rows[i],cols[i],choice] = 1
41/183: val
41/184: val = np.ceil(nSets*np.random.random(1))
41/185: choice
41/186: val
41/187: nSets
41/188: vecsMin.size
41/189:
for i in xrange(rows):
    val = np.ceil(nSets[0]*np.random.random(1))
    choice = vecsMin[val,]
    samp[rows[i],cols[i],choice] = 1
41/190: i
41/191: rows[i]
41/192: xrange(rows)
41/193:
for i in xrange(len(rows)):
    val = np.ceil(nSets[0]*np.random.random(1))
    choice = vecsMin[val,]
    samp[rows[i],cols[i],choice] = 1
41/194: rows[i]
41/195: i
41/196: cols[i]
41/197: i
41/198: plt.imshow(np.where(r <= 1) and np.where(r > radius))
41/199: plt.show()
41/200: np.all(rows == cols)
41/201: plt.imshow(np.where(r <= 1) and np.where(r > radius)).reshape(256,256))
41/202: plt.imshow((np.where(r <= 1) and np.where(r > radius)).reshape(256,256))
41/203: rows
41/204: rows.size
41/205: r
41/206: (r<=1).size
41/207: np.where(r<=1).size
41/208: len(np.where(r<=1))
41/209: np.where(r<=1)
41/210: len(np.where(r<=1)[0])
41/211: np.where(r <= 1 and r > radius)
41/212: np.where(np.all(r <= 1,r > radius))
41/213: r<=1
41/214: int(r<=1)*int(r > radius)
41/215: int(r<=1)
41/216: int(r <= 1)
41/217: r<=1
41/218: (r<=1).astype(int)
41/219: (r<=1).astype(int)*(r>radius).astype(int)
41/220: np.where((r<=1).astype(int)*(r>radius).astype(int) == 1)
41/221: [rows,cols] = np.where((r <= 1).astype(int)*(r > radius).astype(int) == 1)
41/222: [rx,ry] = np.where(r <= radius)
41/223: rows
41/224: [rows,cols] = np.where(((r <= 1).astype(int)*(r > radius).astype(int)) == 1)
41/225: rows
41/226: cols
41/227: r[1,112]
41/228: plt.imshow(r)
41/229: plt.show()
41/230:
for i in xrange(len(rows)):
    val = np.ceil(nSets[0]*np.random.random(1))
    choice = vecsMin[val,]
    samp[rows[i],cols[i],choice] = 1
41/231: val
41/232: val = np.ceil(nSets[0]*np.random.random(1)).astype(int)
41/233: val
41/234: choice = vecsMin[val,]
41/235: nSets = np.hstack([vecsMin.shape, 1])
41/236: val = np.ceil(nSets[0]*np.random.random(1)).astype(int)
41/237: choice = vecsMin[val,]
41/238: samp[rows[i],cols[i],choice] = 1
41/239: choice
41/240: choice.astype(int)
41/241: samp[rows[i],cols[i],choice] = 1
41/242: rows[i]
41/243: cols[i]
41/244: choice
41/245: a = zeros(2,3,4)
41/246: a = np.zeros(2,3,4)
41/247: a = np.zeros([2,3,4])
41/248: a[2,3,[1,2,3]] = 1
41/249: a[1,2,[0,2,3]] = 1
41/250: a[1,2,1]
41/251: a[1,2,2]
41/252: samp
41/253: samp[rows[i],cols[i]]
41/254: samp[rows[i],cols[i],choice]
41/255: samp[rows[i],cols[i],choice.astype(int)]
41/256: choice
41/257: choice.astype(int)
41/258: %paste
41/259: %paste
41/260: i
41/261: cols[i]
41/262: samp.shape
41/263: max[cols]
41/264: max(cols)
41/265: img_sz
41/266: [x,y] = np.meshgrid(np.linspace(-1,1,img_sz[1]),np.linspace(-1,1,img_sz[0]))
41/267: r = np.sqrt(x**2 + y**2)
41/268: [rows,cols] = np.where((r <= 1).astype(int)*(r > radius).astype(int) == 1)
41/269: [rx,ry] = np.where(r <= radius)
41/270: samp = np.zeros(np.hstack([img_sz,n]))
41/271: nSets = np.hstack([vecsMin.shape, 1])
41/272: %paste
41/273:
for i in xrange(len(rx)):
    samp[rx[i],ry[i],:] = 1
41/274: plt.imshow(samp[:,:,10])
41/275: plt.show()
41/276: endSize
41/277: samp_final = np.zeros(np.hstack([n,endSize]))
41/278: samp_final.shape
41/279:
for i in xrange(n):
    samp_final[:,:,i] = np.resize(zpad(samp[i,:,:].flat,endSize),np.hstack([1,endSize]))
41/280: %paste
41/281:
for i in xrange(n):
    samp_final[:,:,i] = np.resize(zpad(samp[i,:,:].flat,endSize),np.hstack([1,endSize]))
41/282: samp.dtype
41/283: samp[i,:,:].flat
41/284: samp
41/285: samp[i,:,:].flat().shape
41/286: samp[i,:,:].flat.shape
41/287: samp_final[:,:,i] = zpad(samp[i,:,:].reshape(img_sz),endSize).reshape(1,endSize)
41/288: zpad(samp[i,:,:].reshape(img_sz),endSize).shape
41/289: zpad(samp[i,:,:].reshape(img_sz))
41/290: samp[i,:,:].shape
41/291: samp = np.zeros(np.hstack([n,img_sz]))
41/292: samp[i,:,:].shape
41/293: nSets = np.hstack([vecsMin.shape, 1])
41/294: %paste
41/295: samp_final = np.zeros(np.hstack([n,endSize]))
41/296: samp_final.shape
41/297: samp_final[i,:,:] = zpad(samp[i,:,:].reshape(img_sz),endSize).reshape(1,endSize)
41/298: zpad(samp[i,:,:].reshape(img_sz),endSize)
41/299: samp
41/300: samp[i,:,:].shape
41/301: i
41/302: i = 0
41/303: samp[i,:,:].shape
41/304: zpad(samp[i,:,:].reshape(img_sz),endSize).reshape(1,endSize)
41/305:  zpad(samp[i,:,:].reshape(img_sz),endSize)
41/306: zpad(samp[i,:,:].reshape(img_sz),endSize)
41/307: zpad(samp[i,:,:].reshape(img_sz))
41/308: samp[i,:,:].shape
41/309: endSize
41/310: endSize.dtype
41/311: %paste
41/312: zpad(samp[i,:,:].reshape(img_sz),endSize)
41/313: %paste
41/314: zpad(samp[i,:,:].reshape(img_sz),endSize)
41/315: samp_final[i,:,:] = zpad(samp[i,:,:].reshape(img_sz),endSize).reshape(1,endSize)
41/316: i
41/317: zpad(samp[i,:,:].reshape(img_sz),endSize)
41/318: zpad(samp[i,:,:].reshape(img_sz),endSize).reshape(np.hstack[1,endSize])
41/319: samp_hold = zpad(samp[i,:,:].reshape(img_sz),endSize)
41/320: samp_final[i,:,:] = samp_hold.reshape(np.hstack([1,endSize]))
41/321: samp_final[i,:,:]
41/322: plt.imshow(samp_final[0,:,:])
41/323: plt.show()
34/55: im
34/56: arrays = [np.random.randn(3, 4) for _ in range(10)]
34/57: arrays
34/58: arrays = [im for _ in range(30)]
34/59: arrays.shape
34/60: np.stack(arrays,axis=1)
34/61: np
34/62: np.dstack(arrays)
34/63: im2 = np.dstack(arrays)
34/64: im2.shape
34/65: im3 = np.rollaxis(im2,1)
34/66: im3.shape
34/67: im3 = np.rollaxis(im2,1)
34/68: im3 = np.rollaxis(im2,2,0)
34/69: im.shape
34/70: im3 = np.rollaxis(im2,2,1)
34/71: im.shape
34/72: im3.shape
34/73: im3 = np.rollaxis(im2,2,0)
34/74: im3.shape
34/75: plt.imshow(im3[1,:,:])
34/76: plt.show()
34/77: strtag3 = ['diff','spatial','spatial']
34/78: strtag3 = ['spatial','spatial','spatial']
34/79: tf.TV(im3,im3.shape,strtag3)
34/80: tvtest = tf.TV(im3,im3.shape,strtag3)
34/81: tvtest.shape
34/82: np.all(tvtest[0,:,:] == 0)
34/83: np.all(tvtest[1,:,:] == 0)
34/84: plt.show(tvtest[1,0,:,:] )
34/85: plt.imshow(tvtest[1,0,:,:] )
34/86: plt.imshow(abs(tvtest[1,0,:,:]))
34/87: plt.show()
34/88: dirs
41/324: dirs
41/325: nmins
41/326: mins = 4
41/327: nmins = 4
41/328: num_vecs = dirs.shape[0]
41/329: num_vecs
41/330: dp = np.zeros([num_vecs,num_vecs])
41/331:
 for i in xrange(num_vecs):
    for j in xrange(num_vecs):
        dp[i,j] = np.dot(dirs[i,:],dirs[j,:])
41/332:
for i in xrange(num_vecs):
    for j in xrange(num_vecs):
        dp[i,j] = np.dot(dirs[i,:],dirs[j,:])
41/333: dp
41/334: np.all(dp.T == dp.T)
41/335: inds = np.fliplr(np.argsort(abs(dp)))
41/336: inds
41/337: inds[0:4,4:12]
41/338: inds[0:4,4:12]+1
41/339: inds[:,1:nmins+1]
41/340: inds[:,1:nmins+1].shape
41/341: %paste
41/342: inds = dot_product_with_mins(dirs,nmins)
41/343: M = np.zeros([dirs.shape[0],nmins,nmins])
41/344: [dirs.shape,nmins,nmins]
41/345: np.hstack([dirs.shape,nmins,nmins])
41/346: qDir
41/347: qDir = 0
41/348: A = np.array([])
41/349: A.shape = (nmins,0)
41/350: A
41/351:
for dirComp in xrange(dirs.shape[1]):
    datHold = np.reshape(dirs[inds[qDir,:],dirComp]-dirs[qDir,dirComp],(nmins,1))
    datHold = datHold/np.linalg.norm(datHold)
    A = np.hstack([A, datHold])
41/352: A
41/353: inds
41/354: qDir
41/355: inds[qDir,:]
41/356: dirs[inds[qDir,:],dirComp]
41/357: dirs
41/358: dirs[inds[qDir,:]]
41/359: dirComp
41/360: dirs.shape
41/361: dirs
41/362: dirs[qDir]
41/363: dirs[qDir,dirComp]
41/364: dirs[inds[qDir,:],:]
41/365: dirs[inds[qDir,:],:]-dirs[qDir,:]
41/366: qDir
41/367: dirs[qDir]
41/368: A = np.array([])
41/369: A.shape = (nmins,0)
41/370: datHold = dirs[inds[qDir,:],dirComp]-dirs[qDir,:]
41/371: datHold = dirs[inds[qDir,:],:]-dirs[qDir,:]
41/372: datHold
41/373: datHold/np.linalg.norm(datHold)
41/374: A = np.hstack([A, datHold])
41/375: A
41/376: Ahat = np.dot(inv(np.dot(A.T,A)),A.T)
41/377: dirs[qDir,:]
41/378: dirs[inds[qDir],:]
41/379: dirs
41/380: dirs
41/381:
for i in range(30):
    if dirs[i,2] < 0:
        dirs[i,:] = -dirs[i,:]
41/382: dirs
42/1: dirs = np.loadtxt(dirFile)
42/2: import numpy as np
42/3: dirs = np.loadtxt(dirFile)
42/4: dirFile = 'GradientVectorMag.txt'
42/5: import os
42/6: import os.path
42/7: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
42/8: dirs = np.loadtxt(dirFile)
42/9:
for i in range(30):
    if dirs[i,2] < 0:
        dirs[i,:] = -dirs[i,:]
42/10: nmins = 4
42/11: inds = dot_product_with_mins(dirs,nmins)
42/12:
def dot_product_with_mins(dirs,
                          nmins = 4):
        '''
        This code exists to quickly calculate the closest directions in order to quickly get the values we need to calculate the mid matrix for the least squares fitting
        '''
        #dirs = np.loadtxt(filename) # Load in the file
        num_vecs = dirs.shape[0] # Get the number of directions
42/13:     dp = np.zeros([num_vecs,num_vecs]) # Preallocate for speed
42/14:
    for i in xrange(num_vecs):
            for j in xrange(num_vecs):
                    dp[i,j] = np.dot(dirs[i,:],dirs[j,:]) # Do all of the dot products
42/15:     inds = np.fliplr(np.argsort(abs(dp))) # Sort the data based on *rows*
43/1: import numpy as np
43/2: import os.path
43/3: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
43/4: dirFile = 'GradientVectorMag.txt'
43/5: dirs = np.loadtxt(dirFile)
43/6: nmins = 4
43/7: %paste
43/8: %paste
43/9: inds = dot_product_with_mins(dirs,nmins)
43/10: inds
43/11: M = np.zeros([dirs.shape[0],nmins,nmins])
43/12: qDir = 0
43/13: A = np.array([])
43/14: A.shape = (nmins,0)
43/15: datHold = dirs[inds[qDir,:],:]-dirs[qDir,:]
43/16: A = dirs[inds[qDir,:],:]-dirs[qDir,:]
43/17: A
43/18: dirs
43/19: %paste
43/20: A = dirs[inds[qDir,:],:]-dirs[qDir,:]
43/21: Ahat = np.dot(np.inv(np.dot(A.T,A)),A.T)
43/22: np.invert(A)
43/23: A
43/24: np.invert(np.dot(A.T,A))
43/25: np.dot(A.T,A)
43/26: from numpy.linalg import inv
43/27: np.dot(inv(np.dot(A.T,A)),A.T)
43/28: M[qDir,:,:] = np.dot(Ahat.T,Ahat)
43/29: Ahat = np.dot(inv(np.dot(A.T,A)),A.T)
43/30: M[qDir,:,:] = np.dot(Ahat.T,Ahat)
43/31: M
43/32: M.shape
43/33: M[1,:,:]
43/34: M[0,:,:]
43/35: %paste
43/36: M
43/37: M.shape
43/38: M[0,:,:]
43/39: inds.shape[1]
43/40: inds
43/41: inds.shape
43/42: import os.path
43/43: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
43/44: filename =
43/45: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
43/46: im = np.load(filename)
43/47: N
43/48: arrays = [im for _ in range(30)]
43/49: im2 = np.dstack(arrays)
43/50: im3 = np.rollaxis(im2,2,0)
43/51: im3.shape
43/52: x = im3
43/53: x0 = x.copy().reshape(N)
43/54: N = im3.shape
43/55: nmins = inds.shape[1]
43/56: nmins
43/57: dirloc = strtag.index("diff")
43/58: strtag = ['diff','spatial','spatial']
43/59: dirloc = strtag.index("diff")
43/60: dirloc
43/61: x0 = np.rollaxis(x0,dirloc)
43/62: x
43/63: x
43/64: x0 = x.copy().reshape(N)
43/65: x0 = np.rollaxis(x0,dirloc)
43/66: np.all(x0 == x)
43/67: dirs.shape[0]
43/68: q = 0
43/69: r = inds[q,:]
43/70: r
43/71: inds
43/72: Iq = x0[q,:,:]
43/73: Iq
43/74: Iq.shape
43/75: q
43/76: Ir = x0[r,:,:]
43/77: Ir.shape
43/78: Irq = Ir - Iq.reshape(1,nrow,ncol).repeat(nmins,0)
43/79: nrow, ncol = Iq.shape
43/80: Irq = Ir - Iq.reshape(1,nrow,ncol).repeat(nmins,0)
43/81: Irq = Ir - Iq
43/82: Irq
43/83: Irq.shape
43/84: a = np.arange(2*3*4)
43/85: a
43/86: a.shape = 2,3,4
43/87: a
43/88: b = np.arange(2,14).reshape(3,4)
43/89: b
43/90: a - b
43/91: Gdiffsq = np.zeros(np.hstack([dirs.shape[0], nrow, ncol]))
43/92: Gdiffsq.shape
43/93:
for i in xrange(nrow):
    for j in xrange(ncol):
        Gdiffsq[q,i,j] = np.dot(np.dot(Irq[:,i,j].reshape(1,nmins),M[q,:,:].reshape(nmins,nmins)),Irq[:,i,j].reshape(nmins,1))
43/94: Irq
43/95: Irq[:,i,j].shape
43/96: M[q,:,:]
43/97: a
43/98: a.shape
43/99: np.rollaxis(a,0,3).shape
43/100: np.rollaxis(a,3).shape
43/101: np.rollaxis(a,2).shape
43/102: a.shape
43/103: np.rollaxis(a,-1).shape
43/104: np.rollaxis(a,dirloc).shape
43/105: np.rollaxis(a,-dirloc).shape
43/106: np.rollaxis(a,1).shape
43/107: np.rollaxis(np.rollaxis(a,1),-1).shape
43/108: np.rollaxis(np.rollaxis(a,1),1).shape
43/109: a = np.arange(2*3*4*5).reshape(2,3,4,5)
43/110: np.rollaxis(np.rollaxis(a,1),1).shape
43/111: np.rollaxis(a,1)
43/112: np.rollaxis(a,1).shape
43/113: np.rollaxis(a,2).shape
43/114: np.rollaxis(a,2).shape
43/115: np.rollaxis(np.rollaxis(a,2),2).shape
43/116: np.rollaxis(np.rollaxis(a,2),1).shape
43/117: np.rollaxis(np.rollaxis(a,2),3).shape
43/118: a.shape
43/119: np.rollaxis(a,2).shape
43/120: np.rollaxis(np.rollaxis(a,2),0,3).shape
43/121: Gdiffsq = np.rollaxis(Gdiffsq,0,dirloc)
43/122: Gdiffsq.shape
44/1: %load simpleBox.py
44/2: %%load simpleBox.py
44/3: %loadpy simpleBox.py
44/4: %paste
44/5:
from __future__ import division
import numpy as np 
import scipy as sp
import matplotlib.pyplot as plt
import os.path
os.chdir('/home/asalerno/Documents/pyDirectionCompSense/') # Change this to the directory that you're saving the work in
import transforms as tf
import scipy.ndimage.filters
import grads
import sampling as samp
import direction as d
#from scipy import optimize as opt
import optimize as opt
plt.rcParams['image.cmap'] = 'gray'
from recon_CS import *
44/6:
filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
strtag = ['spatial','spatial']
TVWeight = 0.01
XFMWeight = 0
dirWeight = 0
#DirType = 2
ItnLim = 150
epsilon = 1e-3
l1smooth = 1e-15
xfmNorm = 1
scaling_factor = 2
L = 2
method = 'CG'
dirFile = None
nmins = None
dirs = None
M = None
44/7:
filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
strtag = ['spatial','spatial']
TVWeight = 0.01
XFMWeight = 0
dirWeight = 0
#DirType = 2
ItnLim = 150
epsilon = 1e-3
l1smooth = 1e-15
xfmNorm = 1
scaling_factor = 2
L = 2
method = 'CG'
dirFile = None
nmins = None
dirs = None
M = None
44/8:
np.random.seed(2000)

im = np.zeros([8,8]);
im[3:5,3:5] = 1;

N = np.array(im.shape) #image Size
tupleN = tuple(N)
pctg = 0.25 # undersampling factor
P = 5 # Variable density polymonial degree
ph = tf.matlab_style_gauss2D(im,shape=(5,5));
44/9:
plt.subplot(211)
plt.imshow(ph.real)
plt.title('Real Part of Phase')
plt.subplot(212)
plt.imshow(ph.imag)
plt.title('Imaginary Part of Phase')
plt.show
44/10:
plt.subplot(211)
plt.imshow(ph.real)
plt.title('Real Part of Phase')
plt.subplot(212)
plt.imshow(ph.imag)
plt.title('Imaginary Part of Phase')
plt.show()
44/11: %matplotlib inline
44/12: %matplotlib inline
44/13:
IPKernelApp.matplotlib=<CaselessStrEnum>
Default: None
Choices: ['auto', 'gtk', 'gtk3', 'inline', 'nbagg', 'notebook', 'osx', 'qt', 'qt4', 'qt5', 'tk', 'wx']
Configure matplotlib for interactive use with the default matplotlib backend.
44/14:
c.IPKernelApp.matplotlib=<CaselessStrEnum>
Default: None
Choices: ['auto', 'gtk', 'gtk3', 'inline', 'nbagg', 'notebook', 'osx', 'qt', 'qt4', 'qt5', 'tk', 'wx']
Configure matplotlib for interactive use with the default matplotlib backend.
44/15:
c.IPKernelApp.matplotlib = <CaselessStrEnum>
Default: None
Choices: ['auto', 'gtk', 'gtk3', 'inline', 'nbagg', 'notebook', 'osx', 'qt', 'qt4', 'qt5', 'tk', 'wx']
Configure matplotlib for interactive use with the default matplotlib backend.
44/16:
import IPython
print IPython.sys_info()
44/17: %matplotlib
44/18:
plt.subplot(211)
plt.imshow(ph.real)
plt.title('Real Part of Phase')
plt.subplot(221)
plt.imshow(ph.imag)
plt.title('Imaginary Part of Phase')
plt.show()
44/19:
plt.subplot(211)
plt.imshow(ph.real)
plt.title('Real Part of Phase')
plt.subplot(221)
plt.imshow(ph.imag)
plt.title('Imaginary Part of Phase')
plt.show()
44/20:
plt.subplot(211)
plt.imshow(ph.real)
plt.title('Real Part of Phase')
plt.subplot(221)
plt.imshow(ph.imag)
plt.title('Imaginary Part of Phase')
plt.show()
44/21:
plt.subplot(211)
plt.imshow(ph.real)
plt.title('Real Part of Phase')
plt.subplot(212)
plt.imshow(ph.imag)
plt.title('Imaginary Part of Phase')
plt.show()
43/123: Gdiffsq
43/124: im
43/125: x = arange(8*8*30).reshape(30,8,8)
43/126: x = np.arange(8*8*30).reshape(30,8,8)
43/127: N = x.shape
43/128: x0 = x.copy().reshape(N)
43/129: nmins = inds.shape[1]
43/130: x
43/131: nmins
43/132: dirloc = strtag.index("diff")
43/133: dirloc
43/134: x0 = np.rollaxis(x0,dirloc)
43/135: x0.shape
43/136: M
43/137: M.shape
43/138: %paste
43/139: Gdiffsq
43/140: q
43/141: q = 0
43/142: r = inds[q,:]
43/143: r
43/144: Iq = x0[q,:,:]
43/145: Iq
43/146: Ir = x0[r,:,:]
43/147: Ir.shape
43/148: Ir
43/149: Irq = Ir - Iq
43/150: Irq
43/151: i = 5
43/152: j = 3
43/153: Gdiffsq[q,i,j]
43/154:
np.dot(np.dot(Irq[:,i,j].reshape(1,nmins),M[q,:,:]),Irq[:,i,j].reshape(nmins,1)
)
43/155: Gdiffsq[q,i,j] = np.dot(np.dot(Irq[:,i,j].reshape(1,nmins),M[q,:,:]),Irq[:,i,j].reshape(nmins,1))
43/156: inds
43/157: test = []
43/158: test[0] = inds[0]
43/159: N
43/160: test = rangeN[1])
43/161: test = range(N[1])
43/162: test
43/163: test = range(N[0])
43/164: test[0] = inds[0]
43/165: test
43/166: test[1] = inds[1,0:-1]
43/167: test
43/168: inds
43/169: inds[3]
43/170: test[1] = [inds[1,0:-1],[1,2,3]]
43/171: test[1]
43/172: test[1] = [inds[1,0:-1],np.array([1,2,3]])
43/173: test[1] = [inds[1,0:-1],np.array([1,2,3])]
43/174: test[1]
43/175: dirs[test[1]]
43/176: dIHold = np.zeros(dirs.shape[0],nmins)
43/177: dIHold = np.zeros([dirs.shape[0],nmins])
43/178: dIHold
43/179: dIHold[inds[1]] = -1
43/180: dIHold
43/181: test[1]
43/182: a
43/183: a = np.arange(inds.size).reshape(inds.shape)
43/184: a
43/185: a[test[1]]
43/186: test[1]
43/187: a[18,1]
43/188: a[test[1]] = -1
43/189: a
43/190: inds[1,:]
43/191: a[0,:]
43/192: [np.repeat(kk,nmins), range(nmins)]
43/193: kk = 0
43/194: [np.repeat(kk,nmins), range(nmins)]
43/195: test[np.repeat(kk,nmins), range(nmins)]
43/196: a[np.repeat(kk,nmins), range(nmins)]
43/197: a[np.repeat(5,nmins), range(nmins)]
43/198: indsPos[kk] = np.where(inds==kk)
43/199: np.where(inds==kk)
43/200: inds[3,1]
43/201: M.shape
43/202: inds.shap
43/203: inds.shape
43/204: dI = np.zeros([n,n,nmins])
43/205: n = dirs.shape[0]
43/206: dI = np.zeros([n,n,nmins])
43/207: dI.shape
43/208: dIM = np.zeros([n,nmins,n])
43/209: dI[0,test[1]]
43/210: test[1]
43/211: test[1,0]
43/212: test[1][0]
43/213: dI[0,test[1][0],test[1][1]]
43/214: dI[0,test[1][0],test[1][1]] = 1
43/215: dI
43/216: dI[0,test[1][0],test[1][1]]
43/217: np.where(dI == 1)
43/218: test[1]
43/219: %paste
43/220: %paste
43/221: indsPos
43/222: indsNeg
43/223: dI = np.zeros([n,n,nmins])
43/224: dIM = np.zeros([n,nmins,n])
43/225: Ause = range(n)
43/226: dI[kk,indsNeg[kk][0],indsNeg[kk][1]] = -1
43/227: kk
43/228: kk = 0
43/229: dI[kk,indsNeg[kk][0],indsNeg[kk][1]] = -1
43/230: dI[kk,indsPos[kk][0],indsPos[kk][1]] = 1
43/231: dI[0]
43/232: inds
43/233: Ause[kk] = np.where(dI[kk,:,:] != 0)
43/234: Ause[kk]
43/235: dI[kk,0,0]
43/236: dI[kk,0,1]
43/237: dI[kk,Ause[kk][0],Ause[kk][1]]
43/238: Ause[kk].size
43/239: len(Ause[kk])
43/240: len(Ause[kk][0])
43/241: Ause[kk][0]
43/242: Ause[kk] = np.where(dI[kk,:,:] != 0,axis=1)
43/243: Ause[kk] = unique(np.where(dI[kk,:,:] != 0))
43/244: Ause[kk] = np.unique(np.where(dI[kk,:,:] != 0))
43/245: ?np.unique
43/246: Ause[kk]
43/247: Ause[kk] = np.unique(np.where(dI[kk,:,:] != 0)[0])
43/248: Ause
43/249: Ause[kk]
43/250: np.where(np.any(dI[kk,:,:] != 0,axis=1))
43/251: np.where(np.any(dI[kk,:,:] != 0,axis=1))[0]
43/252: Ause[kk] = np.where(np.any(dI[kk,:,:] != 0))[0]
43/253: Ause
43/254: Ause[kk]
43/255: kk
43/256: np.any(dI[kk,:,:] != 0)
43/257: np.where(np.any(dI[kk,:,:] != 0))[0]
43/258: np.where(np.any(dI[kk,:,:] != 0,axis=1))[0]
43/259: Ause[kk] = np.where(np.any(dI[kk,:,:] != 0,axis=1))[0]
43/260: Ause[kk]
43/261:
for d in xrange(len(Ause[kk][0]):
    colUse = Ause[kk]
43/262: d
43/263: d = 0
43/264:  Ause[kk][d]
43/265: Ause[kk][d]
43/266: Ause[kk][1]
43/267: Ause[kk][2]
43/268: colUse = Ause[kk][d]
43/269: colUse'
43/270: colUse
43/271: dIM[colUse,:,kk)
43/272: dIM[colUse,:,kk]
43/273: dIM[colUse,:,kk].shape
43/274: np.dot(dI(:,colUse,kk),M(:,:,colUse))
43/275: np.dot(dI[:,colUse,kk],M[:,:,colUse])
43/276: np.dot(dI[:,colUse,kk],M[:,:,colUse]).shape
43/277: dIM[colUse,:,kk] = np.dot(dI[:,colUse,kk],M[:,:,colUse])
43/278: %paste
43/279: Ause[kk]
43/280: %paste
43/281: dIM.shape
43/282: kk
43/283: colUse
43/284: dI.shape
43/285: M.shape
43/286: %paste
43/287: dI[:,colUse,kk].shape
43/288: dI.shape
43/289: dIM[colUse,:,kk] = np.dot(dI[kk,colUse,:],M[colUse,:,:])
43/290: dIM.shape
43/291: dIM[kk,:,colUse] = np.dot(dI[kk,colUse,:],M[colUse,:,:])
43/292: dIM = np.zeros([n,nmins,n])
43/293: dIM[kk,:,colUse] = np.dot(dI[kk,colUse,:],M[colUse,:,:])
43/294: dIM[0,:,0]
43/295: dIM[0]
43/296: dIM[0,:,:]
43/297: dI[0]
43/298: M[colUse]
43/299: colUse
43/300: %paste
43/301: dIM[0]
43/302: Ause
43/303:
def test():
    a,b = 1,2
43/304: A = test()
43/305: A
43/306:
def test():
    a,b = 1,2
    return a,b
43/307: A = test()
43/308: A
43/309: A[0]
43/310: import grads
43/311: import grads
43/312: a
43/313: a.shape
43/314: b
43/315: a = np.random.randn([2,4,8])
43/316: a = np.random.randn(1,[2,4,8])
43/317: a = np.random.randn()
43/318: a
43/319: a = np.random.randn(1)
43/320: a = np.random.randn(2)
43/321: a = np.random.randn(2*4*8).reshape(2,4,8)
43/322: a
43/323: a.shape
43/324: grads.gTV(a,a.shape,['spatial','spatial','spatial'])
43/325: grads.gTV(a,a.shape,['spatial','spatial','spatial'],0)
43/326: dirInfo
43/327: dirInfo = None
43/328: grads.gTV(a,a.shape,['spatial','spatial','spatial'],0)
43/329: reload grads
43/330: reload grad
43/331: reload(grads)
43/332: grads.gTV(a,a.shape,['spatial','spatial','spatial'],0)
43/333: g = grads.gTV(a,a.shape,['spatial','spatial','spatial'],0)
43/334: g
43/335: g.shape
43/336: N
43/337: a.shape
43/338: dIM
43/339: dIM.shape
43/340: inds.shape
43/341: inds
43/342: N
43/343: im
43/344: im.shape
43/345: a
43/346: x
43/347: x.shape
43/348: dDirx = np.zeros(np.hstack([N,M.shape[0]]))
43/349: d = 0
43/350: i = 1
43/351: i = 0
43/352:
for ind_q in xrange(N[i]):
    for ind_r in xrange(M.shape[0]):
        dDirx[ind_q,:,:,ind_r] = x0[inds[ind_q,ind_r],:,:] - x0[ind_q,:,:]
43/353: ind_q
43/354: ind_r
43/355: M.shape
43/356: inds[ind_q,ind_r]
43/357: M.shape[0]
43/358:
for ind_q in xrange(N[i]):
        for ind_r in xrange(M.shape[1]):
                dDirx[ind_q,:,:,ind_r] = x0[inds[ind_q,ind_r],:,:] - x0[ind_q,:,:]
43/359: dDirx
43/360: x0
43/361: ind_q
43/362: ind_r
43/363: [inds[ind_q,ind_r],:,:]
43/364: [inds[ind_q,ind_r],1,1]
43/365: inds[ind_q,ind_r]
43/366: inds
43/367: x0[0,:,:]
43/368: x0[ind_q,:,:]
43/369: x0[0,:,:] - x0[ind_q,:,:]
43/370: dDirx[ind_q,:,:,ind_r]
43/371: a
43/372: i
43/373: i = np.eye([256,256])
43/374: i = np.eye(256)
43/375: i
43/376: I = grads.tf.dwt(i)
43/377: I = grads.tf.xfm(i)
43/378: I
43/379: plt.imshow(I)
43/380: import matplotlib.pyplot as plt
43/381: plt.imshow(I)
43/382: plt.show()
43/383: im
43/384: plt.imshow(im)
43/385: plt.show
43/386: plt.show()
43/387: plt.imshow(np.dot(I,im))
43/388: plt.show()
43/389: plt.imshow(np.dot(i,im))
43/390: plt.show()
43/391: im
43/392: plt.imshow(im)
43/393: plt.show()
43/394: import transforms as tf
43/395: plt.imshow(tf.ixfm(tf.xfm(im)))
43/396: plt.show()
43/397: plt.imshow(tf.xfm(tf.xfm(im)))
43/398: plt.show()
43/399: plt.imshow(tf.ixfm(tf.xfm(im),1/2,1/2))
43/400: plt.show()
46/1: from scipy.misc import lena
46/2: >>> import matplotlib.pyplot as plt
46/3: >>> from rwt import dwt, idwt
46/4: >>> from rwt.wavelets import daubcqf
46/5: >>> img = lena()
46/6: >>> h0, h1 = daubcqf(4, 'min')
46/7: >>> L = 1
46/8: >>> y, L = dwt(img, h, L)
46/9: >>> plt.imshow(y)
46/10: >>> plt.show()
46/11: import matplotlib.pyplot as plt
46/12: from scipy.misc import lena
46/13: import matplotlib.pyplot as plt
46/14: from rwt import dwt, idwt
46/15: from rwt.wavelets import daubcqf
46/16: img = lena()
46/17: h0, h1 = daubcqf(4, 'min')
46/18: L = 1
46/19: y, L = dwt(img, h, L)
46/20: plt.imshow(y)
46/21: plt.show()
46/22: y, L = dwt(img, h, L)
46/23: y, L = dwt(img, h0, L)
46/24: y
46/25: plt.imshow(y)
46/26: plt.show()
46/27: y, L = dwt(img, h1, L)
46/28: plt.imshow(y)
46/29: plt.show()
46/30: h = [h0,h1]
46/31: y, L = dwt(img, h, L)
46/32: import pywt
46/33: pip install PyWavelets --user
47/1: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
47/2: im = np.load(filename)
47/3: import numpy as np
47/4: im = np.load(filename)
47/5: from scipy import signal
47/6: import matplotlib.pyplot as plt
47/7: signal.ricker
47/8: signal.ricker()
47/9: db = scipy.signal.daub(4)
47/10: db = signal.daub(4)
47/11: db
47/12: cwtmatr = signal.cwt(im,db,xrange(4))
47/13: cwtmatr = signal.cwt(im,db,np.arange(4))
47/14: cwtmatr = signal.cwt(im,signal.ricker,xrange(4))
47/15: cwtmatr = signal.cwt(im,signal.daub,xrange(4))
47/16: cwtmatr = signal.cwt(im,signal.daub)
47/17: cwtmatr = signal.cwt(im,signal.daub,xrange(4))
47/18: cwtmatr = signal.cwt(im,signal.daub,xrange(1))
43/401: rwt
43/402: import pywt
43/403: pywt
43/404: pywt.dwt(im,'db2')
43/405: a = pywt.dwt(im,'db2')
43/406: a
43/407: plt.imshow(a[0])
43/408: plt.show()
43/409: a = pywt.dwt(im,'db2','smooth')
43/410: a
43/411: a = pywt.dwt(im,'db4','smooth')
43/412: a
43/413: a = pywt.dwt2(im,'db4','smooth')
43/414: a
43/415: plt.imshow(a[0])
43/416: plt.show
43/417: plt.show()
43/418: a
43/419: A = pywt.dwt2(a,'db4','smooth')
43/420: A = pywt.dwt2([a[0],a[1],a[2],a[3]],'db4','smooth')
43/421: A = pywt.dwt2([a[0],a[1],a[2],a[3]],'db4','smooth')
43/422: len(a)
43/423: a
43/424: A = pywt.dwt2([a[0],a[1][0],a[1][1],a[1][2]],'db4','smooth')
43/425: plt.imshow(A)
43/426: A
43/427: A.dtype
43/428: a
43/429: a = pywt.dwt2(im,'db4')
43/430: a
43/431: A = pywt.idwt2(a,'db4','smooth')
43/432: A
43/433: plt.imshow(A)
43/434: plt.show()
43/435: reload(transforms)
43/436: reload(tf)
43/437: tf.TV(im3,im3.shape,strtag3)
43/438: im = np.load(filename)
43/439: IM = tf.xfm(im)
43/440: reload(tf)
43/441: IM = tf.xfm(im)
43/442: plt.imshow(IM)
43/443: IM.shape
43/444: IM
43/445: IM + 1
43/446: IM[0].shape
43/447: IM[0].shape*4
43/448: 4*IM[0].shape
43/449: 4*np.array(IM[0].shape)
43/450: len(IM[0])
43/451: plt.imshow(IM[0])
43/452: plt.show()
43/453: plt.imshow(IM[1])
43/454: len(IM[1])
43/455: len(IM[1][0])
43/456: 131*2
43/457: im
43/458: im.shape
43/459: len(IM[1][2])
43/460: len(IM[1][1])
43/461: IM = tf.ixfm(IM)
43/462: reload(tf)
43/463: len(IM[1][1])
43/464: reload(tf)
43/465: IM = tf.ixfm(IM)
43/466: IM
43/467: IM.shape
43/468: reload(tf)
43/469: IM = tf.xfm(im)
43/470: im2 = tf.ixfm(IM)
43/471: im2
43/472: im2.shape
43/473: plt.imshow(im2)
43/474: plt.show()
43/475: np.max(abs(im2-im))
43/476: IM
43/477: IM[0]
43/478: IM[0].shape
43/479: a
43/480: a = np.array([[1,2],[3,4]])
43/481: a
43/482: coeffs = pywt.dwt2(data, 'haar')
43/483: coeffs = pywt.dwt2(a, 'haar')
43/484: coeffs
43/485: a = np.arange(16).reshape(4,4)
43/486: a
43/487: coeffs = pywt.dwt2(a, 'db4')
43/488: coeffs
43/489: coeffs[0].shape
43/490: coeffs = pywt.dwt2(a, 'haar')
43/491: coeffs[0].shape
43/492: coeffs
43/493: plt.imshow(coeffs)
43/494: plt.imshow(coeffs[0])
43/495: plt.show()
43/496: plt.imshow(a)
43/497: plt.show()
43/498: coeffs = pywt.dwt2(a, 'db1')
43/499: coeffs
43/500: coeffs[0].shape
43/501: coeffs = pywt.dwt2(a, 'db4')
43/502: coeffs[0].shape
43/503: coeffs[0].shape
43/504: coeffs = pywt.dwt2(a, 'db32')
43/505: coeffs = pywt.dwt2(a, 'db16')
43/506: coeffs[0].shape
43/507: coeffs = pywt.dwt2(a, 'db5')
43/508: coeffs[0].shape
43/509: coeffs = pywt.dwt2(im, 'db5')
43/510: coeffs[0].shape
43/511: 256/2
43/512: 256/2+5
43/513: coeffs = pywt.dwt2(im, 'db1')
43/514: coeffs[0].shape
43/515: coeffs = pywt.dwt2(im, 'db0')
43/516: coeffs = pywt.dwt2(im, 'db1')
43/517: coeffs[0].shape
43/518: coeffs
43/519: len(coeffs)
43/520: len(coeffs[1])
43/521: coeffs[1]
43/522: coeffs = pywt.dwt2(im, 'db5')
43/523: len(coeffs[1])
43/524: plt.imshow(coeffs[0])
43/525: plt.show()
43/526: im
43/527: IM2 = pywt.wavedec2(im,'db4')
43/528: IM2
43/529: IM2.shape
43/530: len(IM2)
43/531: IM2[0].shape
43/532: 14*6
43/533: 14*6
43/534: IM2[1].shape
43/535: len(IM2[1])
43/536: plt.imshow(IM2[0])
43/537: plt.show()
43/538: IM2[0]
43/539: IM2[1].shape
43/540: IM2[1][0].shape
43/541: IM2[1][1].shape
43/542: IM2[1][2].shape
43/543: IM2[2][2].shape
43/544: IM2[2][2].shape[0]
43/545: IM2[0]
43/546: IM2[0][0]
43/547: IM2[0][0].shape
43/548: IM2[0][0].shape[0]
43/549: N = [1,2,3]
43/550: N
43/551: sum(N)
43/552: N*2
43/553: ax = []
43/554: xfmData =IM2
43/555:
for i in xrange(len(xfmData)):
    ax = ax.append(xfmData[i][0].shape[0])
43/556: ax = [None]
43/557: ax
43/558:
for i in xrange(len(xfmData)):
    ax = ax.append(xfmData[i][0].shape[0])
43/559: ax.type
43/560: ax = []
43/561: ax
43/562:
for i in xrange(len(xfmData)):
    ax = ax.append(xfmData[i][0].shape[0])
43/563: l = []
43/564: l.append(1)
43/565: l
43/566: ax
43/567: ax = []
43/568:
for i in xrange(len(xfmData)):
    ax.append(xfmData[i][0].shape[0])
43/569: ax
43/570: sum(ax)
43/571: 288-14
43/572: ax = []
43/573:
for i in xrange(len(xfmData)):
    ax.append(xfmData[i][0].shape[0])
43/574: ax
43/575: N = sum(ax)
43/576: ax = []
43/577:
for i in xrange(len(xfmData)):
    for j in xrange(len(xfmData[i])):
        ax.append(xfmData[i][0].shape[0])
43/578: ax
43/579: N = []
43/580: %paste
43/581: N
43/582: ax
43/583: ax = []
43/584:
for i in xrange(len(xfmData)):
        for j in xrange(len(xfmData[i])):
                ax.append(xfmData[i][0].shape[0])
43/585: ax
43/586: ax = []
43/587:
for i in xrange(len(xfmData)):
            ax.append(xfmData[i][0].shape[0])
43/588: ax
43/589: N = sum(ax)
43/590: N
43/591: res = np.zeros([N,N])
43/592: res[0:ax[0],0:ax[0]] = xfmData[0]
43/593: res
43/594: plt.imshow(res)
43/595: plt.show()
43/596: 288-256
43/597: len(ax)
43/598: 32/6
43/599: ax
43/600: sum(np.array(ax)-5)*6
43/601: sum(np.array(ax)-5)
43/602: sum(np.array(ax))
43/603: sum(np.array(ax)-5)
43/604: np.array(ax)-5
43/605: 32/6.
43/606: i=1
43/607: sum(ax[0:i])
43/608:
sum(ax[:i+2]
)
43/609: ax
43/610: sum(ax[:i+1])
43/611: sum(ax[:i])
43/612: z14+14
43/613: 14+14
43/614: IM2
43/615: IM2[0]
43/616: plt.imshow(IM2[0])
43/617: plt.show
43/618: plt.show()
43/619: IM2[0][3:,3:].shape
43/620: plt.imshow(IM2[0][3:,3:])
43/621: plt.show()
43/622: ax
43/623: plt.imshow(IM2[0][6:,6:])
43/624: plt.show()
43/625: plt.imshow(IM2[0][5:-1,5:-1])
43/626: plt.show()
43/627: IM2 = pywt.wavedec2(im,'db1')
43/628: IM2
43/629: xfmData
43/630: len(xfmData)
43/631: len(IM2)
43/632: xfmData = IM2
43/633: len(xfmData)
43/634: ax = []
43/635:
for i in xrange(len(xfmData)):
        ax.append(xfmData[i][0].shape[0])
43/636: ax
43/637: xfmData = pywt.wavedec2(im,'db2')
43/638: ax = []
43/639:
for i in xrange(len(xfmData)):
        ax.append(xfmData[i][0].shape[0])
43/640: ax
43/641: sum(ax)
43/642: im.shape
43/643: xfmData = pywt.wavedec2(im,'db2',mode='zpad')
43/644: xfmData = pywt.wavedec2(im,'db2','zpad')
43/645: xfmData = pywt.wavedec2(im,'db2','zpd')
43/646: ax = []
43/647:
for i in xrange(len(xfmData)):
        ax.append(xfmData[i][0].shape[0])
43/648: ax
43/649: IM = tf.xfm(im,'db4')
43/650: IM
43/651: IM[0].shape
43/652: IM[1][1].shape
43/653: plt.show(IM[0])
43/654: plt.imshow(IM[0])
43/655: plt.show()
43/656: IM[0]
43/657: a =
43/658: a
43/659: a = 1
43/660: plt.imshow(IM[0][a:-a,a:-a])
43/661: plt.show()
43/662: a = 20
43/663: plt.imshow(IM[0][a:-a,a:-a])
43/664: plt.show()
43/665: plt.imshow(im[a:-a,a:-a])
43/666: plt.show()
43/667: plt.imshow(im[a:-a,:])
43/668: a = 30
43/669: plt.imshow(im[a:-a,:])
43/670: plt.show()
43/671: plt.imshow(im[:,a:-a])
43/672: plt.show()
43/673: a = 40
43/674: np.all(im.T == im)
43/675: plt.imshow(im[:,a:-a])
43/676: plt.show()
43/677: plt.imshow(im[:,a:-a])
43/678: plt.show()
43/679: IM2 = pywt.wavedec2(im,'db1','per')
43/680: IM2
43/681: IM2[0].shape
43/682: IM2[0]
43/683: len(IM2)
43/684: %paste
43/685: ax
43/686: xfmData = IM2
43/687: ax = []
43/688:
for i in xrange(len(xfmData)):
        ax.append(xfmData[i][0].shape[0])
43/689: ax
43/690: IM2 = pywt.wavedec2(im,'db4','per')
43/691: xfmData = IM2
43/692: ax = []
43/693:
for i in xrange(len(xfmData)):
        ax.append(xfmData[i][0].shape[0])
43/694: ax
43/695: xfmData = pywt.wavedec2(im,'db16','per')
43/696:
for i in xrange(len(xfmData)):
        ax.append(xfmData[i][0].shape[0])
43/697: ax
43/698: xfmData = pywt.wavedec2(im,'db6','per')
43/699: ax = []
43/700:
for i in xrange(len(xfmData)):
        ax.append(xfmData[i][0].shape[0])
43/701: ax = []
43/702:
for i in xrange(len(xfmData)):
        ax.append(xfmData[i][0].shape[0])
43/703: ax
43/704: sum(ax)
43/705: xfmData
43/706: xfmData[0]
43/707: plt.imshow(xfmData)
43/708: plt.imshow(xfmData[0])
43/709: plt.show()
43/710: xfmData = pywt.wavedec2(im,'db4','per')
43/711: plt.imshow(xfmData[0])
43/712: plt.show()
43/713: xfmData = pywt.wavedec2(im,'db4','ppd')
43/714: plt.imshow(xfmData[0])
43/715: plt.show()
43/716: xfmData = pywt.wavedec2(im,'db4')
43/717: plt.show()
43/718: plt.imshow(xfmData[0])
43/719: plt.show()
43/720: xfmData = pywt.wavedec2(im,'db4')
43/721: im
43/722: im.shape
43/723: xfmData = pywt.wavedec2(im,'db1')
43/724: plt.imshow(xfmData[0])
43/725: plt.show()
43/726: xfmData[0]
43/727: plt.imshow(xfmData[0])
43/728: xfmData = pywt.wavedec2(im,'db1','sym')
43/729: plt.imshow(xfmData[0])
43/730: plt.show()
43/731: ax = []
43/732:
for i in xrange(len(xfmData)):
        ax.append(xfmData[i][0].shape[0])
43/733: ax
43/734: N = sum(ax)
43/735: res = np.zeros([N,N])
43/736: ax
43/737: sum(ax[0:1])
43/738: sum(ax[0:2])
43/739: ax[0]:ax[1]
43/740: np.arange(10)[ax[0]:ax[1]]
43/741: ax[0]
43/742: np.arange(10)[sum(ax[0:1]):sum(ax[0:2])]
43/743: t = np.arange(10)
43/744: t
43/745: t[sum(ax[0:1]):sum(ax[0:2])]
43/746: res = np.zeros([N,N])
43/747: i = 1
43/748: res[0:sum(ax[0:i]),sum(ax[0:i]):sum(ax[0:i+1])]
43/749: res[0:sum(ax[0:i]),sum(ax[0:i]):sum(ax[0:i+1])].shape
43/750: i = 2
43/751: res[0:sum(ax[0:i]),sum(ax[0:i]):sum(ax[0:i+1])].shape
43/752: i =
43/753: i =3
43/754: res[0:sum(ax[0:i]),sum(ax[0:i]):sum(ax[0:i+1])].shape
43/755: N = sum(ax)
43/756: N
43/757: res = np.zeros([N,N])
43/758: xfmData = pywt.wavedec2(im,'db1','sym')
43/759: plt.imshow(xfmData[0])
43/760: plt.show()
43/761: im
43/762: np.mean(im)
43/763: np.sum(im)
43/764: np.sum(xfmData)
43/765: res[0:ax[0],0:ax[0]] = x[0]
43/766: x
43/767: x = xfmData
43/768: x
43/769: res[0:ax[0],0:ax[0]] = x[0]
43/770: res
43/771: %paste
43/772: plt.imshow(res)
43/773: plt.show()
43/774: %paste
43/775: %paste
43/776: a = toMatrix(x)
43/777: a
43/778: plt.imshow(a)
43/779: plt.show()
43/780: x
43/781: len(x)
43/782: %paste
43/783: X = fromMatrix(a,ax)
43/784: ax
43/785: []*9
43/786: [None]*9
43/787: %paste
43/788: X = fromMatrix(a,ax)
43/789: x
43/790: a
43/791: p
43/792: p = []
43/793: p.append(1)
43/794: p
43/795: p.append([])
43/796: p[1].append([1])
43/797: p
43/798: p[1].append([123])
43/799: p
43/800: %paste
43/801: X = fromMatrix(a,ax)
43/802: X
43/803: np.all(X == x)
43/804: x
43/805: x
43/806: np.max(X - x)
43/807: X
43/808: X[0]
43/809: x = xfmData
43/810:
for i in xrange(1,len(ax)):
    np.all(X[i][0] == x[i][0])
43/811:
for i in xrange(1,len(ax)):
    print(np.all(X[i][0] == x[i][0]))
43/812:
for i in xrange(1,len(ax)):
    print(np.all(X[i][1] == x[i][1]))
43/813:
for i in xrange(1,len(ax)):
    print(np.all(X[i][2] == x[i][2]))
43/814:
for i in xrange(1,len(ax)):
    print(np.all(X[i][2] == x[i][2]))
43/815: t1 = pywt.wavedec2(im,'db1','sym')
43/816: t1
43/817: ax = []
43/818:
    for i in xrange(len(x)):
            ax.append(xfmData[i][0].shape[0])
43/819:
for i in xrange(len(x)):
            ax.append(xfmData[i][0].shape[0])
43/820: ax
43/821: xfmData = pywt.wavedec2(im,'db1','sym')
43/822: len(xfmData)
43/823: xfmData = pywt.dwt2(im,'db1','sym')
43/824: len(xfmData)
48/1: import os
48/2: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/')
48/3: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
48/4: im = np.load(filename)
48/5: import numpy as np
48/6: import pywt
48/7: im
48/8: im = np.load(filename)
48/9: im
48/10: db1 = pywt.dwt2(im,'db1','sym')
48/11: db1
48/12:
def sz(z):
    ax = []
        for i in xrange(len(x)):
                ax.append(xfmData[i][0].shape[0])
48/13:
def sz(z):
    ax = []
    for i in xrange(len(x)):
        ax.append(xfmData[i][0].shape[0])
48/14:
def sz(z):
    ax = []
    for i in xrange(len(x)):
        ax.append(xfmData[i][0].shape[0])
    return ax
48/15: sz(db1)
48/16:
def sz(x):
    ax = []
    for i in xrange(len(x)):
        ax.append(xfmData[i][0].shape[0])
    return ax
48/17: sz(db1)
48/18:
def sz(x):
    ax = []
    for i in xrange(len(x)):
        ax.append(x[i][0].shape[0])
    return ax
48/19:
def toMatrix(x):
        ''' Go from [cAn, (cHn, cVn, cDn), ..., (cH1, cV1, cD1)] to a 2D image'''
48/20:     ax = []
48/21:
    for i in xrange(len(x)):
            ax.append(x[i][0].shape[0])
48/22:     N = sum(ax)
48/23:     res = np.zeros([N,N])
48/24:     res[0:ax[0],0:ax[0]] = x[0]
48/25:
    for i in xrange(1,len(ax)):
            # Now we need to push the correct cH, cV and cD to the right spots
            #
            res[0:sum(ax[0:i]),sum(ax[0:i]):sum(ax[0:i+1])] = x[i][0] # cH
            res[sum(ax[0:i]):sum(ax[0:i+1]),0:sum(ax[0:i])] = x[i][1] # cV
            res[sum(ax[0:i]):sum(ax[0:i+1]),sum(ax[0:i]):sum(ax[0:i+1])] = x[i][2] # cD
48/26: %paste
48/27: db1Image,db1Ax = toMatrix(db1)
48/28: plt.imshow(db1Image)
48/29: import matplotlib.pyplot as plt
48/30: plt.imshow(db1Image)
48/31: plt.show()
48/32: db1Ax
48/33: db1Image,db1Ax = toMatrix(db1)
48/34: db2 = pywt.dwt2(im,'db2','sym')
48/35: db2Image,db2Ax = toMatrix(db2)
48/36: db2Ax
48/37: import transforms as tf
48/38: db2 = tf.xfm(im,'db2')
48/39: db2Image,db2Ax = toMatrix(db2)
48/40: reload(tf)
48/41: db2 = tf.xfm(im,'db2')
48/42: db2Image,db2Ax = tf.toMatrix(db2)
48/43: db2
48/44: im.shape
48/45: pywt._multilevel._check_level(256,pywt.Wavelet('db2'),None)
48/46: coeffs_list = []
48/47: wavelet = pywt.Wavelet('db2')
48/48: wavelet
48/49: wavelet.shape
48/50: wavelet['filter_bank'].shape
48/51: a = im
48/52: pywt.dwt2(a,wavelet)
48/53: t = pywt.dwt2(a,wavelet)
48/54: t.shape
48/55: t[0].shape
48/56: t = pywt.dwtn(a,wavelet)
48/57: t
48/58: t[0].shape
48/59: t[0]
48/60: t
48/61: t['aa'].shape
48/62: axes = range(data.ndim)
48/63: data = a
48/64: axes = range(data.ndim)
48/65: axes
48/66: axes = (a + data.ndim if a < 0 else a for a in axes)
48/67: axes
48/68: mode = pywt.Modes.from_object('sym')
48/69: mode
48/70: coeffs = [('', data)]
48/71: coeffs
48/72: wavelet
48/73: wavelet.filter_bank
48/74: wavelet.filter_bank.shape
48/75: len(wavelet.filter_bank)
48/76: wavelet.filter_bank[0]
48/77: wavelet.filter_bank[0].shape
48/78: test = np.array(wavelet.filter_bank)
48/79: test
48/80: np.dot(test[0,:],test[1,:].T)
48/81: np.dot(test[0,:],test[2,:].T)
48/82: np.dot(test[:,0].T,test[2,:])
48/83: test
48/84: t = pywt.dwtn(a,wavelet)
48/85: t
48/86: t['aa'].shape
48/87: plt.imshow(t['aa'])
48/88: plt.show()
48/89: db2 = tf.xfm(im,'db5')
48/90: db2 = tf.xfm(im,'db2')
48/91: db5 = tf.xfm(im,'db5')
48/92: len(db5)
48/93: len(db5[0])
48/94: db5[0].shape
48/95: db5[4][0].shape
48/96: plt.imshow(db5[4][0])
48/97: plt.show()
48/98: plt.imshow(db5[4][0][:128,:128])
48/99: plt.show()
48/100: plt.imshow(db5[4][0][:128,:])
48/101: plt.show()
48/102: plt.imshow(im[:128,:])
48/103: plt.show()
48/104: plt.imshow(im[:,:])
48/105: plt.show()
48/106: plt.imshow(db5[4][0][:128,:128])
48/107: plt.show()
48/108: plt.imshow(db5[4][0][132-128:,132-128:])
48/109: plt.show()
48/110: plt.imshow(db5[4][0][132-128:,:])
48/111: plt.show()
48/112: plt.imshow(db5[4][0][:,132-128:])
48/113: plt.show()
48/114: plt.imshow(db5[4][0][132-128:,:128])
48/115: plt.show()
48/116: plt.imshow(db5[4][0][:,132-128:])
48/117: plt.imshow(db5[4][0][:128,132-128:])
48/118: plt.show()
48/119: plt.imshow(db5[4][1][:128,132-128:])
48/120: plt.show()
48/121: plt.imshow(db5[4][1][132-128:,:128])
48/122: plt.show()
48/123: a
48/124: plt.imshow(a)
48/125: plt.show()
48/126: db2
48/127: db2[0].shape
48/128: plt.imshow(db2[0])
48/129: plt.show()
48/130: a = []
48/131: a.append(db2[0][2:,2:])
48/132: plt.imshow(a[0])
48/133: plt.show()
48/134: db2[0]
48/135: a[0]
48/136: a.append([])
48/137: a[1]
48/138: db[1].shape
48/139: db2[1].shape
48/140: db2[1][0].shape
48/141: plt.imshow(db2[1][0])
48/142: plt.show()
48/143: db1 = pywt.dwt2(im,'db1','per')
48/144: db1Image,db1Ax = toMatrix(db1)
48/145: plt.imshow(db1Image)
48/146: plt.show()
48/147: db1Image,db1Ax = toMatrix(db1)
48/148: plt.imshow(db1Image)
48/149: db1Image,db1Ax = toMatrix(db1)
48/150: db1 = pywt.wavedec2(im,'db1','per')
48/151: db1Image,db1Ax = toMatrix(db1)
48/152: plt.imshow(db1Image)
48/153: plt.show()
48/154: db1Image,db1Ax = toMatrix(db1)
48/155: db5 = pywt.wavedec2(im,'db5','per')
48/156: db5Image,db5Ax = toMatrix(db5)
48/157: plt.imshow(db5Image)
48/158: plt.show()
48/159: db5Ax
48/160: db12 = pywt.wavedec2(im,'db12','per')
48/161: db12Image,db12Ax = toMatrix(db12)
48/162: plt.imshow(db12Image)
48/163: db12Ax
48/164: plt.show()
48/165: plt.imshow(db12Image)
48/166: db6 = pywt.wavedec2(im,'db6','per')
48/167: 2^6
48/168: 2**6
48/169: 2**12
48/170: db6Image,db6Ax = toMatrix(db6)
48/171: plt.imshow(db6Image)
48/172: plt.show()
48/173: pywt.MODES.modes
48/174: Wavelet('sym3')
48/175: pywtWavelet('sym3')
48/176: pywt.Wavelet('sym3')
48/177: pywt.Wavelet('sym')
48/178: db6 = pywt.wavedec2(im,'db6','sym')
48/179: db6[0].shape
48/180: db6 = pywt.wavedec2(im,'db6','per')
48/181: db6[0].shape
48/182: db6 = pywt.wavedec2(im,'db6','per')
48/183: im6 = pywt.waverec2(db6,'db6','per')
48/184: np.all(im6 == im)
48/185: np.max(im6 - im)
48/186: np.max(abs(im6 - im))
48/187: pywt.Wavelet('haar').filter_bank
48/188: pywt.Wavelet('db1').filter_bank
48/189: db4 = pywt.wavedec2(im,'db4','per')
48/190: db4Image,db4Ax = toMatrix(db4)
48/191: plt.imshow(db4Image)
48/192: plt.show()
48/193: im.shape
48/194: np.log2(im.shape)
48/195: 2**8
48/196: pywt.Modes
48/197: pywt.Modes('sym')
48/198: pywt.MODES
48/199: pywt.MODES('sym')
48/200: pywt.MODES.periodic
48/201: pywt.MODES.periodizaton
48/202: pywt.MODES.periodization
48/203: pywt.MODES.symmetric
48/204: pywt.MODES.symmetric
48/205: pywt.MODES.symmetric
48/206: db4 = pywt.wavedec2(im,'db4','sym')
48/207: db4Image,db4Ax = toMatrix(db4)
48/208: db4 = pywt.wavedec2(im,'sym3','per')
48/209: db4Image,db4Ax = toMatrix(db4)
48/210: plt.imshow(db4Image)
48/211: plt.show()
48/212: plt.show(db4[0])
48/213: plt.imshow(db4[0])
48/214: plt.show()
48/215: db4 = pywt.wavedec2(im,'db4','per',correct_size=True)
48/216: db4 = pywt.wavedec2(im,'db4','per',level=2)
48/217: len(db4)
48/218: len(db4[0])
48/219: db4 = pywt.wavedec2(im,'db4','per',level=3)
48/220: len(db4[0])
48/221: db4 = pywt.wavedec2(im,'db4','per',level=4)
48/222: len(db4[0])
48/223: db4 = pywt.wavedec2(im,'db4','per',level=5)
48/224: len(db4[0])
48/225: db4Image,db4Ax = toMatrix(db4)
48/226: plt.imshow(db4[0])
48/227: plt.show()
48/228: db4 = pywt.wavedec2(im,'db4','sym',level=5)
48/229: db4Image,db4Ax = toMatrix(db4)
48/230: db4 = pywt.wavedec2(im,'db4','zpd',level=5)
48/231: db4Image,db4Ax = toMatrix(db4)
48/232: db4 = pywt.wavedec2(im,'db4','sp1',level=5)
48/233: db4Image,db4Ax = toMatrix(db4)
48/234: db4 = pywt.wavedec2(im,'db4','zpd',level=5)
48/235: plt.imshow(db4[0])
48/236: plt.show()
48/237: db4 = pywt.wavedec2(im,'db4','sym',level=5)
48/238: plt.imshow(db4[0])
48/239: plt.show()
48/240: db2 = pywt.wavedec2(im,'db2','sym',level=5)
48/241: plt.imshow(db2[0])
48/242: plt.show()
48/243: db2 = pywt.wavedec2(im,'db2','per',level=5)
48/244: plt.imshow(db2[0])
48/245: plt.show()
48/246: db4 = pywt.wavedec2(im,'db4','sym',level=5)
48/247: db2Image,db2Ax = toMatrix(db2)
48/248: plt.imshow(db2Image)
48/249: plt.show()
48/250: db4 = pywt.wavedec2(im,'db4','sym',level=3)
48/251: db2Image,db2Ax = toMatrix(db2)
48/252: plt.imshow(db2Image)
48/253: plt.show()
48/254: db2 = pywt.wavedec2(im,'db2','sym',level=3)
48/255: db2Image,db2Ax = toMatrix(db2)
48/256: db2 = pywt.wavedec2(im,'db2','per',level=3)
48/257: db2Image,db2Ax = toMatrix(db2)
48/258: plt.imshow(db2Image)
48/259: plt.show()
48/260: db2Image,db2Ax = toMatrix(db2)
48/261: db3 = pywt.wavedec2(im,'db3','per',level=4)
48/262: db3Image,db3Ax = toMatrix(db3)
48/263: plt.imshow(db3Image)
48/264: plt.show()
49/1: import numpy as np
49/2: np.atleast_1d
49/3: np.atleast_1d([1])
49/4: np.atleast_1d([1,1,1,1,1])
49/5: np.atleast_1d(np.array([1,1,1,1,1]))
49/6: np.atleast_1d(np.ones([5,5]))
49/7: np.atleast_1d([])
49/8: np.atleast_1d?
49/9: np.atleast_1d(1)
49/10: task
49/11: task = b'START'
49/12: tast
49/13: task
49/14: task[:4]
50/1: %paste
50/2: %paste
50/3: plt.imshow(im)
50/4: plt.show()
50/5: %paste
50/6: plt.imshow(im)
50/7: plt.show()
50/8: plt.imshow(im_dc,interpolation='none')
50/9: plt.imshow(abs(im_dc),interpolation='none')
50/10: plt.imshow(abs(im_dc.reshape(N)),interpolation='none')
50/11: plt.show()
50/12: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
50/13: im_result = spopt.minimize(optfun, im_dc, args = args,method=method,jac=derivative_fun,options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
50/14: im_res = im_result['x'].reshape(N);
50/15: plt.imshow(abs(im_res.reshape(N)),interpolation='none')
50/16: plt.show()
50/17: method
50/18: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
50/19: reload opt
50/20: reload(opt)
50/21: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
51/1: %paste
51/2: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
51/3: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
51/4: args
51/5: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
51/6: reload(opt)
51/7: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
52/1: %paste
53/1: %paste
54/1: %paste
54/2: args
54/3: len(args)
54/4: reload(opt)
54/5: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
55/1: %paste
55/2: %paste
56/1: %paste
57/1: %paste
58/1: %paste
59/1: %paste
59/2: f = optfun
59/3: f
59/4: fprime = derivative_fun
59/5: grad_calls, myfprime = wrap_function(fprime, args)
59/6: %paste
59/7: grad_calls, myfprime = wrap_function(fprime, args)
59/8: func_calls, f = wrap_function(f, args)
59/9: f
59/10: %paste
59/11: phi
59/12: phi(3)
59/13: xk = im_dc
59/14: xk
59/15: gval = [gfk]
59/16: gfk = fprime(xk)
59/17: gfk = fprime(xk,args)
59/18: args
59/19: len(args)
59/20: gfk = fprime(xk,args)
59/21: phi(0)
59/22: fc = [0]
59/23: phi(0)
59/24: grad_calls, myfprime = wrap_function(fprime, args)
59/25: myfprime
59/26: gfk = myfprime(xk)
59/27: gfk = myfprime(x0)
59/28: pk = -gfk
59/29: k = 0
59/30: phi(0)
59/31: newargs = args
59/32: phi(0)
59/33: wrapper_args
59/34: args
59/35: pk
59/36: gfk
59/37: np.dot(pk,gfk)
59/38: np.dot(gfk,pk)
59/39: N
59/40: lam1
59/41: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
59/42: f
59/43: f(xk,args)
59/44: args
59/45: len(args)
59/46: f(xk,args)
59/47: f(xk,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
59/48: f(N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
59/49: f(args)
59/50: phi(args)
59/51: phi(0)
59/52: f
59/53: phi(0)
59/54: len(newargs)
59/55: f(xk,newargs)
59/56: len(newargs)
59/57: f(xk,*newargs)
59/58: *newargs
59/59: **newargs
59/60: f(xk,**newargs)
59/61: f(xk,*newargs)
59/62: f(xk,*args)
59/63: f(xk,args)
59/64:
    def phi(s):
            fc[0] += 1
            return f(xk + s*pk, *args)
59/65: phi
59/66: phi(1)
59/67:
def printall(*args):
    for count, thing in enumerate(args):
        print '{0}. {1}'.format(count, thing)
59/68: printall(*args)
59/69: isinstance(fprime, tuple)
59/70: newargs = args
59/71: gradient = True
60/1: %paste
60/2: f = optfun
60/3: fprime = derivative_fun
60/4: %paste
60/5: wrap_function(f,args)
60/6: func_calls, f = wrap_function(f, args)
60/7: f
60/8: func_calls, f = wrap_function(f, args)
60/9: grad_calls, myfprime = wrap_function(fprime, args) # Wraps the derivative function
60/10: gfk = myfprime(x0)
60/11: k = 0
60/12: %paste
60/13: %paste
60/14: pk = -gfk # Here is where the -1 is applied -- thus I shouldn't apply it in mine
60/15: %paste
60/16: phi(1)
60/17: phi()
60/18:
def phi(s):
        fc[0] += 1
        return f(xk + s*pk, args)
60/19: phi(1)
60/20: args
60/21: f(xk,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
60/22: optfun(xk,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
60/23: def alpha_check(xk,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
60/24:
def alpha_check(xk,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a):
    
    
    a
    dassafaw;
    q
60/25:
def alpha_check(s):
    return optfun(xk+s*pk,N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
60/26: alpha_check(0)
60/27: alpha_check(1)
60/28: alpha_check(10)
60/29: np.logspace(2,3)
60/30: np.logspace(-3,1)
60/31: s = np.logspace(-3,1)
60/32:
for i in xrange(len(s)):
    y[i] = alpha_check(s[i])
60/33: y = np.zeros(len(s))
60/34: y
60/35:
for i in xrange(len(s)):
    y[i] = alpha_check(s[i])
60/36: y
60/37: plt.plot(s,y)
60/38: plt.show()
60/39: s = np.logspace(-8,1,1000)
60/40:
for i in xrange(len(s)):
    y[i] = alpha_check(s[i])
60/41: y = np.zeros(len(s))
60/42:
for i in xrange(len(s)):
    y[i] = alpha_check(s[i])
60/43: plt.plot(s,y,'.')
60/44: plt.show()
60/45: plt.plot(s,y,'.')
60/46: plt.show()
60/47: plt.plot(s,y,'.')
60/48: plt.title('Alpha for First Guess')
60/49: plt.xlabel('\alpha')
60/50: plt.ylabel('\phi(\alpha)')
60/51: plt.show()
60/52: plt.title('Objective Function Values per $\alpha$ for First Guess')
60/53: plt.plot(s,y,'.')
60/54: plt.xlabel('$\alpha$')
60/55: plt.ylabel('$\phi(\alpha)$')
60/56: plt.show()
61/1:
for i in xrange(len(s)):
    y[i] = alpha_check(s[i])
61/2: %paste
61/3: $paste
61/4: %paste
61/5: plt.show()
61/6: %paste
61/7: x0
61/8: x0 + 0.75*pk
61/9: x1 = x0 + 0.75*pk
61/10: plt.imshow(x1.reshape(8,8))
61/11: plt.show()
61/12: x1 = x0 - 0.75*pk
61/13: plt.imshow(x1.reshape(8,8))
61/14: plt.imshow(x1.reshape(8,8),interpolation=None)
61/15: plt.show()
61/16: plt.imshow(x1.reshape(8,8),interpolation='None')
61/17: plt.show()
61/18: s
61/19: y
62/1: %paste
62/2: %paste
62/3: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
62/4: im_res = im_result['x'].reshape(N);
63/1: %paste
63/2: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
63/3: reload(opt)
63/4: reload(opt.linesearch)
63/5: reload(opt.optimize)
63/6: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
63/7: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
63/8: reload(opt.linesearch)
63/9: reload(opt.optimize)
63/10: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
63/11: reload(opt.optimize)
63/12: reload(opt.linesearch)
63/13: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
63/14: reload(opt.optimize)
63/15: reload(opt.linesearch)
63/16: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
63/17: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
63/18: inspect.getsourcelines(optimize.optimize)
64/1: %paste
64/2: %paste
64/3: c
64/4: %paste
64/5: reload(opt.linesearch)
64/6: reload(opt.optimize)
64/7: %paste
64/8: import pdb;
64/9: pm
64/10: pdb.pm
64/11: pdb.pm()
65/1: %paste
65/2: phi(1)
65/3: args
65/4: len(args)
65/5:
def phi(s):
        fc[0] += 1
        return f(xk + s*pk, args)
65/6: phi(1)
65/7: len(xk+pk)
65/8: len(xk+pk,args)
65/9: len((xk+pk,args))
65/10: len((xk+pk,*args))
65/11: len((xk+pk,args[]))
65/12: len((xk+pk,args[:]))
65/13: args[:]
65/14: len(xk+pk,args[:])
65/15: xk+pk,args[:]
65/16: it = lambda: list(chain(*args))
65/17: it
65/18: phi(1)
65/19: len(arg)
65/20: len(args)
65/21: arg(14)
65/22: args[14]
65/23: args[13]
65/24: %paste
65/25: %paste
65/26: phi(1)
65/27: %paste
65/28: phi(1)
65/29: phi(1)
65/30:
def phi(s):
        fc[0] += 1
        import pdb; pdb.set_trace()
        return f1(xk + s*pk, *newargs)
65/31: phi(1)
65/32: %paste
65/33: %paste
65/34: %paste
65/35:
def wrap_function(function, args):
        ncalls = [0]
        if function is None:
                return ncalls, None
65/36:
    def function_wrapper(*wrapper_args):
            ncalls[0] += 1
            return function(*(wrapper_args + args))
65/37:     return ncalls, function_wrapper
65/38: %paste
65/39: testcall,test = wrap_function(optfun,args)
65/40: test
65/41: test(1)
65/42: test(args)
65/43: test(x0,args)
65/44: %paste
65/45: testcall,test = wrap_function(optfun,args)
65/46: function_wrapper
65/47: function_wrapper(args)
65/48: func_calls, f1 = wrap_function(f, args)
65/49: f1(xk,args)
65/50: f1(xk,*args)
65/51: %paste
65/52: func_calls, f1 = wrap_function(f, args)
65/53: f1(xk,*args)
65/54: !a = args
65/55: tester = args
65/56: f1(xk,*tester)
65/57: f1(xk,tester)
65/58: rm args
65/59: args = None
65/60: f1(xk,tester)
65/61: args
65/62: f1(xk,tester)
66/1: %paste
66/2: args
66/3: %paste
66/4: f1(x0,testargs)
66/5: f1(x0,*testargs)
66/6: f(x0,args)
66/7: f(x0,testargs)
66/8: %paste
66/9: func_calls, f1 = wrap_function(f, args)
66/10: func_calls, f1 = wrap_function(f, testargs)
66/11: f1(1)
66/12: f1(1)
66/13: old_fval = f1(xk)
66/14: k = 0
66/15: xk = x0
66/16: old_fval = f1(xk)
66/17: %paste
66/18: phi(1)
66/19: gval = [gfk]
66/20: gc = [0]
66/21: %paste
66/22: phi(1)
66/23: f1(1)
66/24: old_fval = f1(xk)
66/25: phi(1)
66/26: %paste
66/27: phi(0)
66/28: derphi(1)
66/29: %paste
66/30: derphi(1)
66/31: newargs
66/32:
def phi2(s):
            fc[0] += 1
            return f(xk + s*pk)
66/33:
def phi2(s):
            fc[0] += 1
            return f(xk + s*pk,*newargs)
66/34: phi2(1)
66/35: newargs
66/36: phi2(30)
66/37: phi2(100)
66/38: phi2(40)
66/39: phi2(50)
66/40: phi2(90)
66/41: args
66/42: newargs
66/43:
def phi(s):
            fc[0] += 1
            return f(xk + s*pk,*newargs)
66/44:
def phi(s):
        fc[0] += 1
        return f1(xk + s*pk,*newargs)
66/45: phi(90)
66/46:
def phi(s):
        fc[0] += 1
        return f1(xk + s*pk,*newargs)
66/47: phi(1)
66/48:
def phi(s):
        fc[0] += 1
        return f1(xk + s*pk)
66/49: phi(1)
66/50: phi
66/51: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
66/52: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
66/53: reload(opt.optimize)
66/54: reload(opt.linesearch)
66/55: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
66/56: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
66/57: derphi
67/1: %paste
67/2: im
67/3: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
67/4: import pdb
67/5: pdb.pm()
67/6: pdb.pm()
67/7: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
68/1: %paste
68/2: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
69/1: %paste
69/2:
reload(optimize/optimize.py(
))
69/3: reload(optimize/optimize.py)
69/4: reload(opt.optimize)
69/5: reload(opt.linesearch)
69/6: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
69/7: reload(opt.linesearch)
69/8: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
69/9: reload(opt.linesearch)
69/10: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
70/1: %paste
70/2: %paste
70/3: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
70/4: import pdb; pdb.pm()
70/5: import pdb; pdb.pm()
70/6: import pdb; pdb.pm()
70/7: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
70/8: reload(opt)
70/9: reload(opt.linesearch)
70/10: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
70/11: pdb.pm()
71/1: %paste
71/2: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
71/3: x
71/4: im_result['x'].reshape(8,8)
71/5: plt.imshow(im_result['x'].reshape(8,8))
71/6: plt.show()
71/7: reload(opt.linesearch)
71/8: reload(opt)
71/9: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
71/10: pdb.pm()
71/11: import pdb
71/12: pdb.pm()
72/1: %paste
72/2: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
73/1: %paste
73/2: %paste
73/3: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
73/4: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
74/1: %paste
74/2: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
75/1: %paste
75/2: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
75/3: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
75/4: reload(opt.optimize)
75/5: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
76/1: %paste
76/2: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
76/3: reload(opt.optimize)
76/4: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
77/1: %paste
77/2: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
78/1: %paste
78/2: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
78/3: vals = np.array([])
78/4: append(vals,1)
78/5: np
78/6: np.append(vals,1)
78/7: vals
78/8: vals = np.append(vals,1)
78/9: vals
78/10: vals = np.append(vals,1)
78/11: vals
79/1: %paste
79/2: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
79/3: c
79/4: import pdb
79/5: pdb.pm()
79/6: pdb.pm()
79/7: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
79/8: pdb.pm()
80/1: %paste
80/2: im_dc
80/3: im_dc = 0*im_dc
80/4: im_dc
80/5: im_dc = abs(0*im_dc)
80/6: im_dc
80/7: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
80/8: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
81/1: %paste
81/2: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
82/1: %paste
82/2: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
83/1: %paste
83/2: %paste
84/1: %paste
85/1: %paste
85/2: import pdb
85/3: pdb.pm
85/4: pdb.pm()
85/5: pdb.pm()
85/6: %paste
86/1: %paste
86/2: pdb
86/3: pdb.pm()
86/4: ipdb.pm()
86/5: pdb
86/6: pdb
86/7: #Imports
86/8: from __future__ import division
86/9: import numpy as np
86/10: import scipy as sp
86/11: import matplotlib.pyplot as plt
86/12: import os.path
86/13: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/') # Change this to the directory that you're saving the work in
86/14: import transforms as tf
86/15: import scipy.ndimage.filters
86/16: import grads
86/17: import sampling as samp
86/18: import direction as d
86/19: #from scipy import optimize as opt
86/20: import optimize as opt
86/21: import scipy.optimize as spopt
86/22: plt.rcParams['image.cmap'] = 'gray'
86/23: from recon_CS import *
86/24: # Initialization variables
86/25: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
86/26: strtag = ['spatial','spatial']
86/27: TVWeight = 0.01
86/28: XFMWeight = 0.01
86/29: dirWeight = 0
86/30: #DirType = 2
86/31: ItnLim = 150
86/32: epsilon = 1e-6
86/33: l1smooth = 1e-15
86/34: xfmNorm = 1
86/35: wavelet = 'db1'
86/36: mode = 'per'
86/37: method = 'CG'
86/38: dirFile = None
86/39: nmins = None
86/40: dirs = None
86/41: M = None
86/42: np.random.seed(2000)
86/43: im = np.zeros([8,8]);
86/44: im[3:5,3:5] = 1;
86/45: #im=np.load(filename)
86/46: N = np.array(im.shape) #image Size
86/47: tupleN = tuple(N)
86/48: pctg = 0.25 # undersampling factor
86/49: P = 5 # Variable density polymonial degree
86/50: #ph = tf.matlab_style_gauss2D(im,shape=(5,5));
86/51: ph=np.ones(im.shape,complex)
86/52: # Generate the PDF for the sampling case -- note that this type is only used in non-directionally biased cases.
86/53: pdf = samp.genPDF(N,P,pctg,radius = 0.3,cyl=[0]) # Currently not working properly for the cylindrical case -- can fix at home
86/54: # Set the sampling pattern -- checked and this gives the right percentage
86/55: k = samp.genSampling(pdf,50,2)[0].astype(int)
86/56: # Here is where we build the undersampled data
86/57: data = np.fft.ifftshift(k)*tf.fft2c(im,ph=ph)
86/58: #ph = phase_Calculation(im,is_kspace = False)
86/59: #data = np.fft.ifftshift(np.fft.fftshift(data)*ph.conj());
86/60: # IMAGE from the "scanner data"
86/61: im_scan = tf.ifft2c(data,ph=ph)
86/62: # Primary first guess. What we're using for now. Density corrected
86/63: im_dc = tf.ifft2c(data/np.fft.ifftshift(pdf),ph=ph).real.flatten().copy()
86/64: # Optimization algortihm -- this is where everything culminates together
86/65: a=10.0
86/66: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
87/1: pdb
87/2: %paste
87/3: %paste
88/1: %paste
89/1: %paste
89/2: %paste
90/1: %paste
90/2: import pdb
90/3: pdb.pm()
90/4: %paste
90/5: %paste
91/1: %paste
91/2: c
91/3: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':epsilon,'disp':1})
92/1: %paste
93/1: a
93/2: a is None
93/3:
if 'myVar' in locals():
    print('hi')
93/4:
if 'myVar' not in locals():
    print('hi')
94/1: %paste
94/2: %paste
95/1: %paste
95/2: %paste
96/1: %paste
96/2: %paste
96/3: %paste
97/1: %paste
97/2: %paste
97/3: %paste
97/4: %paste
98/1: %paste
99/1: %paste
99/2: %paste
100/1: %paste
101/1: %paste
102/1: %paste
102/2: %paste
103/1: %paste
103/2: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':0.01,'disp':1,'alpha_0':0.5,'c':0.6})
103/3: im_res = im_result['x'].reshape(N);
103/4:
np.min(im_res_
)
103/5: np.min(im_res)
103/6: np.max(im_res)
103/7: im_test = im_res + abs(np.min(im_res))
103/8: im_test
103/9: im_test = im_test/(np.max(im_test))
103/10: plt.imshow(im_test,interpolation='None',clim=(0,1))
103/11: plt.show()
103/12: TVWeight
103/13: XFMWeight
104/1: %paste
104/2: %paste
105/1: %paste
105/2: %paste
106/1: %paste
106/2: im_res = im_result['x'].reshape(N);
106/3: plt.imshow(im,interpolation='nearest')
106/4: plt.figure(2); plt.imshow(np.reshape(im_dc,(N)),interpolation='nearest')
106/5: plt.figure(3); plt.imshow(im_res,interpolation='nearest')
106/6: plt.show()
106/7: plt.figure(2); plt.imshow(np.reshape(im_dc,(N)),interpolation='nearest',bbox_images='tight')
106/8: plt.figure(2); plt.imshow(np.reshape(im_dc,(N)),interpolation='nearest')
106/9: plt.show()
106/10: plt.imshow(im,interpolation='nearest',clim=(0,1))
106/11: plt.title('True Image')
106/12: plt.savefig('simpleBoxData/TVandXFM/im.png')
106/13: plt.figure(2); plt.imshow(np.reshape(im_dc,(N)),interpolation='nearest',clim=(0,1))
106/14: plt.title('im_dc Image')
106/15: plt.savefig('simpleBoxData/TVandXFM/x0-im_dc.png')
106/16: plt.figure(3); plt.imshow(im_res,interpolation='nearest',clim=(0,1))
106/17: plt.title('im_dc Final Result')
106/18: plt.savefig('simpleBoxData/TVandXFM/final-im_dc.png')
106/19: plt.show()
106/20: ls
106/21: ls simpleBoxData/
106/22: ls simpleBoxData/TVOnly/
106/23: plt.savefig('simpleBoxData/TVandXFM/final-im_dc.png',bbox_inches='tight')
106/24: im_dc = im_dc*0
106/25: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
106/26: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':0.01,'disp':1,'alpha_0':0.5,'c':0.6,'xtol':5e-3})
106/27: im_res = im_result['x'].reshape(N);
106/28: #plt.imshow(im,interpolation='nearest',clim=(0,1))
106/29: #plt.title('True Image')
106/30: #plt.savefig('simpleBoxData/TVandXFM/im.png')
106/31: plt.figure(2); plt.imshow(np.reshape(im_dc,(N)),interpolation='nearest',clim=(0,1))
106/32: plt.title('im_dc Image')
106/33: plt.savefig('simpleBoxData/TVandXFM/x0-zeros.png')
106/34: plt.figure(3); plt.imshow(im_res,interpolation='nearest',clim=(0,1))
106/35: plt.title('im_dc Final Result')
106/36: plt.savefig('simpleBoxData/TVandXFM/final-zeros.png')
106/37: plt.show()
106/38: plt.figure(2); plt.imshow(np.reshape(im_dc,(N)),interpolation='nearest',clim=(0,1))
106/39: plt.title('Zeros Image')
106/40: plt.savefig('simpleBoxData/TVandXFM/x0-zeros.png')
106/41: plt.figure(3); plt.imshow(im_res,interpolation='nearest',clim=(0,1))
106/42: plt.title('Zeros Final Result')
106/43: plt.savefig('simpleBoxData/TVandXFM/final-zeros.png')
106/44: plt.show()
106/45: im_dc = im
106/46: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
106/47: im_dc
106/48: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':0.01,'disp':1,'alpha_0':0.5,'c':0.6,'xtol':5e-3})
106/49: im_res = im_result['x'].reshape(N);
106/50: plt.figure(3); plt.imshow(im_res,interpolation='nearest',clim=(0,1))
106/51: plt.title('im as x0 Final Result')
106/52: plt.savefig('simpleBoxData/TVandXFM/final-im.png')
106/53: plt.show()
106/54: numpy.save('im-result.npy',im_res)
106/55: np.save('im-result.npy',im_res)
106/56: im_dc = tf.ifft2c(data/np.fft.ifftshift(pdf),ph=ph).real.flatten().copy()
106/57: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
106/58: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':0.01,'disp':1,'alpha_0':0.5,'c':0.6,'xtol':5e-3})
106/59: im_res = im_result['x'].reshape(N);
106/60: np.save('im_dc-result.npy',im_res)
106/61: plt.imshow(im_res,clim=(0,1),interpolation='None')
106/62: plt.show()
106/63: im_dc = 0*im_dc
106/64: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
106/65: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':0.01,'disp':1,'alpha_0':0.5,'c':0.6,'xtol':5e-3})
106/66: im_res = im_result['x'].reshape(N);
106/67: np.save('zeros-result.npy',im_res)
106/68: plt.imshow(im_res,clim=(0,1),interpolation='None')
106/69: plt.show()
106/70: im_hold = np.concatenate([im_dc,0*im_dc,im],axis=2)
106/71: im_dc.shape
106/72: im.shape
106/73: im_hold = np.concatenate([im_dc,0*im_dc,im.flatten()],axis=1)
106/74: im_hold.shape
106/75: im_hold = np.concatenate([im_dc,0*im_dc,im.flatten()],axis=2)
106/76: im_hold.shape
106/77: im_hold = np.concatenate([im_dc.reshape(N),0*im_dc.reshape(N),im],axis=2)
106/78: im_hold = np.concatenate([im_dc.reshape([N,1]),0*im_dc.reshape([N,1]),im],axis=2)
106/79: im_hold = np.concatenate([im_dc.reshape([8,8,1]),0*im_dc.reshape([8,8,1]),im.reshape([8,8,1]),axis=2)
106/80:
im_hold = np.concatenate([im_dc.reshape([8,8,1]),0*im_dc.reshape([8,8,1]),im.reshape([8,8,1])
)
106/81: im_hold = np.concatenate([im_dc.reshape([8,8,1]),0*im_dc.reshape([8,8,1]),im.reshape([8,8,1]))
106/82: im_hold = np.concatenate([im_dc.reshape([8,8,1]),0*im_dc.reshape([8,8,1]),im.reshape([8,8,1])],axis=2)
106/83: im_hold.shape
106/84: a = 'tat'
106/85: a
106/86: ['the ' + a]
107/1: %paste
107/2: %paste
107/3: %paste
107/4: import pdb; pdb.pm()
107/5: x0sty
107/6: j
107/7: x0sty[j]
107/8: [x0sty[j] + '-result.npy'],im_res)
107/9: [x0sty[j] + '-result.npy']
107/10: x0sty[j] + '-result.npy'
107/11: %paste
107/12: sty
107/13: %paste
107/14: %paste
108/1: %paste
108/2: import pdb
108/3: pdb.pm()
109/1: %paste
109/2: %paste
109/3: %paste
109/4: sty = TVandXFM
109/5: sty = 'TVandXFM'
109/6: TVWeight = 0.01
109/7: XFMWeight = 0.01
109/8: %paste
109/9: %paste
109/10: %paste
109/11: %paste
109/12: im_vals
109/13: imvals
109/14: imvals[:,:,1]
109/15: wavelet = 'db4'
109/16: im
109/17: %paste
110/1: from __future__ import division
110/2: import numpy as np
110/3: import scipy as sp
110/4: import matplotlib.pyplot as plt
110/5: import os.path
110/6: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/') # Change this to the directory that you're saving the work in
110/7: import transforms as tf
110/8: import scipy.ndimage.filters
110/9: import grads
110/10: import sampling as samp
110/11: import direction as d
110/12: #from scipy import optimize as opt
110/13: import optimize as opt
110/14: import scipy.optimize as spopt
110/15: plt.rcParams['image.cmap'] = 'gray'
110/16: from recon_CS import *
110/17: %paste
110/18: im=np.load(filename)
110/19: im
110/20:
def rmse(xk,x):
        return np.sqrt(np.sum((xk-x)**2))
110/21: rms
110/22: rmse
110/23:
def rmse(xk,x):
        return np.sqrt(np.sum((xk-x)**2)/len(xk))
110/24: x0sty = ['im_dc','zeros','im']
110/25: sty = ['TVOnly','XFMOnly-nonTanh','TVandXFM']
110/26:
for i in xrange(3):
    for j in xrange(3):
        
        
        
        das
110/27: val = np.zeros(9)
110/28: val
110/29:
for i in xrange(3):
    for j in xrange(3):
        im_k = np.load('simpleBoxData/' + sty[i] + '/' + 'simpleBox' + x0sty[j] + '-result.npy')
        val[i*3+j] = rmse(im_k,im)
110/30:
for i in xrange(3):
    for j in xrange(3):
        im_k = np.load('simpleBoxData/' + sty[i] + '/' + 'SL-' + x0sty[j] + '-result.npy')
        val[i*3+j] = rmse(im_k,im)
110/31: val
110/32: plt.bar(val)
110/33: plt.bar(np.arange(val),val)
110/34: index = np.arange(val)
110/35: index = np.arange(len(val))
110/36: plt.bar(np.arange(len(val)),val)
110/37: plt.show()
110/38: plt.bar(np.arange(len(val)),val,ylim=(0,1))
110/39: plt.bar(np.arange(len(val)),val,clim=(0,1))
110/40: plt.bar(np.arange(len(val)),val,lim=(0,1))
110/41: xticklabels = []
110/42: xticklabels
110/43: xticklabels = ()
110/44: xticklabels
110/45:
for i in xrange(3):
    for j in xrange(3):
        xticklabels = xticklabels.append('sty[i] \n x0sty[j]')
110/46: xticklabels = []
110/47:
for i in xrange(3):
    for j in xrange(3):
        xticklabels = xticklabels.append('sty[i] \n x0sty[j]')
110/48: xticklabels = list()
110/49:
for i in xrange(3):
    for j in xrange(3):
        xticklabels = xticklabels.append('sty[i] \n x0sty[j]')
110/50: xticklabels = list(None)
110/51: xticklabels = list(0)
110/52: xticklabels = list(1)
110/53: xticklabels = {}
110/54: xticklabels = list(1)
110/55:
for i in xrange(3):
    for j in xrange(3):
        xticklabels = xticklabels.append('sty[i] \n x0sty[j]')
110/56: xticklabels = []
110/57:
for i in xrange(3):
    for j in xrange(3):
        xticklabels = xticklabels.append('sty[i] \n x0sty[j]')
110/58:
a = [1,2,3[
]]
110/59: a = [1,2,3]
110/60: a
110/61: a.append(2)
110/62: a
110/63:
for i in xrange(3):
    for j in xrange(3):
        xticklabels = xticklabels.append('sty[i] \n x0sty[j]')
110/64: xticklabels = [arange(9)]
110/65: xticklabels = [np.arange(9)]
110/66: xticklabels
110/67: xticklabels = [range(9)]
110/68: xticklabels
110/69: xticklabels = range(9)
110/70: xticklabels
110/71:
for i in xrange(3):
    for j in xrange(3):
        xticklabels[i*3+j] = 'sty[i] \n x0sty[j]'
110/72: xticklabels
110/73:
for i in xrange(3):
    for j in xrange(3):
        xticklabels[i*3+j] = sty[i] \n x0sty[j]
110/74:
for i in xrange(3):
    for j in xrange(3):
        xticklabels[i*3+j] = (sty[i] '\n' x0sty[j])
110/75:
for i in xrange(3):
    for j in xrange(3):
        xticklabels[i*3+j] = '' sty[i] '\n' x0sty[j] ''
110/76:
for i in xrange(3):
    for j in xrange(3):
        xticklabels[i*3+j] = sty[i] + '\n' + x0sty[j]
110/77: xticklabels
110/78: plt.bar(np.arange(len(val)),val)
110/79: fig, ax = plt.subplots()
110/80: rects1 = ax.bar(ind, menMeans, width, color='r', yerr=menStd)
110/81: fig, ax = plt.subplots()
110/82: plt.show()
110/83: fig, ax = plt.subplots()
110/84: ax.bar(index,val)
110/85: ax.set_label('RMSE')
110/86: ax.set_ylabel('RMSE')
110/87: ax.set_xlabel('Methods')
110/88: max(im_k)
110/89: np.max(im_k)
110/90: np.min(im_k)
111/1:
for i in xrange(3):
    for j in xrange(3):
        
        
        
        das
111/2:
for i in xrange(3):
    for j in xrange(3):
        im_k = np.load('simpleBoxData/' + sty[i] + '/' + 'simpleBox' + x0sty[j] + '-result.npy')
        val[i*3+j] = rmse(im_k,im)
111/3: import numpy as np
111/4:
def rmse(xk,x):
        return np.sqrt(np.sum((xk-x)**2)/len(xk))
111/5: import matplotlib.pyplot as plt
111/6: import os.path
111/7: os.chdir('/home/asalerno/Documents/pyDirectionCompSense/') # Change this to the directory that you're saving the work in
111/8: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/SheppLogan256.npy'
111/9: np.random.seed(2000)
111/10: #im = np.zeros([8,8]);
111/11: #im[3:5,3:5] = 1;
111/12: im=np.load(filename)
111/13: x0sty = ['im_dc','zeros','im']
111/14: sty = ['TVOnly','XFMOnly-nonTanh','TVandXFM']
111/15: #-------------------------------------------------------
111/16:
for i in xrange(3):                                        
        for j in xrange(3):
                im_k = np.load('simpleBoxData/' + sty[i] + '/' + 'simpleBox' + x0sty[j] + '-result.npy')
                im_k = (-np.min(im_k)+im_k)
                im_k = im_k/np.max(im_k) # Normalize the values of im_k
111/17: im_k
111/18: np,min(im_k)
111/19: np.min(im_k)
111/20: np.max(im_k)
111/21:
for i in xrange(3):                                        
        for j in xrange(3):
                im_k = np.load('simpleBoxData/' + sty[i] + '/' + 'simpleBox' + x0sty[j] + '-result.npy')
                im_k = (-np.min(im_k)+im_k)
                im_k = im_k/np.max(im_k) # Normalize the values of im_k
                val[i*3+j] = rmse(im_k,im)
111/22: #-------------------------------------------------------
111/23: val = range(len(sty)*len(x0sty))
111/24:
for i in xrange(len(sty)):                                        
        for j in xrange(len(x0sty)):
                im_k = np.load('simpleBoxData/' + sty[i] + '/' + 'SL-' + x0sty[j] + '-result.npy')
                im_k = (-np.min(im_k)+im_k)
                im_k = im_k/np.max(im_k) # Normalize the values of im_k
                val[i*3+j] = rmse(im_k,im)
111/25: val
111/26: im_k
111/27: plt.imshow(im_k)
111/28: plt.figure
111/29: plt.figure()
111/30: plt.imshow(im)
111/31: plt.show()
112/1: %paste
112/2: im.len
112/3: im.shape
112/4: mode
112/5: wavelet
112/6: tf.xfm(im)
112/7: shape(tf.xfm(im))
112/8: tf.xfm(im).shape
112/9: tf.xfm(im).size
112/10: len(tf.xfm(im))
112/11: len(tf.xfm(im,wavelet,mode))
112/12: len(tf.xfm(im,wavelet='db5',mode))
112/13: len(tf.xfm(im,wavelet='db5',mode='per'))
112/14: len(tf.xfm(im,wavelet='db2',mode='per'))
112/15: len(tf.xfm(im,wavelet='db1',mode='per'))
112/16: len(tf.xfm(im,wavelet='db10',mode='per'))
112/17: tf.xfm(im,wavelet='db10',mode='per')
112/18: tf.xfm(im[10:,10:],wavelet='db10',mode='per')
112/19: tf.xfm(im,wavelet='db10',mode='per') == tf.xfm(im,wavelet='db10',mode='zpd')
112/20: tf.xfm(im,wavelet='db10',mode='per') - tf.xfm(im,wavelet='db10',mode='zpd')
112/21: modes = ('zpd','cpd','sym','ppd','sp1','per')
112/22:
for i in range(len(modes)):
    args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,modes[i],a)
    im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':0.01,'disp':1,'alpha_0':0.5,'c':0.6,'xtol':5e-3})
    im_res = im_result['x'].reshape(N);
    np.save('testmodes/' + modes[i] + '-result.npy',im_res)
112/23: a=10.0
112/24:
for i in range(len(modes)):
    args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,modes[i],a)
    im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':0.01,'disp':1,'alpha_0':0.5,'c':0.6,'xtol':5e-3})
    im_res = im_result['x'].reshape(N);
    np.save('testmodes/' + modes[i] + '-result.npy',im_res)
112/25: modes
112/26: im_testers = np.zeros([6,256,256])
112/27: for i in range(6)"
112/28:
for i in range(6):
    im_testers[i,:,:] = np.load('testmodes/' + modes[i] '-result.npy')
112/29:
for i in range(6):
    im_testers[i,:,:] = np.load('testmodes/' + modes[i] + '-result.npy')
112/30:
for i in range(6):
    plt.imshow(im_testers[i,:,;],interpolation='nearest',clim=(0,1))
    plt.title('With Method of ' + modes[i])
112/31:
for i in range(6):
    plt.imshow(im_testers[i,:,:],interpolation='nearest',clim=(0,1))
    plt.title('With Method of ' + modes[i])
112/32:
for i in range(6):
    plt.imshow(im_testers[i,:,:],interpolation='nearest',clim=(0,1))
    plt.title('With Method of ' + modes[i])
    plt.savefig('testmodes/' + modes[i] + '-result.png
    ')
112/33:
for i in range(6):
    plt.imshow(im_testers[i,:,:],interpolation='nearest',clim=(0,1))
    plt.title('With Method of ' + modes[i])
    plt.savefig('testmodes/' + modes[i] + '-result.png')
112/34: plt.show()
112/35:
for i in range(len(modes)):
    args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,modes[i],a)
    im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':0.01,'disp':1,'alpha_0':0.5,'c':0.6,'xtol':5e-3})
    im_res = im_result['x'].reshape(N);
    np.save('testmodes/' + modes[i] + '-result.npy',im_res)
113/1: %paste
113/2: XFMWeight = 0.01
113/3: TVWeight = 0.01
113/4: i=2
113/5: %paste
113/6: 1+nan
113/7: 1+nan
113/8: 1+1/0
114/1: %paste
114/2: TVWeight
114/3: XFMWeight
114/4: XFMWeight=0
114/5: args = (N,TVWeight,XFMWeight,data,k,strtag,ph,dirWeight,dirs,M,nmins,wavelet,mode,a)
114/6: im_result = opt.minimize(optfun, im_dc, args = args, method=method, jac=derivative_fun, options={'maxiter':ItnLim,'gtol':0.01,'disp':1,'alpha_0':0.5,'c':0.6,'xtol':5e-3})
114/7: im_res = im_result['x'].reshape(N);
114/8: im_res = -np.min(im_res)+im_res
114/9: np.min(im_res)
114/10: im_res = im_res/np.max(im_res)
114/11: plt.imshow(im_res,clim=(0,1),interpolation='None')
114/12: plt.show()
114/13: x,y = np.meshgrid(np.linspace(-1,1,256),np.linspace(-1,1,256))
114/14: zx
114/15: x
114/16: x1 = 1/(exp(-x)+1)
114/17: x1 = 1/(np.exp(-x)+1)
114/18: plt.plot(x,x1)
114/19: plt.show()
114/20: x1 = 1/(np.exp(-x[:,1])+1)
114/21: plt.plot(x[:,1],x1)
114/22: plt.show()
114/23: x[:,1]
114/24: x[1,:]
114/25: plt.plot(x[1,:],x1)
114/26: x1 = 1/(np.exp(-x[1,:])+1)
114/27: x1
114/28: x,y = np.meshgrid(np.linspace(-5,5,256),np.linspace(-5,5,256))
114/29: x1 = 1/(np.exp(-x[1,:])+1)
114/30: plt.plot(x[1,:],x1)
114/31: plt.show()
114/32: x1 = 1/(np.exp(-x[1,:]/10)+1)
114/33: plt.plot(x[1,:],x1)
114/34: plt.show()
114/35: x1 = 1/(np.exp(-x[1,:]/1e-4)+1)
114/36: plt.plot(x[1,:],x1)
114/37: plt.show()
114/38: x1 = 1/(np.exp(-x[1,:]/1e-2)+1)
114/39: plt.plot(x[1,:],x1)
114/40: plt.show()
114/41: x1 = 1/(np.exp(-x[1,:]/1e-1)+1)
114/42: plt.plot(x[1,:],x1)
114/43: plt.show()
114/44: z = 1/(np.exp((-x-y)/1e-1)+1)
114/45: plt.imshow(z)
114/46: plt.show()
114/47:
z = 1/(np.exp((-abs(x+y)/1e-1)+1)
)
114/48: z = 1/(np.exp((-abs(x+y))/1e-1)+1)
114/49: plt.imshow(z)
114/50: plt.show()
114/51: z = 1/(np.exp((-abs(x+y)-1)/1e-1)+1)
114/52: plt.plot(x[1,:],x1)
114/53: plt.show()
114/54: plt.plot(x[1,:],x1)
114/55: z = 1/(np.exp((-abs(x[0,:]-3)-1)/1e-1)+1)
114/56: plt.plot(x[:,1],z)
114/57: plt.show()
115/1: import numpy as np
115/2: x = np.linspace(-5,5,10000)
115/3: y = 1/(1+np.exp(-(x-1)))
115/4: import matplotlib.pyplot as plt
115/5: plt.plot(x,y)
115/6: plt.show()
115/7: import matplotlib.pyplot as plt
115/8: y = 1/(1+np.exp(-(x-1)/10))
115/9: plt.plot(x,y)
115/10: y = 1/(1+np.exp(-(x)/10))
115/11: plt.plot(x,y)
115/12: plt.show()
115/13: y = 1/(1+np.exp(-(x)/.1))
115/14: plt.plot(x,y)
115/15: plt.show()
115/16: y = 1/(1+np.exp(-(x-1)/.1))
115/17: plt.show()
115/18: plt.plot(x,y)
115/19: plt.show()
115/20: xg,yg = np.meshgrid(np.linspace(-0.11,0.11,256),np.linspace(-0.11,.11,256))
115/21:
zg = (1/(1+np.exp(-(abs(xg)-.1)/.01)))*(1/(1+np.exp(-(abs(yg)-.1)/.01))
)
115/22: plt.imshow(zg)
115/23: plt.show()
115/24: zg
115/25: zg = (1/(1+np.exp(-(abs(xg)+.05)/.01)))*(1/(1+np.exp(-(abs(yg)+.05)/.01)))
115/26: plt.imshow(zg)
115/27: plt.show()
115/28: zg = np.fft.fftshift((1/(1+np.exp(-(abs(xg)+.05)/.01)))*(1/(1+np.exp(-(abs(yg)+.05)/.01))))
115/29: plt.imshow(zg)
115/30: plt.show()
115/31: np.max(zg)
115/32: np.min(zg)
115/33: zg = -np.min(zg)+zg
115/34: zg = zg/np.max(zg)
115/35: np.min(zg)
115/36: np.max(zg)
115/37: plt.imshow(zg)
115/38: plt.show()
115/39: filt = zg
115/40: np.save('fermifilter.npy',filt)
115/41: %paste
115/42: data = filt*data
115/43: %paste
115/44: xg,yg = np.meshgrid(np.linspace(-0.11,0.11,256),np.linspace(-0.11,.11,256))
115/45: zg = np.fft.fftshift((1/(1+np.exp((abs(xg)-.05)/.01)))*(1/(1+np.exp((abs(yg)-.05)/.01))))
115/46: plt.imshow(zg)
115/47: plt.show()
115/48: zg = (1/(1+np.exp((abs(xg)-.05)/.01)))*(1/(1+np.exp((abs(yg)-.05)/.01)))
115/49: plt.imshow(zg)
115/50: plt.show()
115/51: np.max(zg)
115/52: np.min(zg)
115/53: plt.plot(xg[128,:],zg[128,:])
115/54: plt.show()
115/55: zg = np.fft.fftshift((1/(1+np.exp(-(abs(xg)-.05)/.01)))*(1/(1+np.exp(-(abs(yg)-.05)/.01))))
115/56: plt.imshow(zg)
115/57: plt.show()
115/58: zg
115/59: zg = np.fft.fftshift((1/(1+np.exp(-(abs(xg)-.09)/.01)))*(1/(1+np.exp(-(abs(yg)-.09)/.01))))
115/60: plt.imshow(filt)
115/61: plt.show()
115/62: filt
115/63: zg = np.fft.fftshift((1/(1+np.exp(-(abs(xg)+.05)/.01)))*(1/(1+np.exp(-(abs(yg)+.05)/.01))))
116/1: %paste
116/2: %paste
117/1: %paste
117/2: plt.imshow(filt)
117/3: plt.show()
117/4: %paste
118/1: %paste
119/1: %paste
120/1: %paste
121/1: %paste
122/1: %paste
123/1: %paste
123/2: wvlt = tf.xfm(im,wavelet,mode)
123/3: gwvlt = wvlt[:]
123/4: gwvlt
123/5: len(gwvlt)
124/1: %paste
124/2: c
125/1: %paste
125/2: %paste
126/1: %paste
127/1: %paste
128/1: %paste
128/2: import pywt
128/3: w = pywt.Wavelet('db4')
128/4: w
128/5: print w
128/6:   Biorthogonal:   True
128/7: w = pywt.Wavelet('db1')
128/8: print w
129/1: %paste
129/2: %paste
130/1: %paste
131/1: %paste
131/2: plt.imshow(im_res)
131/3: plt.show()
132/1: %paste
132/2: plt.imshow(im_res)
132/3: plt.show()
133/1: %paste
134/1: %paste\
134/2: %paste
135/1: %paste
136/1: %paste
136/2: %paste
137/1: %paste
138/1: %paste
138/2: im_res = im_result['x'].reshape(N);
138/3: plt.imshow(im_res)
138/4: plt.show()
138/5: %paste
138/6: plt.imshow(im_res,interpolation='none')
138/7: plt.show()
138/8: im_res
138/9: f, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, sharex='col', sharey='row')
138/10: ax1.imshow(abs(gObj),interpolation='none',axis="tight")
138/11: ax1.imshow(abs(im_res),interpolation='none',axis="tight")
138/12: ax1.imshow(abs(im_res),interpolation='none',bbox_inches="tight")
138/13: ax1.imshow(abs(im_res),interpolation='none',xlim=(0,255))
138/14: ax1.imshow(abs(im_res),interpolation='none')
138/15: plt.show()
139/1: %paste
140/1: %paste
140/2: k = 1
140/3: "at" + 1
140/4: "at" + sting(1)
140/5: "at" + string(1)
140/6: `k`
141/1: %paste
142/1: %paste
142/2: %paste
143/1: %paste
144/1: %paste
145/1: %paste
146/1: %paste
147/1: %paste
148/1: %paste
149/1: %paste
149/2: TVWeight
149/3: TVWeight = 0.0001
149/4: XFMWeight = 0.0001
149/5: args = (N, TVWeight, XFMWeight, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
149/6:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.5, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
149/7: plt.imshow(im_res)
149/8: plt.show()
149/9: TVWeight = 1
149/10: TVWeights = [1,0.1,0.01,0.001,0.0001]
149/11: XFMWeights = TVWeights.copy()
149/12: TVWeights = np.array([1,0.1,0.01,0.001,0.0001])
149/13: XFMWeights = TVWeights.copy()
149/14:
for tv in TVWeights:
    for xfm in XFMWeights:
        print(tv)
        print(xfm)
149/15:
for tv in TVWeights:
    for xfm in XFMWeights:
        args = (N, tv, xfm, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
        im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                                 options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.5, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': tv, 'XFMWeight': xfm, 'N': N})
        im_res = im_result['x'].reshape(N)
        np.save('allOn_result_TV_' + `tv` + '_XFM_' + `xfm` + '.npy', im_res)
149/16: TVWeights = np.array([0.1,0.01,0.001,0.0001])
149/17: XFMWeights = TVWeights.copy()
149/18:
for tv in TVWeights:
    for xfm in XFMWeights:
        args = (N, tv, xfm, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
        im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                                 options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.5, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': tv, 'XFMWeight': xfm, 'N': N})
        im_res = im_result['x'].reshape(N)
        np.save('allOn_result_TV_' + `tv` + '_XFM_' + `xfm` + '.npy', im_res)
150/1: %paste
150/2: TVWeights = np.array([0.1,0.01,0.001,0.0001])
150/3: XFMWeights = TVWeights.copy()
150/4:
for tv in TVWeights:
    for xfm in XFMWeights:
        args = (N, tv, xfm, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
        im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                                 options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.5, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': tv, 'XFMWeight': xfm, 'N': N})
        im_res = im_result['x'].reshape(N)
        np.save('allOn_result_TV_' + `tv` + '_XFM_' + `xfm` + '.npy', im_res)
151/1: %paste
151/2:
for tv in TVWeights:
    for xfm in XFMWeights:
        args = (N, tv, xfm, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
        im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                                 options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.5, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': tv, 'XFMWeight': xfm, 'N': N})
        im_res = im_result['x'].reshape(N)
        np.save('allOn_result_TV_' + `tv` + '_XFM_' + `xfm` + '.npy', im_res)
151/3: TVWeights = np.array([0.1,0.01,0.001,0.0001])
151/4: XFMWeights = TVWeights.copy()
151/5:
for tv in TVWeights:
    for xfm in XFMWeights:
        args = (N, tv, xfm, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
        im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                                 options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.5, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': tv, 'XFMWeight': xfm, 'N': N})
        im_res = im_result['x'].reshape(N)
        np.save('allOn_result_TV_' + `tv` + '_XFM_' + `xfm` + '.npy', im_res)
153/1: im = np.zeros([8,8]);
153/2: im[3:5,3:5] = 1;
153/3: import numpy as np
153/4: import numpy as np
153/5: im = np.zeros([8,8]);
153/6: im[3:5,3:5] = 1;
153/7: im
153/8: tv_kernel = np.array([0, 1, 0, 1, 3, 1, 0, 1, 0]).reshape(3,3)
153/9: tv_kernel
153/10: import scipy as sp
153/11: from scipy import ndimage
153/12: tv_kernel
153/13: tv_kernel/3
153/14: from future import division
153/15: from __future__ import division
153/16: tv_kernel/3
153/17: tv_kernel = tv_kernel/3
153/18: test = sp.ndimage.convolve(im,tv_kernel,mode='constant')
153/19: test
153/20: import matplotlib.pyplot as plt
153/21: plt.imshow(test)
153/22: plt.show()
153/23: plt.imshow(test,interpolation='none')
153/24: plt.show()
153/25: tvk2 = np.array([-1,1])
153/26: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
153/27: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
153/28: tvk2 = np.array([[-1,1],[0,0]])
153/29: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
153/30: test2
153/31: tvk2 = np.array([[-1,1],[-1,1]])
153/32: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
153/33: test2
153/34: tvk2 = np.array([[-1,0],[-1,0]])
153/35: test2
153/36: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
153/37: test2
153/38: im
153/39: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
153/40: tvk2 = np.array([[-1,0],[0,0]])
153/41: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
153/42: test2
153/43: tvk2 = np.array([[-1,0],[0,-1]])
153/44: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
153/45: test2
153/46: tvk2 = np.array([[-1,0],[-1,0]])
153/47: tvk2 = np.array([[-1,0],[1,0]])
153/48: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
153/49: test2
153/50: tvk2 = np.array([[-1,0],[-1,0]])
153/51: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
153/52: tvk2 = np.array([[-1,0],[-1,0]])
153/53: test2
155/1: %paste
155/2: tf
155/3: im = np.zeros([8,8]);
155/4: im[3:5,3:5] = 1;
155/5: im
155/6: tf.TV(im)
155/7: strtag = ['spatial', 'spatial']
155/8: N = im.shape
155/9: tf.TV(im,N,strtag)
155/10: a
155/11: a = tf.TV(im,N,strtag)
155/12: a
155/13: a[0,:,:]
155/14: a = a.real
155/15: a
155/16: import scipy as sp
155/17: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
155/18: import scipy.ndimage
155/19: tvk2 = np.array([[-1,0],[-1,0]])
155/20: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
155/21: test2
155/22: tvk2 = np.array([[-1,0],[0,0]])
155/23: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
155/24: test2
155/25: tvk2 = np.array([[-1,0],[1,0]])
155/26: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
155/27: test2
155/28: a[0,:,:]
155/29: tvk2 = np.array([[0,-1],[0,1]])
155/30: test2 = sp.ndimage.convolve(im,tvk2,mode='constant')
155/31: test2
152/1: import array
152/2: array
152/3: import /home/bjnieman/source/vnmr/varian_recon/varian_read_files as vrf
152/4: import importlib.util
152/5: spec = importlib.util.spec_from_file_location("module.name", "/path/to/file.py")
152/6: foo = importlib.util.module_from_spec(spec)
152/7: spec.loader.exec_module(foo)
152/8: import importlib.util
152/9: import importlib
152/10: importlib.import_module('/home/bjnieman/source/vnmr/varian_recon_4/varian_read_file.py')
156/1: %paste
156/2: import varian_read_file as vrf
156/3: inputdirectory = '/hpf/largeprojects/MICe/zsu/CCP_Raw/ExVivo/Oct.17.16'
156/4: inputdirectory
156/5: vnmrfidfilelist,data_shape,header_info,param_dict,procpar_text_lines = vrf.open_vnmrfid_file(inputdirectory)
156/6: vnmrfidfilelist
156/7: vrf.close_vnmrfid_file(vnmrfidfilelist)
156/8: nmice = int(get_dict_value(param_dict,'nmice',1))
156/9: data_shape
156/10: inputdirectory = '/hpf/largeprojects/MICe/zsu/CCP_Raw/ExVivo/11may16/'
156/11: vnmrfidfilelist,data_shape,header_info,param_dict,procpar_text_lines = vrf.open_vnmrfid_file(inputdirectory)
156/12: data_shape
156/13: header_info
156/14: procpar_text_lines
156/15: %paste
156/16: inputdirectory
156/17: vnmrfidfilelist,data_shape,header_info,param_dict,procpar_text_lines = vrf.open_vnmrfid_file(inputdirectory)
156/18: vrf.close_vnmrfid_file(vnmrfidfilelist)
156/19: nmice = int(get_dict_value(param_dict,'nmice',1))
156/20: %paste
156/21: nmice = int(get_dict_value(param_dict,'nmice',1))
156/22: nmice
156/23: options
156/24: mouse_list
156/25: %paste
156/26: nrcvrs
156/27: nrcvrs = len(re.findall('y',get_dict_value(param_dict,'rcvrs','ynnn')))
156/28: nrcvrs
156/29: %paste
156/30: mouse_list = range(nmice)
156/31: mouse_list
156/32: seqrec = seqmodule.seq_reconstruction(options,param_dict,inputdirectory,outputfile)
156/33: inputdirectory = '/hpf/largeprojects/MICe/jacob/fid/14nov15.fid_20151114T113621/'
156/34: vnmrfidfilelist,data_shape,header_info,param_dict,procpar_text_lines = vrf.open_vnmrfid_file(inputdirectory)
156/35: vrf.close_vnmrfid_file(vnmrfidfilelist)
156/36: data_shape
156/37: inputdirectory
156/38: etl = int(vrf.get_dict_value(self.param_dict,'etl',6))
156/39: param_dict
156/40: %paste
156/41: gen_kspace(imouse=imouse)
156/42: imouse
156/43: gen_kspace(imouse=0)
156/44: imouse = 1
156/45: imouse = 0
156/46: etl = int(vrf.get_dict_value(param_dict,'etl',6))
156/47: nf = int(vrf.get_dict_value(param_dict,'nf',60))
156/48: ni_perchan = int(vrf.get_dict_value(param_dict,'ni',170)*vrf.get_dict_value(param_dict,'nfid',40))
156/49: nro = int(vrf.get_dict_value(param_dict,'np',630*2)/2)
156/50: nrcvrs = len(re.findall('y',get_dict_value(param_dict,'rcvrs','ynnn')))
156/51: t1_array = vrf.parse_petable_file(self.petable_name,'t1')
156/52: t1_array = vrf.parse_petable_file(petable_name,'t1')
156/53: get_dict_value(param_dict,'petable','petable')
156/54: t1_array = vrf.parse_petable_file(petable_name,'t1')
156/55: petable_name = get_dict_value(param_dict,'petable','petable')
156/56: t1_array = vrf.parse_petable_file(petable_name,'t1')
156/57: recontypestring
157/1: %paste
157/2: from pyminc.volumes.factory import *
157/3: from numpy import *
157/4: import sys
157/5:
pdf = samp.genPDF(N, P, pctg, radius=0.3,
                  cyl=[1,180,180])
157/6: N = np.array([256,256])
157/7: P
157/8: P= 5
157/9: pctg = 0.25
157/10:
pdf = samp.genPDF(N, P, pctg, radius=0.3,
                  cyl=[1,180,180])
157/11: pdf
157/12: plt.imshow(pdf)
157/13: plt.show()
157/14: k = samp.genSampling(pdf, 50, 2)[0].astype(int)
157/15: plt.imshow(k)
157/16: plt.show()
157/17: image
157/18: infile
158/1: %paste
158/2: from sys import path as syspath
158/3: syspath.append('/home/bjnieman/source/mri_recon')
158/4: from mri_recon import generate_option_parser_and_seq_module
158/5: import varian_read_file as vrf
158/6: from numpy import *
158/7: from numpy.fft import *
158/8: inputpetable="/projects/souris/jacob/fid/table_test/JE_Table_Angdist_nf60_ni17"
158/9: inputdirectory="/projects/souris/jacob/fid/29jul14.fid"
158/10: outputfile="dummy.mnc"
158/11: recon_cmd_str="/home/bjnieman/source/mri_recon/mri_recon.py dti_fse_varian --petable %s --petable_ordered_pairs %s %s"%(inputpetable,inputdirectory,outputfile)
158/12: parser,seqmodule = generate_option_parser_and_seq_module(recontypestring=recon_cmd_str.split(" ")[1])
158/13: seqoptions, args = parser.parse_args(recon_cmd_str.split(" "))
158/14: inputAcq = vrf.VarianAcquisition(inputdirectory,procpar_file=seqoptions.procpar_file_name)
158/15: seqrec = seqmodule.seq_reconstruction(inputAcq,seqoptions,outputfile)
158/16: seqrec.pre_recon_processing()
158/17: imouse = 5 #pick a mouse
158/18: seqrec.gen_kspace(imouse=imouse)
159/1: from sys import path as syspath
159/2: syspath.append('/home/bjnieman/source/mri_recon')
159/3: from mri_recon import generate_option_parser_and_seq_module
159/4: import varian_read_file as vrf
159/5: from numpy import *
159/6: from numpy.fft import *
159/7: #input parameters
159/8: inputpetable="/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294"
159/9: inputdirectory="./"
159/10: outputfile="dummy.mnc"
159/11: recon_cmd_str="/home/bjnieman/source/mri_recon/mri_recon.py flash_cyl_MICe --petable %s --petable_ordered_pairs %s %s"%(inputpetable,inputdirectory,outputfile)
159/12: parser,seqmodule = generate_option_parser_and_seq_module(recontypestring=recon_cmd_str.split(" ")[1])
159/13: seqoptions, args = parser.parse_args(recon_cmd_str.split(" "))
159/14: inputAcq = vrf.VarianAcquisition(inputdirectory,procpar_file=seqoptions.procpar_file_name)
159/15: #initialize seq specific data
159/16: seqrec = seqmodule.seq_reconstruction(inputAcq,seqoptions,outputfile)
159/17: #perform any global calibration or other analysis for all coils here
159/18: seqrec = seqmodule.seq_reconstruction(inputAcq,seqoptions,outputfile)
159/19: inputAcq = vrf.VarianAcquisition(inputdirectory,procpar_file=seqoptions.procpar_file_name)
159/20: inputAcq = vrf.BrukerAcquisition(inputdirectory,procpar_file=seqoptions.procpar_file_name)
160/1: from sys import path as syspath
160/2: syspath.append('/home/bjnieman/source/mri_recon')
160/3: from mri_recon import generate_option_parser_and_seq_module
160/4: import varian_read_file as vrf
160/5: from numpy import *
160/6: from numpy.fft import *
160/7: #input parameters
160/8: inputpetable="/projects/souris/jacob/fid/table_test/JE_Table_Angdist_nf60_ni17"
160/9: inputdirectory="/projects/souris/jacob/fid/29jul14.fid"
160/10: outputfile="dummy.mnc"
160/11: recon_cmd_str="/home/bjnieman/source/mri_recon/mri_recon.py dti_fse_varian --petable %s --petable_ordered_pairs %s %s"%(inputpetable,inputdirectory,outputfile)
160/12: parser,seqmodule = generate_option_parser_and_seq_module(recontypestring=recon_cmd_str.split(" ")[1])
160/13: seqoptions, args = parser.parse_args(recon_cmd_str.split(" "))
160/14: #generate inputAcq
160/15: inputAcq = vrf.VarianAcquisition(inputdirectory,procpar_file=seqoptions.procpar_file_name)
160/16: #initialize seq specific data
160/17: seqrec = seqmodule.seq_reconstruction(inputAcq,seqoptions,outputfile)
160/18: #perform any global calibration or other analysis for all coils here
160/19: seqrec.pre_recon_processing()
160/20: imouse = 5 #pick a mouse
160/21: seqrec.gen_kspace(imouse=imouse)
161/1: from sys import path as syspath
161/2: syspath.append('/home/bjnieman/source/mri_recon')
161/3: from mri_recon import generate_option_parser_and_seq_module
161/4: import bruker_read_file as brf
161/5: from numpy import *
161/6: from numpy.fft import *
161/7: #input parameters
161/8: inputpetable="/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294"
161/9: inputdirectory="./"
161/10: outputfile="dummy.mnc"
161/11: recon_cmd_str="/home/bjnieman/source/mri_recon/mri_recon.py flash_cyl_MICe --petable %s --petable_ordered_pairs %s %s"%(inputpetable,inputdirectory,outputfile)
161/12: parser,seqmodule = generate_option_parser_and_seq_module(recontypestring=recon_cmd_str.split(" ")[1])
161/13: seqoptions, args = parser.parse_args(recon_cmd_str.split(" "))
161/14: #generate inputAcq
161/15: inputAcq = brf.BrukerAcquisition(inputdirectory,procpar_file=seqoptions.procpar_file_name)
161/16: brf.BrukerAcquisition?
161/17: inputAcq = brf.BrukerAcquisition(inputdirectory,method='flash_cyl_MICe')
161/18: inputAcq = brf.BrukerAcquisition(inputdirector)
161/19: inputAcq = brf.BrukerAcquisition(inputdirectory)
161/20: inputAcq = brf.BrukerAcquisition(inputdirectory,acqp='flash_cyl_MICe')
161/21: inputAcq = brf.BrukerAcquisition(inputdirectory)
161/22: brf.BrukerAcquisition?
161/23: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name='flash_cyl_MICe')
161/24: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name='flash_cyl_MICe',acqp_name='flash_cyl_MICe')
161/25: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name='flash_cyl_MICe',acqp_name=seqoptions.procpar_file_name)
161/26: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name='flash_cyl_MICe',acqp_name='/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294')
161/27: inputdirectory
161/28: os.getcwd()
161/29: import os
161/30: os.getcwd()
161/31: inputdirectory="/hpf/largeprojects/MICe/segan/exercise_irradiation/bruker_data/running_D/P14/20160613_095024_Running_D_and_E_1_1"
161/32: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name='flash_cyl_MICe',acqp_name='/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294')
161/33: methodfile="/hpf/largeprojects/MICe/segan/exercise_irradiation/bruker_data/running_D/P14/20160613_095024_Running_D_and_E_1_1"
161/34: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile,acqp_name='/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294')
161/35: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name='method',acqp_name='/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294')
161/36: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile,acqp_name='/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294')
161/37: inputAcq = brf.BrukerAcquisition(inputdirectory+'/fid',method_name=methodfile,acqp_name='/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294')
161/38: %tb
161/39: inputdirectory+'/fid'
161/40: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile,acqp_name='/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294')
161/41: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile,acqp_name='/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294')
161/42: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile,acqp_name='/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294')
161/43: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile,acqp_name=seqoptions.procpar_file_name)
161/44: seqoptions.procpar_file_name
161/45: procparfile = inputdirectory+'/procpar'
161/46: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile,acqp_name=procpar)
161/47: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile,acqp_name=procparfile)
161/48: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile,acqp_name=procparfile)
161/49: procparfile = inputdirectory+'/specpar'
161/50: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile,acqp_name=procparfile)
160/22: fullkspacearray = fftshift(fft(fftshift(seqrec.kspace,axes=(-1,)),axis=-1),axes=(-1,))
161/51: procparfile = inputdirectory+'/acqp'
161/52: procparfile
161/53: acqpfile = procparfile
161/54: ls
161/55: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile,acqp_name=acqpfile)
161/56:
def bruker_paramfile_to_dict(brukerparamfile):
        bpfh = open(brukerparamfile,'r')
        text_lines = bpfh.readlines()
        bpfh.close()  
        param_dict={}
        ntext = 0
        curr_line = 0
        nlines = len(text_lines)
        while (curr_line<nlines):
                line = text_lines[curr_line]
                if ((line[0:7]=='$$ @vis') or (line[0:7]=='$$ ')):
                        curr_line += 1
                        continue
                    if line[0:3]=='##$':
                        words = line[3:].split('=') 
                        try:
                                val = int(words[1])
                            except ValueError,e:
                                    try:
                                            val = float(words[1])
                                        except ValueError,f:
                                                val = words[1][:-1]
                                                if (len(val)==0):
                                                        curr_line += 1
                                                        continue
                                                    if (words[0]=="PVM_SliceGeo"): #handle SliceGeo as special case since it is important for orientation info
                                                            slicegeostr = ''                 #expand this to handle multiple slice orientations? currently just grabs first one...
                                                            while 1:
                                                                    curr_line+=1
                                                                    line = text_lines[curr_line]
                                                                    if (line[0:2]=='##')|(line[0:2]=='$$'): break
                                                                    slicegeostr += line[:-1] #exclude new line char at the end of the line
                                                                param_dict['slicegeostr']=slicegeostr
                                                                c_regexpr=re.compile("\(\(\((?P<Gmatrix>.*?),(?P<Offset>.*?)\),(?P<Fov>.*?), <(?P<Row1>.*?)> <(?P<Row2>.*?)> <(?P<Row3>.*?)>,(?P<ustr1>.*?)\),(?P<ustr2>.*?),(?P<ustr3>.*?),(?P<ustr4>.*?),(?P<rsltn>.*?),(?P<ustr5>.*?),(?P<ustr6>.*?)\)",re.DOTALL)
                                                                c_matchiter=c_regexpr.finditer(slicegeostr)
                                                                val=[]
                                                                for c_matches in c_matchiter:
                                                                        valE={'Gmatrix':  reshape(array(map(float,c_matches.group('Gmatrix').split())),(3,3)),
                                                                             'Offset':   array(map(float,c_matches.group('Offset').split())),
                                                                             'Fov':      array(map(float,c_matches.group('Fov').split())),
                                                                             'RowOrder': [c_matches.group('Row1'),c_matches.group('Row2'),c_matches.group('Row3')],
                                                                             'ustr1':    c_matches.group('ustr1'),  #sort out these later if needed
                                                                             'ustr2':    c_matches.group('ustr2'),
                                                                             'ustr3':    c_matches.group('ustr3'),
                                                                             'ustr4':    c_matches.group('ustr4'),
                                                                             'rsltn':    c_matches.group('rsltn'),
                                                                             'ustr5':    c_matches.group('ustr5'),
                                                                             'ustr6':    c_matches.group('ustr6')}
                                                                        GmatOrder = [[i for i,j in enumerate(valE["RowOrder"]) if 'read' in j][0],
                                                                                     [i for i,j in enumerate(valE["RowOrder"]) if 'phase' in j][0],
                                                                                     [i for i,j in enumerate(valE["RowOrder"]) if 'slice' in j][0]]
                                                                        valE['GmatrixRPS'] = valE['Gmatrix'][GmatOrder,:]
                                                                        val.append(valE)
                                                                    curr_line -= 1
                                                                elif (val[0]=='(')&(val[-1]==')'):
                                                                        elems = []
                                                                        while 1:
                                                                                curr_line+=1
                                                                                line = text_lines[curr_line]
                                                                                if (line[0:2]=='##')|(line[0:2]=='$$'): break
                                                                                elem_words = line[:-1].split()
                                                                                elems.extend(elem_words)
                                                                            curr_line -= 1
                                                                            try:
                                                                                    type_array = 'int'
                                                                                    for m in range(len(elems)):
                                                                                            val = int(elems[m])
                                                                                    except ValueError,e:
                                                                                            try:
                                                                                                    type_array = 'float'
                                                                                                    for m in range(len(elems)):
                                                                                                            val = float(elems[m])
                                                                                                    except ValueError,f:
                                                                                                            type_array = 'str'
                                                                                                    if (type_array=='int'):
                                                                                                            val = array([int(x) for x in elems],int)
                                                                                                        elif (type_array=='float'):
                                                                                                                val = array([float(x) for x in elems],float)
                                                                                                            else:
                                                                                                                    val = elems
                                                                                                            elif (val[0]=='('):
                                                                                                                    elems = val.split(',')
                                                                                                                    elems[0] = elems[0].strip('(')
                                                                                                                    while 1:
                                                                                                                            curr_line+=1
                                                                                                                            line = text_lines[curr_line]
                                                                                                                            if (line[0:2]=='##')|(line[0:2]=='$$'): break
                                                                                                                            elem_words = line[:-1].split()
                                                                                                                            elems.extend(elem_words)
                                                                                                                        elems[-1] = elems[-1].strip(')')
                                                                                                                        val = elems    
                                                                                                            param_dict[words[0]] = val
                                                                                                            curr_line += 1
                                                                                                            continue
                                                                                                        curr_line += 1
                                                                                                    return param_dict
161/57: %paste
161/58: %paste
161/59: methodfile
161/60: methodfile = methodfile+'/method'
161/61: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile,acqp_name=procparfile)
161/62: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile,acqp_name=procparfile)
161/63: inputAcq
161/64: seqrec = seqmodule.seq_reconstruction(inputAcq,seqoptions,outputfile)
161/65: seqrec.pre_recon_processing()
161/66: imouse = 3 #pick a mouse
161/67: seqrec.gen_kspace(imouse=imouse)
161/68: fullkspacearray = fftshift(fft(fftshift(seqrec.kspace,axes=(-1,)),axis=-1),axes=(-1,))
161/69: import matplotlib.pyplot as plt
161/70: fullkspacearray.shape
161/71: data = fullkspacearray(1,1,:,:,:)
161/72: data = fullkspacearray[1,1,:,:,:]
161/73: data
161/74: data.shape
161/75: np.max(data)
161/76: max(data)
161/77: import numpy as np
161/78: np.max(data)
161/79: seqrec.gen_kspace()
161/80: fullkspacearray = fftshift(fft(fftshift(seqrec.kspace,axes=(-1,)),axis=-1),axes=(-1,))
161/81: data
161/82: np.all(data == fullkspacearray[1,1,:,:,:])
161/83: np.any(data == fullkspacearray[1,1,:,:,:])
161/84: np.sum(data == fullkspacearray[1,1,:,:,:])
161/85: len(data == fullkspacearray[1,1,:,:,:])
161/86: kplanes=transpose(fullkspacearray,axes=(3,0,1,2)).copy()
161/87: fullkspacearray
161/88: fullkspacearray.shape
161/89: seqrec.gen_kspace(imouse=imouse)
161/90: np.max(fullkspacearray[0,0,:,:,:])
161/91: np.max(fullkspacearray[0,1,:,:,:])
161/92: fullkspacearray = fftshift(fft(fftshift(seqrec.kspace,axes=(-1,)),axis=-1),axes=(-1,))
161/93: np.max(fullkspacearray[0,1,:,:,:])
161/94: np.max(fullkspacearray[0,0,:,:,:])
161/95: np.max(fullkspacearray[1,0,:,:,:])
161/96: np.max(fullkspacearray[1,1,:,:,:])
161/97: seqrec.gen_kspace()
161/98: fullkspacearray = fftshift(fft(fftshift(seqrec.kspace,axes=(-1,)),axis=-1),axes=(-1,))
161/99: seqrec.kspace.shape
161/100: fullkspacearray
161/101:
for i in range(2):
    for j in range(2):
        imgs
161/102: imgs = np.zeros(fullkspacearray.shape)
161/103: a = np.fft.fftn(fullkspacearray[0,0,:,:,:])
161/104: a
161/105: plt.imshow(a.real)
161/106: a.shape
161/107: plt.imshow(a.real[:,:,150])
161/108: plt.show()
161/109: a = np.fft.fftn(seqrec.kspace[0,0,:,:,:])
161/110: plt.imshow(a.real[:,:,150])
161/111: plt.show()
161/112: plt.imshow(abs(a[:,:,150]))
161/113: plt.show()
161/114: a = np.fft.fftn(seqrec.kspace[0,1,:,:,:])
161/115: plt.imshow(abs(a[:,:,150]))
161/116: plt.show()
162/1: from sys import path as syspath
162/2: syspath.append('/home/bjnieman/source/mri_recon')
162/3: from mri_recon import generate_option_parser_and_seq_module
162/4: import bruker_read_file as brf
162/5: from numpy import *
162/6: from numpy.fft import *
162/7: #input parameters
162/8: inputpetable="/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294"
162/9: inputdirectory="/hpf/largeprojects/MICe/segan/exercise_irradiation/bruker_data/running_D/P14/20160613_095024_Running_D_and_E_1_1"
162/10: outputfile="/home/asalerno/Documents/pyDirectionCompSense/dummy.mnc"
162/11: recon_cmd_str="/home/bjnieman/source/mri_recon/mri_recon.py flash_cyl_MICe --petable %s --petable_ordered_pairs %s %s"%(inputpetable,inputdirectory,outputfile)
162/12: parser,seqmodule = generate_option_parser_and_seq_module(recontypestring=recon_cmd_str.split(" ")[1])
162/13: seqoptions, args = parser.parse_args(recon_cmd_str.split(" "))
162/14: #generate inputAcq
162/15: methodfile = inputdirectory + '/method'
162/16: acqpfile = inputdirectory + '/acqp'
162/17: inputAcq = brf.BrukerAcquisition(inputdirectory,method_name=methodfile, acqp_name=acqpfile)
162/18: #initialize seq specific data
162/19: seqrec = seqmodule.seq_reconstruction(inputAcq,seqoptions,outputfile)
162/20: #perform any global calibration or other analysis for all coils here
162/21: seqrec.pre_recon_processing()
162/22: imouse = 3 #pick a mouse
162/23: seqrec.gen_kspace(imouse=imouse)
162/24: fullkspacearray = fftshift(fft(fftshift(seqrec.kspace,axes=(-1,)),axis=-1),axes=(-1,))
161/117: seqmodule
163/1: from pyminc.volumes.factory import *
163/2: from numpy import *
163/3: import sys
163/4: data = volumeFromFile('/hpf/largeprojects/MICe/segan/exercise_irradiation/bruker_data/running_C/P14/20160607_124310_Running_C_1_1/study_data/imgrecon.3.mnc)
163/5: data = volumeFromFile('/hpf/largeprojects/MICe/segan/exercise_irradiation/bruker_data/running_C/P14/20160607_124310_Running_C_1_1/study_data/imgrecon.3.mnc')
163/6: infile = '/hpf/largeprojects/MICe/segan/exercise_irradiation/bruker_data/running_C/P14/20160607_124310_Running_C_1_1/study_data/imgrecon.3.mnc'
163/7: data
163/8: data.data
163/9: data.data.shape
163/10: import matplotlib.pyplot as plt
163/11: plt.rcParams['image.cmap'] = 'gray'
163/12: plt.imshow(data[:,:,180])
163/13: plt.show()
163/14: plt.imshow(data[:,:,190])
163/15: plt.show()
163/16: plt.imshow(data[:,:,190])
163/17: plt.show()
163/18: 294-256
163/19: (294-256)/2
163/20: len(data[19:-19,1,1])
163/21: plt.imshow(data[19:-19,19:-19,190])
163/22: plt.show()
163/23: img = data[19:-19,19:-19,:]
163/24: img.shape
163/25: import numpy as np
163/26: np.save(img,'/home/asalerno/Documents/pyDirectionCompSense/data/testbrain.npy')
163/27: img = img.data
163/28: img = data.data[19:-19,19:-19,:]
163/29: np.save(img,'/home/asalerno/Documents/pyDirectionCompSense/data/testbrain.npy')
163/30: img
163/31: np.save(img.data,'/home/asalerno/Documents/pyDirectionCompSense/data/testbrain.npy')
163/32: img
163/33: img.data
163/34: data.data
163/35: img.data[1]
163/36: data.dataLoaded
163/37: data.dataLoadable
163/38: data.detdata
163/39: data.getdata
163/40: data.getdata()
163/41: data.loaddata
163/42: data.loadData()
163/43: data
163/44: data.data
163/45: a = data.loadData()
163/46: a
163/47: a
163/48: a = data.data
163/49: a
163/50: a = data.data['data']
163/51: a = data.data('data')
163/52: a = data('data')
163/53: a = data.data{'data'}
163/54: a = data.data['data']
163/55: a = data.data.dtype
163/56: data.data.dtype
163/57: data.data.ndim
163/58: data.data.view
163/59: data.data.view()
163/60: data.data.shap
163/61: data.data.shape
163/62: data.data['start
163/63: data.data['start']
163/64: a = data.getdata()
163/65: a
163/66: a[1]
163/67: img = a
163/68: np.save(img,'/home/asalerno/Documents/pyDirectionCompSense/data/testbrain.npy')
163/69: a
163/70: data.readonly
163/71: data.separations
163/72: data.setdata
163/73: data.sizes
163/74: data.get_string_form_of_numpy_dtype
163/75: data.get_string_form_of_numpy_dtype()
163/76: data.getHyperslab
163/77: data.getHyperslab()
163/78: data.getdata
163/79: data.getdata()
163/80: array(data.getdata())
163/81: a = array(data.getdata())
163/82: a.shape
163/83: img = a
163/84: np.save(img,'/home/asalerno/Documents/pyDirectionCompSense/data/testbrain.npy')
163/85: np.save('/home/asalerno/Documents/pyDirectionCompSense/data/testbrain.npy',img)
163/86: np.save('/home/asalerno/Documents/pyDirectionCompSense/data/testbrain.npy',data.data)
164/1: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/testbrain.npy'
164/2: %paste
164/3: data = tf.fft2c(im, ph=ph)
164/4: im = np.load(filename)
164/5: N = np.array(im.shape)  # image Size
164/6: #tupleN = tuple(N)
164/7: pctg = 0.25  # undersampling factor
164/8: P = 5  # Variable density polymonial degree
164/9: # ph = tf.matlab_style_gauss2D(im,shape=(5,5));
164/10: ph = np.ones(im.shape, complex)
164/11: test = tf.fft2c(im, ph=ph)
164/12: plt.imshow(np.log10(abs(test)))
164/13: plt.show()
164/14:
plt.imshow(abs(np.fft.fftshift(test))
)
164/15: plt.show()
164/16: plt.imshow(abs(np.fft.fftshift(log(abs(test)))))
164/17: plt.imshow(abs(np.fft.fftshift(np.log(abs(test)))))
164/18:
plt.show(0
)
164/19: test = np.fft.fft2(im)
164/20: plt.show(im)
164/21: plt.imshow(im)
164/22: plt.show()
164/23: filename
164/24: filename = '/home/asalerno/Documents/pyDirectionCompSense/data/testbrain.npy'
164/25: im = np.load(filename)
164/26: %paste
164/27: im.shape
164/28: im = im[:,:,190]
164/29: plt.imshow(im)
164/30: plt.show()
164/31: data = tf.fft2c(im, ph=ph)
164/32: N
164/33: N = N[:-1]
164/34: N
164/35: data = tf.fft2c(im, ph=ph)
164/36: im
164/37: im.size
164/38: ph.shape
164/39: ph = ph[:,:,190]
164/40: plt.imshow(ph)
164/41: ph
164/42: ph = tf.matlab_style_gauss2D(im,shape=(5,5))
164/43: ph
164/44: plt.imshow(abs(ph))
164/45: plt.show()
164/46: ph
164/47: data = tf.fft2c(im, ph=ph)
164/48: plt.imshow(data)
164/49: plt.imshow(real(data))
164/50: plt.imshow(data.real)
164/51: plt.show()
164/52: plt.imshow(np.fft.fftshift(np.log10(data.real)))
164/53: plt.show()
164/54:
plt.imshow(np.fft.fftshift(np.log10(abs(data)))
)
164/55: plt.show()
164/56: data
164/57: pdf = samp.genPDF(N, P, pctg, radius=0.3, cyl=[0])
164/58: plt.imshow(pdf)
164/59: plt.show()
164/60: plt.imshow(pdf,clim=[0,1])
164/61: plt.show()
164/62: %paste
164/63: %paste
164/64: genPDF
164/65: pdf = genPDF(N, P, pctg, radius=0.3, cyl=[0])
164/66: pdf
164/67: plt.imshow(pdf)
164/68: plt.show()
164/69: pdf = genPDF(N, P, pctg, radius=0.3, cyl=[1,180,180])
164/70: pdf
164/71: pdf.shape
164/72: pdf = genPDF(N, P, pctg, radius=0.3, cyl=[1,256,256])
164/73: import ipdb
164/74: import pdb
164/75: pdf = genPDF(N, P, pctg, radius=0.3, cyl=[1,256,256])
164/76: pdb.pm()
164/77: %paste
164/78: pdf = genPDF(N, P, pctg, radius=0.3, cyl=[1,256,256])
164/79: 1.2
164/80: 1.2.astype(int)
164/81: a = 1.2
164/82: a.astype(int)
164/83: int(a)
164/84: pdf = genPDF(N, P, pctg, radius=0.3, cyl=[1,256,256])
164/85: pdf
164/86: %paste
164/87: pdf = genPDF(N, P, pctg, radius=0.3, cyl=[1,256,256])
164/88: %paste
164/89: pdf = genPDF(N, P, pctg, radius=0.3, cyl=[1,256,256])
164/90: pdf
164/91: plt.imshow(pdf)
164/92: plt.show()
164/93: pdf = genPDF(N, P, pctg, radius=0.3, cyl=[1,256,256],disp=1)
164/94: plt.show()
164/95: pdf = genPDF(N, P, pctg, radius=0.3, cyl=[0],disp=1)
164/96: plt.show()
164/97: plt.imshow(pdf,clim=[0,1])
164/98: plt.show()
164/99: pdf
164/100: plt.imshow(pdf,clim=[0,1])
164/101: pdf = genPDF(N, P, pctg, radius=0.3, cyl=[0,294,294],disp=1)
164/102: plt.imshow(pdf,clim=[0,1])
164/103: plt.show()
164/104: pdf
164/105: pdf = genPDF(N, P, pctg, radius=0.3, cyl=[1,294,294],disp=1)
164/106: pdf
164/107: plt.imshow(pdf,clim=[0,1])
164/108: plt.show()
165/1: %paste
165/2: options=dummyopt(complexavg=True,petable=petable,petable_ordered_pairs=True)
165/3: petable="/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294"
165/4: options=dummyopt(complexavg=True,petable=petable,petable_ordered_pairs=True)
165/5: inputAcq = brf.BrukerAcquisition(inputdirectory)
165/6: inputdirectory="/hpf/largeprojects/MICe/segan/exercise_irradiation/bruker_data/running_C/P14/20160607_124310_Running_C_1_1"
165/7: inputAcq = brf.BrukerAcquisition(inputdirectory)
165/8: inputAcq
165/9: seqrec = seqmodule.seq_reconstruction(inputAcq,options,"./temp.mnc")
165/10: seqrec.kspace
165/11: seqrec.recon()
165/12: seqrec.recon(imouse)
165/13: seqrec.recon(imouse=2)
165/14: help seqrec.recon
165/15: seqrec
165/16: seqrec.options
165/17: seqrec.options()
165/18: seqrec.gen_kspace(imouse=2)
165/19: rgf.default_recon(seqrec)
165/20: options
165/21: options.complexavg
165/22: ls
165/23: seqrec
165/24: seqrec.recon()
167/1: inputpetable="/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294"
167/2: inputdirectory="/hpf/largeprojects/MICe/segan/exercise_irradiation/bruker_data/running_D/P14/20160613_095024_Running_D_and_E_1_1"
167/3: outputfile="/home/asalerno/Documents/pyDirectionCompSense/dummy.mnc"
167/4: petable = inputpetable
167/5: options=dummyopt(complexavg=True,petable=petable,petable_ordered_pairs=True)
167/6: %paste
167/7: options=dummyopt(complexavg=True,petable=petable,petable_ordered_pairs=True)
167/8: %paste
167/9: options=dummyopt(complexavg=True,petable=petable,petable_ordered_pairs=True)
167/10: inputAcq = brf.BrukerAcquisition(inputdirectory)
167/11: seqrec = seqmodule.seq_reconstruction(inputAcq,options,"./temp.mnc")
167/12: seqrec.recon()
167/13: mouselist = [0,1,2,3]
167/14: mouselist = 2
167/15: imouse = 2
167/16: seqrec.gen_kspace(imouse=imouse)
165/25: seqrec.recon()
165/26: seqrec.image_data
165/27: seqrec.image_data.shape
165/28: test = seqreq.copy
165/29: test = seqrec.copy()
165/30: test = copy(seqrec)
165/31: test = copy(seqrec)
165/32: import copy
165/33: test = copy.deepcopy(seqrec)
165/34: test
165/35: mouselist = range(4)
165/36:
for i in mouselist:
    test.gen_kspace(imouse=i)
165/37: i
165/38:
for i in mouselist:
    test.gen_kspace(imouse=i)
165/39: test = seqmodule.seq_reconstruction(inputAcq,options,"./temp.mnc")
165/40: test = seqmodule.seq_reconstruction(inputAcq,options,"./temp.mnc")
165/41:
for i in mouselist:
    test.gen_kspace(imouse=i)
165/42: test.kspace.shape
165/43: seqrec.image_data
165/44: seqrec.image_data.shape
165/45: test.recon(imouse)
165/46: test.recon(imouse=2)
165/47: test.recon()
168/1: %paste
168/2: im = rff.getDataFromFID(petable,inputdirectory,2)
169/1: %paste
168/3: im.shape
168/4: fullimagedata = im
168/5: im = fullimagedata(1,:,:,190)
168/6: im = fullimagedata[1,:,:,190]
168/7: im = fullimagedata[0,:,:,190]
168/8: im.shape
168/9: plt.imshow(im)
168/10: plt.show()
168/11: fullimagedata = fullimagedata[0,:,:,:]
168/12: fullimagedata = fullimagedata[0,:,:,:]
168/13: TEST = np.fft.fft2(fullimagedata,axes=(0,1))
168/14: TEST
168/15: fullImData = fullImData-np.min(fullImData)
168/16: fullImData = fullimagedata
168/17: fullImData = fullImData-np.min(fullImData)
168/18: fullImData = fullImData/np.max(fullImData)
168/19: fullImData.shape
168/20: np.max(fullImData)
168/21: np.min(fullImData)
168/22: N = fullImData.shape
168/23: N
168/24: Nsort = np.argsort(N)
168/25: Nsort
168/26: fftData = np.fft.fft2(fullImData,axes=Nsort[0,1])
168/27: fftData = np.fft.fft2(fullImData,axes=Nsort[0:1])
168/28: fftData
168/29: plt.imshow(fftData[:,:,190])
168/30: plt.imshow(fftData.real[:,:,190])
168/31: plt.show()
168/32: fftData.shape
168/33: plt.imshow(fft.fft2(fftData[:,:,190]))
168/34: plt.imshow(np.fft.fft2(fftData[:,:,190]))
168/35: plt.imshow(np.fft.fft2(fftData[:,:,190]).real)
168/36: plt.show()
168/37: test = np.fft.fft2(fullImData[:,:,190])
168/38: plt.imshow(test)
168/39: plt.imshow(test.real)
168/40: plt.show()
168/41: np.all(test == fftData[:,:,190])
168/42: np.any(test == fftData[:,:,190])
168/43: fftData = np.fft.fft2(fullImData,axes=(0,1))
168/44: np.any(test == fftData[:,:,190])
168/45: Nsort
168/46: Nsort[0:1]
168/47: fftData = np.fft.fft2(fullImData,axes=(Nsort[0],Nsort[1]))
168/48: plt.imshow(np.fft.fft2(fftData[:,:,190]).real)
168/49: plt.show()
168/50: im_full = fullImData(:,:,sliceChoice)
168/51: im_full = fullImData[:,:,sliceChoice]
168/52: sliceChoice = 190
168/53: fullImData = rff.getDataFromFID(petable,inputdirectory,2)
168/54: fullImData = fullImData-np.min(fullImData)
168/55: fullImData = fullImData/np.max(fullImData)
168/56: im_full = fullImData[:,:,sliceChoice]
168/57: N = fullImData.shape
168/58: N_sort = np.argsort(N)
168/59: # Now, FFT over the two PE Axes
168/60: fftData = np.fft.fft2(fullImData,axes=(Nsort[0],Nsort[1]))
168/61: data_full = np.fft.fftshift(fftData[:,:,sliceChoice])
168/62: plt.imshow(im_full); plt.colorbar()
168/63: im_full.shap
168/64: im_full.shape
168/65: fullImData.shape
168/66: im = fullImData[0,:,:,sliceChoice]
168/67: plt.imshow(im_full); plt.colorbar(); plt.show()
168/68: plt.imshow(im); plt.colorbar(); plt.show()
168/69: tester = np.fft.fft2(im)
168/70: data_full = np.fft.fftshift(fftData[:,:,sliceChoice])
168/71: np.all(tester == data_full)
168/72: np.max(tester - data_full)
168/73: np.all(tester == data_full[0,:,:])
168/74: np.max(tester - data_full[0,:,:])
168/75: data_full = np.fft.fftshift(fftData[0,:,:,sliceChoice])
168/76: np.all(tester == data_full)
168/77: np.max(tester - data_full)
168/78: tester
168/79: data_full
168/80: max(data_full)
168/81: fullImData.shapw
168/82: fullImData.shape
168/83: fullImData = fullImData[0,:,:,:]
168/84: fftData = np.fft.fft2(fullImData,axes=(Nsort[0],Nsort[1]))
168/85: data_full = np.fft.fftshift(fftData[0,:,:,sliceChoice])
168/86: data_full = np.fft.fftshift(fftData[:,:,sliceChoice])
168/87: np.all(tester == data_full)
168/88: tester.shape
168/89: data_full.shape
168/90: np.max(tester - data_full)
170/1: %paste
170/2: im
170/3: plt.imshow(im)
170/4: plt.show()
170/5: N = fullImData.shape
170/6: N_sort = np.argsort(N)
170/7: N
170/8: Nsort = np.argsort(N)
170/9: fftData = np.fft.fft2(fullImData,axes=(Nsort[0],Nsort[1]))
170/10: data_full = np.fft.fftshift(fftData[:,:,sliceChoice])
170/11: N = np.array(im.shape)  # image Size
170/12: #tupleN = tuple(N)
170/13: pctg = 0.25  # undersampling factor
170/14: P = 5  # Variable density polymonial degree
170/15: ph = tf.matlab_style_gauss2D(im,shape=(5,5));
170/16: #ph = np.ones(im.shape, complex)
170/17: # Generate the PDF for the sampling case -- note that this type is only used in non-directionally biased cases.
170/18: plt.imshow(np.log10(abs(data_full)))
170/19: plt.show()
170/20: plt.imshow(np.log10(abs(data_full)))
170/21: plt.show()
169/2: 7005420819575348
170/22: biased cases.
170/23: pdf = samp.genPDF(N, P, pctg, radius=0.3, cyl=[0])
170/24: # Set the sampling pattern -- checked and this gives the right percentage
170/25: k = samp.genSampling(pdf, 50, 2)[0].astype(int)
170/26: reload(samp)
170/27: pdf = samp.genPDF(N, P, pctg, radius=0.3, cyl=[0])
170/28: k = samp.genSampling(pdf, 50, 2)[0].astype(int)
170/29: k
170/30: tf
170/31: mode='periodization'
170/32: reload(tf)
170/33: test = tf.xfm(im,wavelet=wavelet,mode=mode)
170/34: test
170/35: test2 = tf.ixfm(test,wavelet=wavelet,mode=mode)
170/36: np.max(test2-test)
170/37: test.shape
170/38: np.max(test2-im)
170/39: # Generate the PDF for the sampling case -- note that this type is only used in non-directionally biased cases.
170/40: pdf = samp.genPDF(N, P, pctg, radius=0.3, cyl=[0])
170/41: # Set the sampling pattern -- checked and this gives the right percentage
170/42: k = samp.genSampling(pdf, 50, 2)[0].astype(int)
170/43: # Here is where we build the undersampled data
170/44: data = np.fft.ifftshift(k) * tf.fft2c(im, ph=ph)
170/45: # ph = phase_Calculation(im,is_kspace = False)
170/46: # data = np.fft.ifftshift(np.fft.fftshift(data)*ph.conj());
170/47: #filt = tf.fermifilt(N)
170/48: #data = data * filt
170/49: im_scan = tf.ifft2c(data, ph=ph)
170/50: im_dc = np.zeros(data.shape)
170/51: # Optimization algortihm -- this is where everything culminates together
170/52: a = 10.0
170/53: args = (N, TVWeight, XFMWeight, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
170/54:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.5, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
170/55: im_res = im_result['x'].reshape(N)
170/56: plt.imshow(im_scan)
170/57: plt.imshow(abs(im_scan))
170/58: plt.show()
170/59: plt.imshow(abs(im_res))
170/60: plt.show()
170/61: a = 10.0
170/62: args = (N, TVWeight, XFMWeight, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
170/63:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
170/64: im_res = im_result['x'].reshape(N)
170/65: plt.imshow(im_res)
170/66: plt.show()
170/67: plt.imshow(abs(im_scan))
170/68: plt.show()
170/69: ls
170/70: plt.imshow(abs(im_scan)); plt.colorbar(); plt.title('Pseudo-Undersampled Image')
170/71: plt.show()
170/72: f1 = plt.imshow(abs(im_scan)); plt.colorbar(); plt.title('Pseudo-Undersampled Image')
170/73: import saveFig
170/74: import saveFig
170/75: f1 = plt.imshow(abs(im_scan)); plt.colorbar(); plt.title('Pseudo-Undersampled Image')
170/76: saveFig.save("brainData/bruker/exercise_irradiation/running_C/P14/undersampled_brain")
170/77: plt.show()
170/78: plt.imshow(abs(im)); plt.colorbar(); plt.title('Pseudo-Undersampled Image')
170/79: plt.show()
170/80: plt.imshow(abs(im)); plt.colorbar(); plt.title('Fully Sampled Image')
170/81: saveFig.save("brainData/bruker/exercise_irradiation/running_C/P14/fully_sampled_brain")
170/82: im_dc
170/83: plt.imshow(im_dc)
170/84: plt.show()
170/85: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=[0]')
170/86: plt.show()
170/87: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=[0]')
170/88: saveFig.save("brainData/bruker/exercise_irradiation/running_C/P14/result_im_dc_zeros")
170/89: im_dc = np.ones(data.shape)
170/90: data.shape
170/91:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
170/92: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=[1]'); plt.show()
170/93: im_res = im_result['x'].reshape(N)
170/94: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=[1]'); plt.show()
170/95: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=[1]');
170/96: saveFig.save("brainData/bruker/exercise_irradiation/running_C/P14/result_im_dc_ones")
170/97: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
170/98:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
170/99: im_res = im_result['x'].reshape(N)
170/100: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=DensityCorrected');
170/101: saveFig.save("brainData/bruker/exercise_irradiation/running_C/P14/result_im_dc_DensityCorrected")
170/102: im_scan = tf.ifft2c(data, ph=ph)
170/103: plt.imshow(im_scan); plt.colorbar(); plt.title('Pseudo-Undersampled Image')
170/104: plt.imshow(abs(im_scan)); plt.colorbar(); plt.title('Pseudo-Undersampled Image')
170/105: saveFig.save("brainData/bruker/exercise_irradiation/running_C/P14/undersampled_brain.png")
170/106: saveFig.save("brainData/bruker/exercise_irradiation/running_C/P14/undersampled_brain")
170/107: %paste
170/108: plt.imshow(pdf)
170/109: plt.show()
170/110: plt.imshow(abs(im_scan))
170/111: plt.show()
170/112: im_dc
170/113: plt.imshow(im_dc)
170/114: plt.show()
170/115: plt.imshow(abs(im_res))
170/116: plt.show()
170/117: plt.show(abs(im_res-im_scan))
170/118: plt.show()
170/119: plt.imshow(abs(im_res-im_scan))
170/120: plt.show()
170/121: plt.imshow(abs(im_scan)); plt.colorbar(); plt.title('Pseudo-Undersampled Image -- Smaller Radius')
170/122: saveFig.save("brainData/bruker/exercise_irradiation/running_C/P14/rad_0.1/undersampled_brain")
170/123: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=[0]');
170/124: saveFig.save("brainData/bruker/exercise_irradiation/running_C/P14/rad_0.1/result_im_dc_zeros")
170/125: im_dc = np.ones(im_dc.shape)
170/126: a = 10.0
170/127: args = (N, TVWeight, XFMWeight, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
170/128:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
170/129: im_res = im_result['x'].reshape(N)
170/130: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=[1]');
170/131: saveFig.save("brainData/bruker/exercise_irradiation/running_C/P14/rad_0.1/result_im_dc_ones")
170/132: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).copy()
170/133: plt.imshow(abs(im_dc))
170/134: plt.show()
170/135: saveFig.save("brainData/bruker/exercise_irradiation/running_C/P14/rad_0.1/im_dc_densityCorrected")
170/136: %paste
170/137: a = 10.0
170/138: args = (N, TVWeight, XFMWeight, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
170/139:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
170/140: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
170/141:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
170/142: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=DensityCorrected');
170/143: saveFig.save("brainData/bruker/exercise_irradiation/running_C/P14/rad_0.1/result_im_dc_DensityCorrected")
170/144: plt.imshow(pdf);
170/145: plt.figure(2)
170/146: plt.imshow(k)
170/147: plt.show()
170/148: pdf = samp.genPDF(N, P, pctg, radius=0.3, cyl=[0])
170/149: k = samp.genSampling(pdf, 50, 2)[0].astype(int)
170/150: plt.imshow(pdf);
170/151: plt.figure(2)
170/152: plt.imshow(k)
170/153: plt.show()
170/154: np.sum(k)/len(k)
170/155: len(k)
170/156: np.sum(k)/k.size
171/1: %paste
171/2: plt.imshow(im)
171/3: plt.imshow(im); plt.colorbar(); plt.title('Fully Sampled Image')
171/4: import saveFig
171/5: saveFig('sheppLoganData/fully_sampled_SL')
171/6: saveFig.save('sheppLoganData/fully_sampled_SL')
171/7: plt.imshow(im_scan); plt.colorbar(); plt.title('Undersampled Image -- Radius = 0.1')
171/8: plt.imshow(im_scan.reshape(256,256)); plt.colorbar(); plt.title('Undersampled Image -- Radius = 0.1')
171/9: plt.imshow(abs(im_scan)); plt.colorbar(); plt.title('Undersampled Image -- Radius = 0.1')
171/10: saveFig.save('sheppLoganData/undersampled_SL')
171/11: plt.imshow(abs(im_dc)); plt.colorbar(); plt.title('Im_DC = Density Corrected')
171/12: plt.imshow(abs(im_dc.reshape(256,256))); plt.colorbar(); plt.title('Im_DC = Density Corrected')
171/13: saveFig.save('sheppLoganData/im_dc=densityCorrected')
171/14: im_dc = np.zeros(im_dc.shape)
171/15: args = (N, TVWeight, XFMWeight, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
171/16:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.5, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
171/17: im_res = im_result['x'].reshape(N)
171/18: plt.imshow(abs(im_res.reshape(256,256))); plt.colorbar(); plt.title('Final Image -- im_dc=[0]')
171/19: saveFig.save('sheppLoganData/final_result_im_dc=0')
171/20: im_dc = np.ones(im_dc.shape)
171/21:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.5, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
171/22: pdf
171/23: plt.imshow(pdf)
171/24: plt.show()
171/25: import scipy
171/26: test = scipy.ndimage.filters.gaussian_filter(pdf,3)
171/27: plt.imshow(test)
171/28: plt.show()
171/29: x = np.linspace(0,len(test))
171/30: x
171/31: im
171/32: plt.plot(x,test[:,128],x,pdf[:,128])
171/33: plt.plot(x,test[:,128])
171/34: x
171/35: plt.plot(x,test[128,:])
171/36: test[128,:]
171/37: test[128,:].shape
171/38: x.shape
171/39: x = np.linspace(0,len(test),len(test))
171/40: plt.plot(x,test[:,128],x,pdf[:,128])
171/41: plt.show()
171/42: test = scipy.ndimage.filters.gaussian_filter(pdf,1)
171/43: plt.plot(x,test[:,128],x,pdf[:,128])
171/44: plt.show()
170/157: reload(samp)
170/158: reload(samp)
170/159: %paste
170/160: plt.imshow(abs(im_scan))
170/161: plt.figure
170/162: plt.figure()
170/163: plt.imshow(abs(im_dc))
170/164: plt.figure()
170/165: plt.imshow(abs(im_res))
170/166: plt.show()
170/167: plt.imshow(k)
170/168: plt.show()
170/169: plt.show(pdf)
170/170: plt.imshow(pdf)
170/171: plt.show()
170/172: samp
170/173: reload(samp)
170/174: pdf = samp.genPDF(N, P, pctg, radius=0.3, cyl=[0])
170/175: pdf = samp.genPDF(N, P, pctg, radius=0.1,cyl=[0])
170/176: plt.imshow(pdf)
170/177: plt.show()
170/178: %paste
170/179: plt.imshow(pdf)
170/180: plt.show()
170/181: plt.imshow(k)
170/182: plt.show()
170/183: im_scan = tf.ifft2c(data, ph=ph)
170/184: # Primary first guess. What we're using for now. Density corrected
170/185: #im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
170/186: im_dc = np.zeros(data.shape)
170/187: plt.imshow(im_scan)
170/188: plt.imshow(abs(im_scan))
170/189: plt.colorbar()
170/190: plt.show()
170/191: np.max(im)
170/192: np.max(im_scan)
170/193: np.min(im)
170/194: # Optimization algortihm -- this is where everything culminates together
170/195: a = 10.0
170/196: args = (N, TVWeight, XFMWeight, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
170/197:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
170/198: im_res = im_result['x'].reshape(N)
170/199: plt.imshow(im_res)
170/200: plt.show()
170/201: plt.imshow(k)
170/202: plt.show()
170/203: pctg = 0.33
170/204: im_dc = im.flatten().copy()
170/205: im_dc
170/206:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
170/207: im_res = im_result['x'].reshape(N)
170/208: plt.imshow(im_res)
170/209: plt.show()
170/210: maxval = np.max(im)
170/211: minval = np.min(im)
170/212: plt.imshow(im_res,clim=(minval,maxval))
170/213: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=im');
170/214: saveFig.save("brainData/bruker/exercise_irradiation/running_C/P14/rad_0.1/result_im_dc_as_im")
172/1: %paste
173/1: # Imports
173/2: from __future__ import division
173/3: import numpy as np
173/4: import scipy as sp
173/5: import matplotlib.pyplot as plt
173/6: import os.path
173/7: from sys import path as syspath
173/8: syspath.append("/home/asalerno/pyDirectionCompSense/source/")
173/9:
os.chdir(
    '/home/asalerno/Documents/pyDirectionCompSense/')  # Change this to the directory that you're saving the work in
173/10: import transforms as tf
173/11: import scipy.ndimage.filters
173/12: import grads
173/13: import sampling as samp
173/14: import direction as d
173/15: # from scipy import optimize as opt
173/16: import optimize as opt
173/17: import scipy.optimize as spopt
173/18: plt.rcParams['image.cmap'] = 'gray'
173/19: from recon_CS import *
173/20: import read_from_fid as rff
173/21: # Initialization variables
173/22: inputdirectory="/hpf/largeprojects/MICe/segan/exercise_irradiation/bruker_data/running_C/P14/20160607_124310_Running_C_1_1"
173/23: petable = "/hpf/largeprojects/MICe/bjnieman/Bruker_cyltests/cylbruker_nTRfeath18_294_294"
173/24: strtag = ['spatial', 'spatial']
173/25: TVWeight = 0.005
173/26: XFMWeight = 0.005
173/27: dirWeight = 0
173/28: # DirType = 2
173/29: ItnLim = 150
173/30: epsilon = 1e-6
173/31: l1smooth = 1e-15
173/32: xfmNorm = 1
173/33: wavelet = 'db4'
173/34: mode = 'per'
173/35: method = 'CG'
173/36: dirFile = None
173/37: nmins = None
173/38: dirs = None
173/39: M = None
173/40: radius = 0.1
173/41: sliceChoice = 190
173/42: # Make the data go from clim=[0,1]
173/43: fullImData = rff.getDataFromFID(petable,inputdirectory,2)[0,:,:,:]
173/44: fullImData = fullImData-np.min(fullImData)
173/45: fullImData = fullImData/np.max(fullImData)
173/46: im = fullImData[:,:,sliceChoice]
173/47: N = fullImData.shape
173/48: Nsort = np.argsort(N)
173/49: # Now, FFT over the two PE Axes
173/50: fftData = np.fft.fft2(fullImData,axes=(Nsort[0],Nsort[1]))
173/51: data_full = np.fft.fftshift(fftData[:,:,sliceChoice])
173/52: N = np.array(im.shape)  # image Size
173/53: #tupleN = tuple(N)
173/54: pctg = 0.25  # undersampling factor
173/55: P = 5  # Variable density polymonial degree
173/56: ph = tf.matlab_style_gauss2D(im,shape=(5,5));
173/57: #ph = np.ones(im.shape, complex)
173/58: # Generate the PDF for the sampling case -- note that this type is only used in non-directionally biased cases.
173/59: pdf = samp.genPDF(N, P, pctg, radius=radius, cyl=[0])
173/60: # Set the sampling pattern -- checked and this gives the right percentage
173/61: k = samp.genSampling(pdf, 50, 2)[0].astype(int)
173/62: # Here is where we build the undersampled data
173/63: data = np.fft.ifftshift(k) * tf.fft2c(im, ph=ph)
173/64: # ph = phase_Calculation(im,is_kspace = False)
173/65: # data = np.fft.ifftshift(np.fft.fftshift(data)*ph.conj());
173/66: #filt = tf.fermifilt(N)
173/67: #data = data * filt
173/68: # IMAGE from the "scanner data"
173/69: im_scan = tf.ifft2c(data, ph=ph)
173/70: # Primary first guess. What we're using for now. Density corrected
173/71: #im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
173/72: im_dc = np.zeros(data.shape)
173/73: # Optimization algortihm -- this is where everything culminates together
173/74: a = 10.0
173/75: args = (N, TVWeight, XFMWeight, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
173/76:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
173/77: im_res = im_result['x'].reshape(N)
173/78: maxval = np.max(im)
173/79: minval = np.min(im)
173/80: plt.imshow(im_res,clim=(minval,maxval))
173/81: plt.show()
173/82: plt.imshow(im_res,clim=(minval,maxval)); plt.colorbar(); plt.title('Result with im_dc=0')
173/83: import saveFig
173/84: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/result_im_dc_zeros")
173/85: im_dc = np.ones(data.shape)
173/86:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
173/87: im_res = im_result['x'].reshape(N)
173/88: plt.imshow(im_res,clim=(minval,maxval)); plt.colorbar(); plt.title('Result with im_dc=1')
173/89: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/result_im_dc_ones")
173/90: plt.imshow(im_res,clim=(minval,maxval)); plt.colorbar(); plt.title('Result with im_dc=1')
173/91: plt.show()
173/92: %paste
173/93: plt.imshow(abs(im_scan),clim=(minval,maxval))
173/94: plt.show()
173/95: plt.imshow(abs(im_res),clim=(minval,maxval))
173/96: plt.show()
173/97: plt.imshow(im_res,clim=(minval,maxval)); plt.colorbar(); plt.title('33%% Sampled Result with im_dc=1')
173/98: plt.show()
173/99: plt.imshow(im_res,clim=(minval,maxval)); plt.colorbar(); plt.title('33% Sampled Result with im_dc=0')
173/100: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/33per_result_im_dc_ones")
173/101: plt.imshow(im_res,clim=(minval,maxval)); plt.colorbar(); plt.title('33% Sampled Result with im_dc=0')
173/102: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/33per_result_im_dc_zeros")
173/103: %paste
173/104: data = np.fft.ifftshift(k) * tf.fft2c(im, ph=ph)
173/105: # ph = phase_Calculation(im,is_kspace = False)
173/106: # data = np.fft.ifftshift(np.fft.fftshift(data)*ph.conj());
173/107: #filt = tf.fermifilt(N)
173/108: #data = data * filt
173/109: # IMAGE from the "scanner data"
173/110: im_scan = tf.ifft2c(data, ph=ph)
173/111: plt.imshow(im_scan)
173/112: plt.imshow(abs(im_scan),clim=(minval,maxval))
173/113: plt.show()
173/114: np.sum(k)
173/115: np.sum(k)/k.shape
173/116: np.sum(k)/k.size
173/117: pctg
173/118: pctg=.5
173/119: %paste
173/120: k
173/121: np.sum(k)/k.size
173/122: plt.imshow(abs(im_scan),clim=(minval,maxval))
173/123: plt.show()
173/124: im_dc =im
173/125: %paste
173/126: plt.imshow(abs(im_res),clim=(minval,maxval))
173/127: plt.show()
173/128: im_dc = np.zeros(data.shape)
173/129: %paste
173/130: plt.imshow(abs(im_res),clim=(minval,maxval))
173/131: plt.show()
173/132: plt.imshow(abs(im_res),clim=(minval,maxval))
173/133: plt.figure()
173/134: plt.imshow(abs(im),clim=(minval,maxval))
173/135: plt.show()
173/136: plt.imshow(k)
173/137: plt.show()
170/215: im
170/216: plt.imshow(im)
170/217: plt.show()
170/218: plt.imshow(data)
170/219: plt.imshow(abs(data))
170/220: plt.show()
170/221: plt.imshow(np.log10(abs(data)))
170/222: plt.show()
170/223: np.any(data==0)
170/224: np.sum(data==0)
170/225: np.sum(data!=0)
170/226: 21609+64827
170/227: 21609+64827/(294**2)
170/228: (21609+64827)/(294**2)
170/229: DATA = tf.ifft2c(data)
170/230: data_full
170/231: data
170/232: plt.imshow(np.log10(abs(data_full)))
170/233: plt.show()
170/234: pctg
170/235: im_dc
170/236: im_dc.shape
170/237: q = ceil(sqrt(3)*294)
170/238: q = np.ceil(sqrt(3)*294)
170/239: q = np.ceil(np.sqrt(3)*294)
170/240: q
170/241: q = int(np.ceil(np.sqrt(3)*294))
170/242: q
170/243: q = int(np.ceil(294/np.sqrt(3)))
170/244: q
170/245: q = int(np.ceil(294/np.sqrt(3)/2))
170/246: q
170/247: 294-2*85
170/248: 294/124
170/249: np.sqrt(3)
170/250: 294/np.sqrt(3)
170/251: 294/np.sqrt(3)/2
170/252: 124**2
170/253: 124**2/294**2
170/254: q = int(np.ceil(294/(3**2)/2))
170/255: q
170/256: 294-2*q
170/257: 260**2/294**2
170/258: q = int(np.ceil(294-np.ceil(294/pctg)/2))
170/259: q
170/260: q = int(np.ceil((294-np.ceil(294/pctg))/2))
170/261: q
170/262: 294/pctg
170/263: q = int(np.ceil((294-np.ceil(294/np.sqrt(1/pctg)))/2))
170/264: q
170/265: 294-2*q
170/266: (294-2*q)**2/294**2
170/267: data_lr = data[q:-q,q:-q]
170/268: data_lr
170/269: data_lr = data_full[q:-q,q:-q]
170/270: data_lr
170/271:
plt.imshow(abs(data_lr)
)
170/272: plt.show()
170/273: im_lr = np.fft.fftshift(np.fft.fft2(np.fft.fftshift(data_lr)))
170/274: plt.imshow(im_lr)
170/275: plt.imshow(im_lr.real)
170/276: plt.show()
170/277: im_lr = (np.fft.fft2(np.fft.fftshift(data_lr)))
170/278: plt.imshow(im_lr.real)
170/279: plt.show()
170/280: plt.imshow(im_lr.real.T)
170/281: plt.show()
170/282: plt.imshow(im_lr.real.T.T)
170/283: plt.show()
170/284: im_lr.flipud()
170/285: np.flipud(im_lr)
170/286: im_test = tf.ifft2c(tf.fft2c(im_lr))
170/287: im_test = tf.ifft2c(tf.fft2c(im_lr,im_lr.shape),im_lr.shape)
170/288: p
170/289: p = np.ones(im_lr.shape)
170/290: im_test = tf.ifft2c(tf.fft2c(im_lr,p),p)
170/291: plt.imshow(im_test)
170/292: plt.imshow(abs(im_test))
170/293: plt.show()
170/294: im_lr = np.flipud(im_lr)
170/295: np.max(im_test- im_lr)
170/296: np.max(im_test)
170/297: np.max(im_lr)
170/298: im_test = np.flipud(im_test)
170/299: np.max(im_test- im_lr)
170/300: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=im');
170/301: plt.figure
170/302: im_res
170/303: im_res = im_res-np.min(im_res)
170/304: im_res = im_res/np.max(im_res)
170/305: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=im');
170/306: im_lr = im_lr - np.min(im_lr)
170/307: im_lr = im_lr/np.max(im_lr)
170/308: np.max(im_lr)
170/309: np.min(im_lr)
170/310: plt.imshow(abs(im_lr)); plt.colorbar(); plt.title('Low Res')
170/311: plt.close()
170/312: plt.show()
170/313: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=im');
170/314: plt.figure
170/315: plt.figure()
170/316: plt.imshow(abs(im_res)); plt.colorbar(); plt.title('Result with im_dc=im');
170/317: plt.imshow(abs(im_lr)); plt.colorbar(); plt.title('Low Res')
170/318: plt.show()
170/319: plt.imshow(abs(im_res)); plt.title('Result with im_dc=im');
170/320: plt.figure()
170/321: plt.imshow(abs(im_lr)); plt.title('Low Res')
170/322: plt.show()
170/323: im_lr = np.fliplr(im_lr)
174/1: %paste
174/2: minval = np.min(im)
174/3: maxval = np.max(im)
174/4: pctg
174/5: '%f%%' + pctg
174/6: '%f%%' % pctg
174/7: '%d%%' % pctg
174/8: '%2f%%' % pctg
174/9: '%f2%%' % pctg
174/10: '%.2f%%' % pctg
174/11: imdcs = 'zeros'
174/12: "Reconstructed Image with %.2f%% Sampling and im_dc==" + imdcs % pctg
174/13: "Reconstructed Image with %.2f%% Sampling and im_dc=" % pctg + imdcs
174/14: "brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV%.2f_XFM%.2f/%.2fper_result_im_dc_" % TVWeight, XFMWeight, pctg + imdcs
174/15: "brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV%.2f_XFM%.2f/%.2fper_result_im_dc_" % TVWeight % XFMWeight % pctg + imdcs
174/16: "brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV%.2f_XFM%.2f/%.2fper_result_im_dc_" % TVWeight % XFMWeight % pctg + imdcs
174/17: "brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV%.2f_XFM%.2f/%.2fper_result_im_dc_" % (TVWeight, XFMWeight, pctg) + imdcs
175/1: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/33per_result_im_dc_zeros")
175/2: q = int(np.ceil((294-np.ceil(294/np.sqrt(1/pctg)))/2))
175/3: import numpy as np
175/4: q = int(np.ceil((294-np.ceil(294/np.sqrt(1/pctg)))/2))
175/5: q
174/18: lrLoc = int(np.ceil((294-np.ceil(294/np.sqrt(1/pctg)))/2))
174/19: im_lr = tf.fft2c(tf.ifft2c(im,np.ones(im.shape))[lrLoc:-lrLoc,lrLoc:-lrLoc],np.ones(im[lrLoc:-lrLoc,lrLoc:-lrLoc].shape))
174/20: plt.imshow(im_lr)
174/21: plt.imshow(abs(im_lr))
174/22: plt.show()
174/23:
tf.ifft2c(im,np.ones(im.shape)
)
174/24: data_lr = tf.ifft2c(im,np.ones(im.shape))
174/25: plt.imshow(data_lr)
174/26: data_lr
174/27: im_lr = tf.fft2c(np.fft.fftshift(np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]),np.ones(im[lrLoc:-lrLoc,lrLoc:-lrLoc].shape))
174/28: plt.imshow(abs(im_lr))
174/29: plt.show()
174/30: plt.imshow(im_lr.real)
174/31: plt.show()
174/32: %paste
174/33: import saveFig
174/34: %paste
174/35:
for imdcs in ['zeros','ones','densCorr','imFull']:
        if imdcs == 'zeros':
                im_dc = np.zeros(data.shape)
            elif imdcs == 'ones':
                    im_dc = np.ones(data.shape)
                elif imdcs == 'densCorr':
                        im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
                    elif imdcs == 'imFull':
                            im_dc = im
174/36:     # Optimization algortihm -- this is where everything culminates together
174/37:     a = 10.0
174/38:     args = (N, TVWeight, XFMWeight, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
174/39:     im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
174/40:                             options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
174/41:     im_res = im_result['x'].reshape(N)
174/42:     plt.imshow(abs(im_res),clim=(minval,maxval))
174/43:     plt.title("Reconstructed Image with %.2f%% Sampling and im_dc==" % pctg + imdcs)
174/44:     saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV%.2f_XFM%.2f/%.2fper_result_im_dc_" % (TVWeight, XFMWeight, pctg) + imdcs)
174/45: %paste
174/46: "brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV%.2f_XFM%.2f/%.2fper_result_im_lr" % (TVWeight, XFMWeight, pctg)
174/47: %paste
174/48: %paste
174/49: %paste
176/1: import numpy as np
176/2: imdcs = 'zeros'
176/3: TVWeight = 0.0005
176/4: XFMWeight = 0.0005
176/5: "brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV%s_XFM%s/%.2fper_result_im_dc_" % (float('%.1g', TVWeight), float('%.1g', XFMWeight) , pctg) + imdcs
176/6: "brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV%s_XFM%s/%.2fper_result_im_dc_" % (float('%.1g' % TVWeight), float('%.1g' % XFMWeight) , pctg) + imdcs
176/7: pctg = 0.20
176/8: "brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV%s_XFM%s/%.2fper_result_im_dc_" % (float('%.1g' % TVWeight), float('%.1g' % XFMWeight) , pctg) + imdcs
177/1: %paste
177/2: %paste
178/1: %paste
179/1: %paste
180/1: %paste
181/1: import numpy as np
181/2: np.save --help
181/3: help(np.save)
182/1: %paste
182/2: %paste
182/3: %paste
183/1: %paste
184/1: %paste
185/1: # Imports
185/2: from __future__ import division
185/3: import numpy as np
185/4: import scipy as sp
185/5: import matplotlib.pyplot as plt
185/6: import os.path
185/7: from sys import path as syspath
185/8: syspath.append("/home/asalerno/pyDirectionCompSense/source/")
185/9:
os.chdir(
    '/home/asalerno/Documents/pyDirectionCompSense/')  # Change this to the directory that you're saving the work in
185/10: import transforms as tf
185/11: import scipy.ndimage.filters
185/12: import grads
185/13: import sampling as samp
185/14: import direction as d
185/15: # from scipy import optimize as opt
185/16: import optimize as opt
185/17: import scipy.optimize as spopt
185/18: import saveFig
185/19: plt.rcParams['image.cmap'] = 'gray'
185/20: from recon_CS import *
185/21: optfun
185/22: optfun.func_code
185/23: optfun.func_code()
185/24: optfun.func_defaults
185/25: %paste
186/1: %paste
187/1: %paste
187/2: import inspect
187/3: inspect.getsourcelines(optfun)
187/4: import dill
187/5: inspect.getsource(optfun)
187/6: %paste
187/7: %paste
188/1: %paste
188/2: %paste
188/3: plt.rcParams['image.cmap'] = 'gray'
188/4: %paste
182/4: %paste
189/1: %paste
189/2: %paste
189/3: %paste
188/5: im_dc
188/6: im_dc = np.zeros(data.shape)
190/1: import numpy as np
190/2: import errorcalc as err
190/3: %paste
190/4: %paste
190/5: ls
190/6: import errorcalc
190/7: syspath.append("/home/asalerno/pyDirectionCompSense/source/")
190/8: import errorcalc
190/9: cd source
190/10: import errorcalc
190/11: np.prod([5,6,6,4,294,294])
190/12: 256**4
190/13: imgsData = np.zeros([5,6,6,4,294,294])
190/14: %paste
190/15: %paste
190/16: pc
190/17: TV
190/18: imdc
190/19: %paste
190/20: imdc
190/21: imdc=-1
190/22: %paste
190/23: pc
190/24: TV
190/25: imdc
190/26: %paste
190/27: imdc
190/28: %paste
188/7: im
188/8: plt.imshow(im)
188/9: plt.show()
189/4: im
189/5: plt.imshow(im)
189/6: plt.show()
189/7: np.save('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/fullySampledBrain.npy',im)
190/29: im = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/fullySampledBrain.npy')
190/30: im
190/31:
def rmse(xk,x):
        return np.sqrt(np.sum((xk-x)**2)/len(xk))
190/32: %paste
190/33: %paste
190/34: rmse_data
190/35: %paste
190/36: rmse
190/37: rmse_data
190/38: np.savetxt('/home/asalerno/Documents/pyDirectionCompSense/rmse.txt',rmse,header='pctg,TV,XFM,imdc',delimiter=',')
190/39: np.savetxt('/home/asalerno/Documents/pyDirectionCompSense/rmse.txt',rmse_data,header='pctg,TV,XFM,imdc',delimiter=',')
190/40: import matplotlib.pyplot as plt
190/41: pctg = [0.20, 0.25, 0.33, 0.40, 0.50]
190/42: TVWeight = [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05]
190/43: XFMWeight = [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05]
190/44: imdcs = ['zeros','ones','densCorr','imFull']
190/45: N = len(pctg)
190/46: ind = np.arange(N)
190/47: width =0.2
190/48: # TV and XFM Comparison
190/49: fig, ax = plt.subplots()
190/50: rects1 = ax.bar(ind,rmse_data[2,0,:,2], color='r', alpha=.1)
190/51: rects2 = ax.bar(ind,rmse_data[2,1,:,2], color='b', alpha=.3)
190/52: rects3 = ax.bar(ind,rmse_data[2,2,:,2], color='b', alpha=.5)
190/53: rects4 = ax.bar(ind,rmse_data[2,3,:,2], color='b', alpha=.7)
190/54: rects5 = ax.bar(ind,rmse_data[2,4,:,2], color='b', alpha=.9)
190/55: rects6 = ax.bar(ind,rmse_data[2,5,:,2], color='b', alpha=1)
190/56: ax.set_ylabel('RMSE')
190/57: ax.set_title('RMSE for Different TV and XFM Combinations')
190/58: ax.set_xticks(ind+width)
190/59: ax.set_xticklabels(('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'))
190/60: ax.set_xlabel('XFMWeights')
190/61: ax.legend((rects1[0], rects2[0], rects3[0], rects4[0], rects5[0], rects6[0]),('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'),title='TVWeights')
190/62: re
190/63: rects1 = ax.bar(ind,rmse_data[2,0,:,2].flat(), color='r', alpha=.1)
190/64: rects1 = ax.bar(ind,rmse_data[2,0,:,2].flat, color='r', alpha=.1)
190/65: N = len(XFMWeight)
190/66: ind = np.arange(N)
190/67: width =0.2
190/68: rects2 = ax.bar(ind,rmse_data[2,1,:,2], color='b', alpha=.3)
190/69: plt.close
190/70: plt.close()
190/71: pctg = [0.20, 0.25, 0.33, 0.40, 0.50]
190/72: TVWeight = [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05]
190/73: XFMWeight = [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05]
190/74: imdcs = ['zeros','ones','densCorr','imFull']
190/75: N = len(XFMWeight)
190/76: ind = np.arange(N)
190/77: width =0.2
190/78: # TV and XFM Comparison
190/79: fig, ax = plt.subplots()
190/80: rects1 = ax.bar(ind,rmse_data[2,0,:,2], color='r', alpha=.1)
190/81: rects2 = ax.bar(ind,rmse_data[2,1,:,2], color='b', alpha=.3)
190/82: rects3 = ax.bar(ind,rmse_data[2,2,:,2], color='b', alpha=.5)
190/83: rects4 = ax.bar(ind,rmse_data[2,3,:,2], color='b', alpha=.7)
190/84: rects5 = ax.bar(ind,rmse_data[2,4,:,2], color='b', alpha=.9)
190/85: rects6 = ax.bar(ind,rmse_data[2,5,:,2], color='b', alpha=1)
190/86: ax.set_ylabel('RMSE')
190/87: ax.set_title('RMSE for Different TV and XFM Combinations')
190/88: ax.set_xticks(ind+width)
190/89: ax.set_xticklabels(('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'))
190/90: ax.set_xlabel('XFMWeights')
190/91: ax.legend((rects1[0], rects2[0], rects3[0], rects4[0], rects5[0], rects6[0]),('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'),title='TVWeights')
190/92: plt.show()
190/93: %paste
190/94: plt.show()
190/95: %paste
190/96: plt.show()
190/97: %paste
190/98: fig, ax = plt.subplots()
190/99: rects1 = ax.bar(ind,rmse_data[2,0,:,2], width, color='r', alpha=.1)
190/100: rects2 = ax.bar(ind-2*width,rmse_data[2,1,:,2], width, color='b', alpha=.3)
190/101: rects3 = ax.bar(ind-width,rmse_data[2,2,:,2], width, color='b', alpha=.5)
190/102: rects4 = ax.bar(ind,rmse_data[2,3,:,2], width, color='b', alpha=.7)
190/103: rects5 = ax.bar(ind+width,rmse_data[2,4,:,2], width, color='b', alpha=.9)
190/104: rects6 = ax.bar(ind+2*width,rmse_data[2,5,:,2], width, color='b', alpha=1)
190/105: ax.set_ylabel('RMSE')
190/106: ax.set_title('RMSE for Different TV and XFM Combinations')
190/107: ax.set_xticks(ind+4*width)
190/108: ax.set_xticklabels(('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'))
190/109: ax.set_xlabel('XFMWeights')
190/110: ax.legend((rects1[0], rects2[0], rects3[0], rects4[0], rects5[0], rects6[0]),('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'),title='TVWeights')
190/111: plt.show()
190/112: N = len(XFMWeight)
190/113: ind = np.arange(N)
190/114: width =0.2
190/115: # TV and XFM Comparison
190/116: fig, ax = plt.subplots()
190/117: rects1 = ax.bar(ind,rmse_data[2,0,:,2], width, color='r', alpha=.1)
190/118: rects2 = ax.bar(ind-2*width,rmse_data[2,1,:,2], width, color='b', alpha=.3)
190/119: rects3 = ax.bar(ind-width,rmse_data[2,2,:,2], width, color='b', alpha=.5)
190/120: rects4 = ax.bar(ind,rmse_data[2,3,:,2], width, color='b', alpha=.7)
190/121: rects5 = ax.bar(ind+width,rmse_data[2,4,:,2], width, color='b', alpha=.9)
190/122: rects6 = ax.bar(ind+2*width,rmse_data[2,5,:,2], width, color='b', alpha=1)
190/123: ax.set_ylabel('RMSE')
190/124: ax.set_title('RMSE for Different TV and XFM Combinations')
190/125: ax.set_xticks(ind+2*width)
190/126: ax.set_xticklabels(('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'))
190/127: ax.set_xlabel('XFMWeights')
190/128: ax.legend((rects1[0], rects2[0], rects3[0], rects4[0], rects5[0], rects6[0]),('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'),title='TVWeights')
190/129: plt.show()
190/130: TVWeight = [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05]
190/131: XFMWeight = [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05]
190/132: imdcs = ['zeros','ones','densCorr','imFull']
190/133: N = len(XFMWeight)
190/134: ind = np.arange(N)
190/135: width =0.2
190/136: # TV and XFM Comparison
190/137: fig, ax = plt.subplots()
190/138: rects1 = ax.bar(ind,rmse_data[2,0,:,2], width, color='r', alpha=.1)
190/139: rects2 = ax.bar(ind-2*width,rmse_data[2,1,:,2], width, color='b', alpha=.3)
190/140: rects3 = ax.bar(ind-width,rmse_data[2,2,:,2], width, color='b', alpha=.5)
190/141: rects4 = ax.bar(ind,rmse_data[2,3,:,2], width, color='b', alpha=.7)
190/142: rects5 = ax.bar(ind+width,rmse_data[2,4,:,2], width, color='b', alpha=.9)
190/143: rects6 = ax.bar(ind+2*width,rmse_data[2,5,:,2], width, color='b', alpha=1)
190/144: ax.set_ylabel('RMSE')
190/145: ax.set_title('RMSE for Different TV and XFM Combinations')
190/146: ax.set_xticks(ind)
190/147: ax.set_xticklabels(('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'))
190/148: ax.set_xlabel('XFMWeights')
190/149: ax.legend((rects1[0], rects2[0], rects3[0], rects4[0], rects5[0], rects6[0]),('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'),title='TVWeights')
190/150: plt.show()
190/151: pctg = [0.20, 0.25, 0.33, 0.40, 0.50]
190/152: TVWeight = [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05]
190/153: XFMWeight = [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05]
190/154: imdcs = ['zeros','ones','densCorr','imFull']
190/155: N = len(XFMWeight)
190/156: ind = np.arange(N)
190/157: width =0.2
190/158: # TV and XFM Comparison
190/159: fig, ax = plt.subplots()
190/160: rects1 = ax.bar(ind-2.5*width,rmse_data[2,0,:,2], width, color='r', alpha=.1)
190/161: rects2 = ax.bar(ind-1.5*width*width,rmse_data[2,1,:,2], width, color='b', alpha=.3)
190/162: rects3 = ax.bar(ind-0.5*width,rmse_data[2,2,:,2], width, color='b', alpha=.5)
190/163: rects4 = ax.bar(ind+0.5*width,rmse_data[2,3,:,2], width, color='b', alpha=.7)
190/164: rects5 = ax.bar(ind+1.5width,rmse_data[2,4,:,2], width, color='b', alpha=.9)
190/165: rects6 = ax.bar(ind+2.5*width,rmse_data[2,5,:,2], width, color='b', alpha=1)
190/166: ax.set_ylabel('RMSE')
190/167: ax.set_title('RMSE for Different TV and XFM Combinations')
190/168: ax.set_xticks(ind+2.5*width)
190/169: ax.set_xticklabels(('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'))
190/170: ax.set_xlabel('XFMWeights')
190/171: ax.legend((rects1[0], rects2[0], rects3[0], rects4[0], rects5[0], rects6[0]),('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'),title='TVWeights')
190/172: plt.show()
190/173: ind = np.arange(N)
190/174: width =0.2
190/175: # TV and XFM Comparison
190/176: fig, ax = plt.subplots()
190/177: rects1 = ax.bar(ind-2.5*width,rmse_data[2,0,:,2], width, color='r', alpha=.1)
190/178: rects2 = ax.bar(ind-1.5*width*width,rmse_data[2,1,:,2], width, color='b', alpha=.3)
190/179: rects3 = ax.bar(ind-0.5*width,rmse_data[2,2,:,2], width, color='b', alpha=.5)
190/180: rects4 = ax.bar(ind+0.5*width,rmse_data[2,3,:,2], width, color='b', alpha=.7)
190/181: rects5 = ax.bar(ind+1.5width,rmse_data[2,4,:,2], width, color='b', alpha=.9)
190/182: rects6 = ax.bar(ind+2.5*width,rmse_data[2,5,:,2], width, color='b', alpha=1)
190/183: ax.set_ylabel('RMSE')
190/184: ax.set_title('RMSE for Different TV and XFM Combinations')
190/185: ax.set_xticks(ind+width)
190/186: ax.set_xticklabels(('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'))
190/187: ax.set_xlabel('XFMWeights')
190/188: ax.legend((rects1[0], rects2[0], rects3[0], rects4[0], rects5[0], rects6[0]),('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'),title='TVWeights')
190/189: plt.show()
190/190: pctg = [0.20, 0.25, 0.33, 0.40, 0.50]
190/191: TVWeight = [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05]
190/192: XFMWeight = [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05]
190/193: imdcs = ['zeros','ones','densCorr','imFull']
190/194: N = len(XFMWeight)
190/195: ind = np.arange(N)
190/196: width =0.2
190/197: # TV and XFM Comparison
190/198: fig, ax = plt.subplots()
190/199: rects1 = ax.bar(ind-2*width,rmse_data[2,0,:,2], width, color='r', alpha=.1)
190/200: rects2 = ax.bar(ind-1*width*width,rmse_data[2,1,:,2], width, color='b', alpha=.3)
190/201: rects3 = ax.bar(ind-0*width,rmse_data[2,2,:,2], width, color='b', alpha=.5)
190/202: rects4 = ax.bar(ind+0.5*width,rmse_data[2,3,:,2], width, color='b', alpha=.7)
190/203: rects5 = ax.bar(ind+1.5width,rmse_data[2,4,:,2], width, color='b', alpha=.9)
190/204: rects6 = ax.bar(ind+2.5*width,rmse_data[2,5,:,2], width, color='b', alpha=1)
190/205: ax.set_ylabel('RMSE')
190/206: ax.set_title('RMSE for Different TV and XFM Combinations')
190/207: ax.set_xticks(ind+width)
190/208: ax.set_xticklabels(('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'))
190/209: ax.set_xlabel('XFMWeights')
190/210: ax.legend((rects1[0], rects2[0], rects3[0], rects4[0], rects5[0], rects6[0]),('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'),title='TVWeights')
190/211: plt.show()
190/212: %paste
190/213: %paste
190/214: plt.show()
190/215: %paste
190/216: plt.show()
190/217: %paste
190/218: plt.show()
191/1: %paste
191/2: %paste
191/3: plt.show()
191/4: %paste
191/5: plt.show()
191/6: %paste
191/7: plt.show()
191/8: ind
191/9: width
191/10: 2.5*width
191/11: %paste
191/12: rects1
191/13: rects1[0]
191/14: rects1[1]
191/15: rects1[0][:]
191/16: rects1.index
191/17: rects1.index()
191/18: plt.show()
191/19: %paste
191/20: plt.show()
191/21: %paste
191/22: plt.show()
191/23: %paste
191/24: plt.show()
191/25: ind
191/26: ind+width
191/27: ind+4*width
191/28: %paste
191/29: plt.show()
191/30: %paste
191/31: plt.show()
191/32: %paste
191/33: plt.show()
191/34: pctg = [0.20, 0.25, 0.33, 0.40, 0.50]
191/35: TVWeight = [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05]
191/36: XFMWeight = [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05]
191/37: imdcs = ['zeros','ones','densCorr','imFull']
191/38: N = len(XFMWeight)
191/39: ind = np.arange(N)
191/40: width =0.15
191/41: # TV and XFM Comparison
191/42: fig, ax = plt.subplots()
191/43: rects1 = ax.bar(ind - 2.5*width, rmse_data[2,0,:,2], width, color='r', alpha=.1)
191/44: rects2 = ax.bar(ind - 1.5*width, rmse_data[2,1,:,2], width, color='r', alpha=.3)
191/45: rects3 = ax.bar(ind - 0.5*width, rmse_data[2,2,:,2], width, color='m', alpha=.5)
191/46: rects4 = ax.bar(ind + 0.5*width, rmse_data[2,3,:,2], width, color='m', alpha=.7)
191/47: rects5 = ax.bar(ind + 1.5*width, rmse_data[2,4,:,2], width, color='b', alpha=.8)
191/48: rects6 = ax.bar(ind + 2.5*width, rmse_data[2,5,:,2], width, color='b', alpha=1)
191/49: ax.set_ylabel('RMSE')
191/50: ax.set_title('RMSE for Different TV and XFM Combinations')
191/51: ax.set_xticks(ind)
191/52: ax.set_xticklabels(('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'))
191/53: ax.set_xlabel('XFMWeights')
191/54: ax.legend((rects1[0], rects2[0], rects3[0], rects4[0], rects5[0], rects6[0]),('0.0001', '0.0005', '0.001', '0.005', '0.01', '0.05'),title='TVWeights')
191/55: plt.show()
191/56: %paste
191/57: plt.show()
191/58: %paste
191/59: plt.show()
191/60: %paste
191/61: plt.show()
191/62: %paste
191/63: plt.show()
191/64: %paste
191/65: plt.show()
191/66: %paste
191/67: plt.show()
191/68: %paste
191/69: plt.show()
191/70: %paste
191/71: %paste
191/72: plt.show()
191/73: %paste
191/74: %paste
191/75: plt.show()
191/76: %paste
191/77: %paste
191/78: plt.close()
191/79: %paste
191/80: plt.show()
191/81: %paste
191/82: plt.show()
191/83: %paste
191/84: plt.show()
191/85: %paste
191/86: plt.show()
191/87: %paste
191/88: plt.show()
191/89: import saveFig
191/90: import source/saveFig
191/91: import './source/saveFig.py'
191/92: import ./source/saveFig.py
191/93: syspath.append("/home/asalerno/pyDirectionCompSense/source/")
191/94: syspath
191/95: import saveFig
191/96: cd source
191/97: import saveFig
191/98: cd ../
191/99: %paste
191/100: %paste
191/101: f, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, sharex='col', sharey='row')
191/102: f, ((ax1, ax2, ax3), (ax4, ax5, ax6)) = plt.subplots(2, 3, sharex='col', sharey='row')
191/103: %paste
191/104: N = im.shape
191/105: minval = np.min(im)
191/106: maxval = np.max(im)
191/107: ax1.imshow(im, clim=(minval,maxval))
191/108: ax1.title('Original Image')
191/109: ax2.imshow(imgsData[pc,TV,XFM,0,:,:],clim=(minval,maxval))
191/110: ax2.title('Recon %.2f%% samp imdc=zeros' % pctg*100)
191/111: ax3.imshow(imgsData[pc,TV,XFM,1,:,:],clim=(minval,maxval))
191/112: ax3.title('Recon %.2f%% samp imdc=ones' % pctg*100)
191/113: ax4.imshow(im_lr,clim=(minval,maxval))
191/114: ax4.title('Low Res with %.2f%% of Data' % pctg*100)
191/115: ax5.imshow(imgsData[pc,TV,XFM,2,:,:],clim=(minval,maxval))
191/116: ax5.title('Recon %.2f%% samp imdc=densCorr' % pctg*100)
191/117: ax6.imshow(imgsData[pc,TV,XFM,3,:,:],clim=(minval,maxval))
191/118: ax6.title('Recon %.2f%% samp imdc=imFull' % pctg*100)
191/119: pctg
191/120: pctg=.2
191/121: pc=0
191/122: ax1.imshow(im, clim=(minval,maxval))
191/123: ax1.title('Original Image')
191/124: ax2.imshow(imgsData[pc,TV,XFM,0,:,:],clim=[minval,maxval])
191/125: ax2.title('Recon %.2f%% samp imdc=zeros' % pctg*100)
191/126: ax3.imshow(imgsData[pc,TV,XFM,1,:,:],clim=(minval,maxval))
191/127: ax3.title('Recon %.2f%% samp imdc=ones' % pctg*100)
191/128: ax4.imshow(im_lr,clim=(minval,maxval))
191/129: ax4.title('Low Res with %.2f%% of Data' % pctg*100)
191/130: ax5.imshow(imgsData[pc,TV,XFM,2,:,:],clim=(minval,maxval))
191/131: ax5.title('Recon %.2f%% samp imdc=densCorr' % pctg*100)
191/132: ax6.imshow(imgsData[pc,TV,XFM,3,:,:],clim=(minval,maxval))
191/133: ax6.title('Recon %.2f%% samp imdc=imFull' % pctg*100)
191/134: pctg
191/135: pctg*100
191/136: plt.close()
191/137: plt.show()
191/138: %paste
191/139: %paste
191/140: %paste
192/1: syspath
192/2: import sys
192/3: sys.syspath
192/4: from sys import path as syspath
192/5: syspath
192/6: syspath.append("/home/asalerno/pyDirectionCompSense/source/")
192/7: import errcalc
191/141: import transforms as tf
191/142: syspath
191/143: syspath.append("/home/asalerno/Documents/pyDirectionCompSense/source/")
191/144: import transforms as tf
191/145: lrLoc = int(np.ceil((N[0]-np.ceil(N[0]/np.sqrt(1/pctg)))/2))
191/146: im_lr = tf.fft2c(np.fft.fftshift(np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]),np.ones(im[lrLoc:-lrLoc,lrLoc:-lrLoc].shape))
191/147: plt.close(all)
191/148: plt.close('all)
191/149: plt.close('all')
191/150: %paste
191/151: f, ((ax1, ax2, ax3), (ax4, ax5, ax6)) = plt.subplots(2, 3, sharex='col', sharey='row')
191/152: ax1.imshow(im, clim=(minval,maxval))
191/153: ax1.set_title('Original Image')
191/154: ax2.imshow(imgsData[pc,TV,XFM,0,:,:],clim=[minval,maxval])
191/155: ax2.set_title('Recon %.2f%% samp imdc=zeros' % pctg*100)
191/156: ax3.imshow(imgsData[pc,TV,XFM,1,:,:],clim=(minval,maxval))
191/157: ax3.set_title('Recon %.2f%% samp imdc=ones' % pctg*100)
191/158: ax4.imshow(im_lr,clim=(minval,maxval))
191/159: ax4.set_title('Low Res with %.2f%% of Data' % pctg*100)
191/160: ax5.imshow(imgsData[pc,TV,XFM,2,:,:],clim=(minval,maxval))
191/161: ax5.set_title('Recon %.2f%% samp imdc=densCorr' % pctg*100)
191/162: ax6.imshow(imgsData[pc,TV,XFM,3,:,:],clim=(minval,maxval))
191/163: ax6.set_title('Recon %.2f%% samp imdc=imFull' % pctg*100)
191/164: plt.close('all')
191/165: %paste
191/166: plt.show()
191/167: %paste
191/168: plt.show()
191/169: %paste
191/170: plt.imshow(im,clim=(minval,maxval))
191/171: plt.show()
191/172: fig = plt.figure()
191/173: ax1 = fig.add_subplot(2,3,1)
191/174: plt.imshow(im, clim=(minval,maxval))
191/175: plt.show()
191/176: plt.rcParams['image.cmap'] = 'gray'
191/177: plt.show()
191/178: %paste
191/179: plt.show()
191/180: pc
191/181: TV
191/182: XFM
191/183: %paste
193/1: %paste
193/2: %paste
193/3: %paste
193/4: %paste
193/5: %paste
193/6: plt.show()
193/7: %paste
193/8: plt.show()
193/9: %paste
193/10: %paste
193/11: %paste
193/12: plt.imshow()
193/13: plt.show()
193/14: %paste
193/15: plt.show()
193/16: %paste
193/17: %paste
193/18: %paste
193/19: plt.show()
194/1: %paste
193/20: im
194/2: im = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/fullySampledBrain.npy')
194/3: %paste
194/4: %paste
194/5: plt.imshow(im)
194/6: plt.show()
194/7: im_dc = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/0.25per_result_im_dc_densCorr.npy')
195/1: im = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/fullySampledBrain.npy')
195/2: %paste
195/3: %paste
195/4: %paste
195/5: from recon_CS import *
195/6: %paste
195/7: %paste
195/8: plt.imshow(im_res)
195/9: plt.show()
195/10: plt.imshow(im_res)
195/11: plt.figure()
195/12: plt.imshow(im)
195/13: plt.show()
195/14: %paste
195/15: %paste
195/16: lrLoc = int(np.ceil((N[0]-np.ceil(N[0]/np.sqrt(1/pctg)))/2))
195/17: im_lr_rs = tf.fft2c(zpad(np.fft.fftshift(np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]),im.shape),np.ones(im.shape))
195/18: im_lr_rs = tf.fft2c(zpad(np.fft.fftshift(np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]),256),np.ones(im.shape))
196/1: %paste
196/2: %paste
196/3: %paste
196/4: lrLoc = int(np.ceil((N[0]-np.ceil(N[0]/np.sqrt(1/pctg)))/2))
196/5: im_lr_rs = tf.fft2c(zpad(np.fft.fftshift(np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]),im),np.ones(im.shape))
196/6: N = im.shape
196/7: im_lr_rs = tf.fft2c(zpad(np.fft.fftshift(np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]),im),np.ones(im.shape))
196/8: lrLoc = int(np.ceil((N[0]-np.ceil(N[0]/np.sqrt(1/pctg)))/2))
196/9: im_lr_rs = tf.fft2c(zpad(np.fft.fftshift(np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]),im),np.ones(im.shape))
196/10: test = np.fft.fftshift(np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc])
196/11: test
196/12: test.shape
196/13: zpad(test,im)
196/14: zpad(test,im.shape)
196/15: 256-208
196/16: 48/2
196/17: zpad(test,im.shape)
196/18: res_sz = im.shape
196/19: orig_data = test
196/20: res_sz = np.array(res_sz)
196/21: orig_sz = np.array(orig_data.shape)
196/22: padval = np.ceil((res_sz-orig_sz)/2)
196/23: padval
196/24: res_sz
196/25: orig_sz
196/26: 294-208
196/27: padval[0]
196/28:
def zpad(orig_data,res_sz):
        res_sz = np.array(res_sz)
        orig_sz = np.array(orig_data.shape)
        padval = int(np.ceil((res_sz-orig_sz)/2))
        res = np.pad(orig_data,([padval[0],padval[0]],[padval[1],padval[1]]),mode='constant')
        return res
196/29: zpad(test,im.shape)
196/30: %paste
196/31: %paste
196/32: %paste
196/33: zpad(test,im.shape)
196/34: test2 = zpad(test,im.shape)
196/35: plt.imshow(abs(test2))
196/36: plt.show()
196/37: plt.imshow(abs(test))
196/38: plt.show()
196/39: test
196/40: test = np.fft.fftshift(test)
196/41: test2 = zpad(test,im.shape)
196/42: plt.imshow(abs(test2))
196/43: plt.show()
196/44: data_lr_rs = np.fft.fftshift(test2)
196/45: a = tf.ifft2c(im,np.ones(im.shape))[lrLoc:-lrLoc,lrLoc:-lrLoc])
196/46: a = tf.ifft2c(im,np.ones(im.shape))[lrLoc:-lrLoc,lrLoc:-lrLoc]
196/47: plt.imshow(abs(a))
196/48: plt.show()
196/49: a = np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape))[lrLoc:-lrLoc,lrLoc:-lrLoc])
196/50: test == a
196/51: a
196/52: test
196/53: test = np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]
196/54: test == a
196/55: a = np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]
196/56: a
196/57: plt.imshow(a)
196/58: a = np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]
196/59: plt.imshow(abs(a))
196/60: plt.show()
196/61: a = np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]
196/62: data_lr_us = np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]
196/63: data_lr_rs = zpad(data_lr_us,im.shape)
196/64: data_lr_rs
196/65: data_lr_rs = zpad(data_lr_us,im.shape)
196/66: im_lr_rs = tf.fft2c(np.fft.fftshift(data_lr_rs),np.ones(im.shape))
196/67: plt.imshow(abs(im_lr_rs))
196/68: plt.show()
196/69: np.finfo(float).eps
196/70: eps = np.finfo(float).eps
196/71: eps
196/72: data_lr_rs += eps
196/73:
plt.imshow(np.log10(abs(data_lr_rs))
)
196/74: plt.imshow()
196/75: plt.show()
196/76: pctg
196/77: pctg = 0.25
196/78: %paste
196/79: plt.imshow(abs(im_lr_rs))
196/80: plt.show()
196/81: rmse_lr = err.rmse(im_lr,im)
196/82: import errorcalc as err
196/83: rmse_lr = err.rmse(im_lr,im)
196/84: rmse_lr = err.rmse(im_lr_rs,im)
196/85: %paste
196/86: %paste
196/87: pctg = [0.20, 0.25, 0.33, 0.40, 0.50]
196/88:
for i in len(pctg):
        lrLoc = int(np.ceil((N[0]-np.ceil(N[0]/np.sqrt(1/pctg[i])))/2))
        data_lr_us = np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]
        data_lr_rs = zpad(data_lr_us,im.shape)
        im_lr_rs = tf.fft2c(np.fft.fftshift(data_lr_rs),np.ones(im.shape))
        rmse_lr[i] = err.rmse(im_lr_rs,im)
196/89: i
196/90: pctg
196/91:
for i in len(pctg):
        lrLoc = int(np.ceil((N[0]-np.ceil(N[0]/np.sqrt(1/pctg[i])))/2))
        data_lr_us = np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]
        data_lr_rs = zpad(data_lr_us,im.shape)
        im_lr_rs = tf.fft2c(np.fft.fftshift(data_lr_rs),np.ones(im.shape))
        rmse_lr[i] = err.rmse(im_lr_rs,im)
196/92:
for i in range(len(pctg)):
        lrLoc = int(np.ceil((N[0]-np.ceil(N[0]/np.sqrt(1/pctg[i])))/2))
        data_lr_us = np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]
        data_lr_rs = zpad(data_lr_us,im.shape)
        im_lr_rs = tf.fft2c(np.fft.fftshift(data_lr_rs),np.ones(im.shape))
        rmse_lr[i] = err.rmse(im_lr_rs,im)
196/93:
for i in range(len(pctg)):
        lrLoc = int(np.ceil((N[0]-np.ceil(N[0]/np.sqrt(1/pctg[i])))/2))
        data_lr_us = np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]
        data_lr_rs = zpad(data_lr_us,im.shape)
        im_lr_rs = tf.fft2c(np.fft.fftshift(data_lr_rs),np.ones(im.shape))
        rmse_lr[i] = err.rmse(abs(im_lr_rs),im)
196/94: im_lr_rs.dtype
196/95: abs(im_lr_rs).dtype
196/96: a = abs(im_lr_rs)
196/97: err.rmse(a,im)
196/98: err.rmse(abs(im_lr_rs),im)
196/99:
for i in range(len(pctg)):
        lrLoc = int(np.ceil((N[0]-np.ceil(N[0]/np.sqrt(1/pctg[i])))/2))
        data_lr_us = np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]
        data_lr_rs = zpad(data_lr_us,im.shape)
        im_lr_rs = tf.fft2c(np.fft.fftshift(data_lr_rs),np.ones(im.shape))
        rmse_lr[i] = err.rmse(abs(im_lr_rs),im)
196/100: plt.imshow(abs(im_lr_rs))
196/101: plt.show()
196/102:
for i in range(len(pctg)):
        lrLoc = int(np.ceil((N[0]-np.ceil(N[0]/np.sqrt(1/pctg[i])))/2))
        data_lr_us = np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]
        data_lr_rs = zpad(data_lr_us,im.shape)
        im_lr_rs = abs(tf.fft2c(np.fft.fftshift(data_lr_rs),np.ones(im.shape)))
        rmse_lr[i] = err.rmse(abs(im_lr_rs),im)
196/103: im_lr_rs.dtype
196/104: im.dtype
196/105: %paste
196/106: %paste
196/107: plt.show()
196/108: pctg = 0.25
196/109:  lrLoc = int(np.ceil((N[0]-np.ceil(N[0]/np.sqrt(1/pctg[i])))/2))
196/110:     data_lr_us = np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]
196/111:     data_lr_rs = zpad(data_lr_us,im.shape)
196/112:     im_lr_rs = abs(tf.fft2c(np.fft.fftshift(data_lr_rs),np.ones(im.shape)))
196/113:     rmse_lr[i] = err.rmse(abs(im_lr_rs),im)
196/114: %paste
196/115: %paste
196/116: %paste
196/117: N
196/118: N=im.shape
196/119: %paste
196/120: im_lr_rs
196/121: x = np.arange(N[0])
196/122: plt.imshow(im[10:40,:])
196/123: plt.show()
196/124: plt.imshow(im[10:200,:])
196/125: plt.show()
196/126: im_res = imgsData[1,3,3,2,:,:]
196/127: plt.plot(x,im[147,:],x,im_res[147,:],x,im_lr_rs[147,:])
196/128: plt.legend(('Image','Dens Corr','Lo Res'))
196/129: plt.show()
196/130: plt.imshow(im-im_lr_rs)
196/131: plt.figure
196/132: plt.imshow(im-im_res)
196/133: plt.show()
196/134: plt.imshow(im-im_lr_rs)
196/135: plt.figure()
196/136: plt.imshow(im-im_res)
196/137: plt.show()
196/138: plt.imshow(im-im_lr_rs)
196/139: np.min(im-im_lr_rs)
196/140: minval = np.min(im-im_lr_rs)
196/141: maxval = np.max(im-im_lr_rs)
196/142: minval
196/143: maxval
196/144: np.min(im-im_dc)
196/145: np.min(im-im_res)
196/146: np.max(im-im_res)
196/147: plt.figure()
196/148: plt.imshow(im-im_res,clim=(minval,maxval))
196/149: plt.show()
196/150: import samp
196/151: import sampling
196/152: pdf = samp.genPDF(N, 0, pctg, radius=radius, cyl=[0])
196/153: import sampling as samp
196/154: pdf = samp.genPDF(N, 0, pctg, radius=radius, cyl=[0])
196/155: pdf = samp.genPDF(N, 0, pctg, radius=0.1, cyl=[0])
196/156: reload(samp)
196/157: pdf = samp.genPDF(N, 0, pctg, radius=0.1, cyl=[0])
196/158: import scipy as sp
196/159: import scipy.ndimage as sp.ndimage
196/160: import scipy.ndimage as ndimage
196/161: reload(samp)
196/162: pdf = samp.genPDF(N, 0, pctg, radius=0.1, cyl=[0])
196/163: pdf
196/164: reload(samp)
196/165: pdf = samp.genPDF(N, 0, pctg, radius=0.1, cyl=[0])
196/166: pdf
196/167: plt.imshow(pdf)
196/168: plt.show()
196/169: plt.imshow(pdf,clim=(0,1))
196/170: plt.show()
196/171: k = samp.genSampling(pdf, 50, 2)[0].astype(int)
196/172: plt.imshow(k)
196/173: plt.show()
196/174: pctg
196/175: np.sum(k)/k.size
196/176: sum(k)
196/177: np.sum(k)
196/178: np.sum(k)/k.size.0
196/179: from _
196/180: from __future__ import division
196/181: np.sum(k)/k.size.0
196/182: np.sum(k)/k.size
197/1: %paste
197/2: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
197/3: TVWeight = 0.005
197/4: XFMWeight = 0.005
197/5: %paste
197/6: imdcs='densCorr'
197/7: plt.title("Reconstructed Image with %.2f%% Sampling and im_dc==" % pctg + imdcs)
197/8: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV%.2f_XFM%.2f/%.2fper_result_uniform_im_dc_" % (TVWeight, XFMWeight, pctg) + imdcs)
197/9: np.save('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/fullySampledBrain.npy',im)
197/10: np.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV%s_XFM%s/%.2fper_result_uniformUS_im_dc_" % (float('%.1g' % TVWeight), float('%.1g' % XFMWeight) , pctg) + imdcs + ".npy",im_res)
197/11: plt.imshow(im_res)
197/12: plt.show()
193/21: im = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/fullySampledBrain.npy')
196/183: d
193/22: d
193/23: import direction as d
193/24: reload(d)
193/25: reload(samp)
193/26: import sampling as samp
193/27: k
193/28: k = samp.genSamplingDir()
198/1: %paste
198/2: reload(samp)
198/3: k = samp.genSamplingDir()
198/4: k
198/5: k.shape
198/6: plt.imshow(k[0,:,:])
198/7: plt.show()
198/8: a = []
198/9: a = [0]
198/10:
if a:
    print('l')
198/11:
if a[0]:
    print('l')
198/12: np.sum(k)
198/13: np.sum(k)/k.size
198/14: [x,y] = np.meshgrid(np.linspace(-1,1,256),np.linspace(-1,1,256))
198/15: r = x**2+y**2
198/16: np.sum(r<=1)
198/17: np.sum(k)/(np.sum(r<=1)*30)
198/18: np.save('/home/asalerno/Documents/pyDirectionCompSense/directionData/30dirSampling.npy',k)
198/19: mkdir('/home/asalerno/Documents/pyDirectionCompSense/directionData')
198/20: mkdir('/home/asalerno/Documents/pyDirectionCompSense/directionData/')
198/21: mkdir /home/asalerno/Documents/pyDirectionCompSense/directionData/
198/22: np.save('/home/asalerno/Documents/pyDirectionCompSense/directionData/30dirSampling.npy',k)
199/1: import scipy.io.loadmat as lm
199/2: import scipy.io
199/3: test = scipy.io.loadmat('/home/asalerno/Documents/Lustig/sparseMRI_v0.2/brain6-zpad-ksp.mat')
199/4: test.shape
199/5: test
199/6: test.items
199/7: test.items()
199/8: test.viewkeys()
199/9: im = test['im']
199/10: im
199/11: im.shape
199/12: np.rollaxis(im,2)
199/13: import numpy as np
199/14: np.rollaxis(im,2)
199/15: im.shape
199/16: np.rollaxis(im,2).shape
199/17: plt.imshow(abs(im[:,:,1]))
199/18: import matplotlib.pyplot as plt
199/19: plt.imshow(abs(im[:,:,1]))
199/20: plt.show()
199/21: im = np.rollaxis(im,2).shape
199/22: plt.imshow(abs(im[:,:,1]))
199/23: plt.imshow(abs(im[1,:,:]))
199/24: im.shape
199/25: im = test['im']
199/26: im = np.rollaxis(im,2)
199/27: plt.imshow(abs(im[1,:,:]))
199/28: plt.show()
199/29: im = np.rollaxis(im,2,1)
199/30: plt.imshow(abs(im[1,:,:]))
199/31: plt.show()
199/32:
for i in np.arange(30):
    im[i,:,:] = np.flipud(im[i,:,:])
199/33: plt.imshow(abs(im[1,:,:]))
199/34: plt.show()
199/35:
for i in np.arange(30):
    im[i,:,:] = np.fliplr(im[i,:,:])
199/36: plt.imshow(abs(im[1,:,:]))
199/37: plt.show()
199/38: np.save('/home/asalerno/Documents/pyDirectionCompSense/directionData/singleSlice_30dirs.npy',im)
198/23: %paste
198/24: d.calc_Mid_Matrix(dirs,nmins)
198/25: test = d.calc_Mid_Matrix(dirs,nmins)
198/26: test
198/27: test.shape
198/28: test[0].shape
198/29: k
198/30: plt.imshow(k[0,:,:])
198/31: plt.show()
198/32: im = np.load(filename)
198/33: ph = np.zeros(im.shape)
198/34:
for dirCount in range(len(dirs)):
        ph[i,:,:] = tf.matlab_style_gauss2D(im[i,:,:],shape=(5,5));
198/35: im
199/39: im = np.load(filename)
199/40: ph = np.zeros(im.shape)
199/41:
for dirCount in range(len(dirs)):
        ph[i,:,:] = tf.matlab_style_gauss2D(im[i,:,:],shape=(5,5));
199/42: dirFile = '/home/asalerno/Documents/pyDirectionCompSense/GradientVectorMag.txt'
199/43: nmins = 4
199/44: dirs = np.loadtxt(dirFile)
199/45: M, dIM, Ause = d.calc_Mid_Matrix(dirs,nmins)
199/46: import direction as d
199/47: %paste
199/48: im.dtype
199/49: k = samp.genSamplingDir()
199/50: c
199/51: c
199/52: np.save('/home/asalerno/Documents/pyDirectionCompSense/directionData/30dirSampling_5mins.npy',k)
199/53: k = samp.genSamplingDir(img_sz=[180,180],nmins=4)
200/1: %paste
200/2:
for i in range(len(dirs)):
        ph[i,:,:] = tf.matlab_style_gauss2D(im[i,:,:],shape=(5,5))
200/3: data = tf.ifft2c(im[0,:,:],ph[0,:,:])
200/4: plt.imshow(np.log10(abs(data)))
200/5: plt.show()
200/6: k = samp.genSamplingDir(img_sz = [180,180], dirFile = dirFile, pctg = pctg, cyl = [0],                         radius = radius, nmins = nmins, engfile = None)
200/7: import pdb
200/8: pdb.pm()
200/9: k
200/10: k = samp.genSamplingDir(img_sz = [180,180], dirFile = dirFile, pctg = pctg, cyl = [0],                         radius = radius, nmins = nmins, engfile = None)
200/11: reload(samp)
200/12: k = samp.genSamplingDir(img_sz = [180,180], dirFile = dirFile, pctg = pctg, cyl = [0],                         radius = radius, nmins = nmins, engfile = None)
200/13: k
200/14: k.shape
200/15: plt.imshow(k[0,:,:])
200/16: plt.show()
200/17: nmins
200/18: np.save('/home/asalerno/Documents/pyDirectionCompSense/directionData/30dirSampling_5mins.npy',k)
200/19: ls directionData/
200/20: rm directionData/30dirSampling.npy
200/21: N
200/22: N = im.shape
200/23: N
200/24: N[-2:]
200/25: r
200/26: [x,y] = np.meshgrid(np.linspace(-1,1,origDataSize[0]),np.linspace(-1,1,origDataSize[1]))
200/27: [x,y] = np.meshgrid(np.linspace(-1,1,N[1]),np.linspace(-1,1,N[1]))
200/28: x
200/29: y
200/30: r = x**2+y**2
200/31: r
200/32: r = np.sqrt(x**2+y**2)
200/33: r
200/34: x,y = np.where(r>0 and r<1)
200/35: x,y = np.where(r>0)
200/36: x,y = (r>0 and r<1).nonzero()
200/37: x,y = (r>0 & r<1).nonzero()
200/38: x,y = (r>0 & r<1).nonzero()
200/39: x,y = np.where(np.logical_and(r>0,r<1))
200/40: x
200/41: a = [1,2,3]
200/42: a
200/43: a*b
200/44: a*a
200/45: a = np.arange(3)
200/46: a
200/47: a*a
200/48: inner(a,a)
200/49: np.inner(a,a)
200/50: a = np.arange(40)
200/51: np.inner(a,a)
200/52: np.sum(a*a)
200/53: dirs
200/54: N
200/55: N1 = N
200/56: N1 = N[-2:]
200/57: N1
200/58: N1 = np.hstack([1, N1])
200/59: N1
200/60: dp = np.zeros([N[0],N[0])
200/61: dp = np.zeros([N[0],N[0]])
200/62: dirs
200/63: %paste
200/64:
for i in range(N[0]):
        for j in range(N[0]):
                dp[i,j] = abs(np.inner(dirs[i,:],dirs[j,:]))
200/65: dp
200/66: plt.imshow(dp,interpolation='none')
200/67: plt.show()
200/68: test, tinds = np.sort(dp)
200/69: test = np.sort(dp)
200/70: test
200/71: plt.imshow(test,interpolation='none')
200/72: plt.show()
200/73: inds = np.sortargs(dp)
200/74: inds = np.argsort(dp)
200/75: inds
200/76: plt.imshow(dp(inds),interpolation='none')
200/77: plt.imshow(dp[inds],interpolation='none')
200/78: dp[inds]
200/79: np.all(dp[inds] == test)
200/80: np.max(dp[inds] - test)
200/81: a = dp[inds]
200/82: plt.imshow(a,interpolation='none')
200/83: a
200/84: a.shape
200/85: dp.shape
200/86: inds.shape
200/87: a[0,:,:]
200/88: plt.imshow(a[0,:,:],interpolation='none')
200/89: plt.show()
200/90: plt.imshow(a[:,:,0],interpolation='none')
200/91: plt.show()
200/92: plt.imshow(a[:,0,:],interpolation='none')
200/93: plt.show()
200/94: plt.imshow(a[:,2,:],interpolation='none')
200/95: plt.show()
200/96: inds.shape
200/97: inds = np.argsort(dp)
200/98: k
200/99: samp
200/100: reload(d)
200/101: reload(d)
200/102: reload(d)
200/103: data
200/104: data.shape
198/36: data.shape
197/13: data
197/14: data.shape
200/105: im = np.load(filename)
201/1: %paste
201/2: test = d.dir_dataSharing(k,data,dirs,N)
201/3: N = im.shape
201/4: test = d.dir_dataSharing(k,data,dirs,N)
201/5: reload(d)
201/6: test = d.dir_dataSharing(k,data,dirs,N)
201/7: reload(d)
201/8: test = d.dir_dataSharing(k,data,dirs,N)
201/9: import pdb; pdb.pm()
201/10: reload(d)
201/11: test = d.dir_dataSharing(k,data,dirs,N)
201/12: plt.imshow(test[1,:,:])
201/13: plt.figure()
201/14: plt.imshow(data[1,:,:])
201/15: plt.show()
201/16: plt.imshow(im_scan[i,:,:])
201/17: plt.show()
201/18: plt.imshow(im[i,:,:])
201/19: plt.imshow(abs(im[i,:,:]))
201/20: plt.show()
201/21: plt.imshow((im[i,:,:].real))
201/22: plt.show()
201/23: i
201/24: np.fft.fft2(im[0,:,:])
201/25: ha = np.fft.fft2(im[0,:,:])
201/26: plt.imshow(np.log10(abs(ha)))
201/27: plt.show()
201/28: HA = np.fft.ifft2(np.fft.fftshift(ha))
201/29: plt.imshow(HA)
201/30: plt.imshow(HA.real)
201/31: plt.show()
201/32: plt.imshow(HA.real)
201/33: HA = np.fft.ifft2(np.fft.fftshift(np.flipud(np.fliplr(ha))))
201/34: plt.imshow(HA.real)
201/35: plt.show()
201/36: HA = np.fliplr(np.flipud(np.fft.ifft2(np.fft.fftshift(np.flipud(np.fliplr(ha))))))
201/37: plt.imshow(HA.real)
201/38: plt.show()
201/39: HA = np.fliplr(np.flipud(np.fft.ifft2(np.fft.fftshift(np.flipud(np.fliplr(ha))))))
201/40:
for i in range(N[0]):
    im[i,:,:] = np.fliplr(np.flipud(np.fft.ifft2(np.fft.fftshift(np.flipud(np.fliplr(ha))))))
201/41: im = np.load(filename)
201/42:
for i in range(N[0]):
    im[i,:,:] = np.fliplr(np.flipud(np.fft.ifft2(np.fft.fftshift(np.flipud(np.fliplr(np.fft.fft2(im[i,:,:]))))))
    
    )
)
)
/
201/43:
for i in range(N[0]):
    im[i,:,:] = np.fliplr(np.flipud(np.fft.ifft2(np.fft.fftshift(np.flipud(np.fliplr(np.fft.fft2(im[i,:,:]))))))
    
    )
    \
    
    
    /
201/44:
for i in range(N[0]):
    im[i,:,:] = np.fliplr(np.flipud(np.fft.ifft2(np.fft.fftshift(np.flipud(np.fliplr(np.fft.fft2(im[i,:,:]))))))
    
    )
    /
201/45: im
201/46: plt.imshow(im[0,:,:].real)
201/47: plt.show()
201/48: im = im - np.min(im)
201/49: im = im/np.max(im)
201/50: plt.imshow(abs(im[i,:,:]))
201/51: plt.show()
201/52: plt.imshow(abs(im[1,:,:]))
201/53: plt.show()
201/54: plt.imshow(abs(im[0,:,:]))
201/55: plt.show()
201/56: test = tf.fft2c(im[i,:,:], ph=ph[i,:,:])
201/57: plt.imshow(abs(test))
201/58: plt.show()
201/59:
for i in range(len(dirs)):
        ph[i,:,:] = tf.matlab_style_gauss2D(im[i,:,:],shape=(5,5))
201/60: %paste
201/61: test = tf.fft2c(im[i,:,:], ph=ph[i,:,:])
201/62: plt.imshow(abs(test))
201/63: plt.show()
201/64: i
201/65: ph[29,:,:]
201/66: eps = np.finfo('eps')
201/67: eps = np.finfo('eps').eps
201/68: eps = np.finfo(eps).eps
201/69: eps = np.finfo('eps')
201/70: eps = np.finfo.mro
201/71: eps
201/72: eps = np.finfo.mro()
201/73: eps
201/74: eps = np.finfo('eps')
201/75: eps = np.finfo(float).eps
201/76: test += eps
201/77: plt.imshow(np.log10(abs(test)))
201/78: plt.show()
201/79: %paste
201/80: plt.imshow(abs(im_scan[i,:,:]))
201/81: plt.show()
201/82: plt.imshow(abs(im[i,:,:]))
201/83: plt.show()
201/84: plt.imshow(im_scan[i,:,:].real)
201/85: plt.show()
201/86: plt.imshow(k[i,:,:])
201/87: plt.show()
201/88: plt.imshow(np.fft.fftshift(k[i,:,:]))
201/89: plt.show()
201/90: ph.shape
201/91: plt.imshow(ph[i,:,:])
201/92: plt.show()
201/93: plt.imshow(im[i,:,:])
201/94: plt.imshow(im[i,:,:].real)
201/95: import cv2
201/96: im = im[i,:,:]
201/97: filtdata = cv2.GaussianBlur(im.real*1,shape,0) + cv2.GaussianBlur(im.imag*1,shape,sigmaX)*1j
201/98: shape = N
201/99: N
201/100: shape = [256,256]
201/101: filtdata = cv2.GaussianBlur(im.real*1,shape,0) + cv2.GaussianBlur(im.imag*1,shape,sigmaX)*1j
201/102: filtdata = cv2.GaussianBlur(im.real*1,(3,3),0) + cv2.GaussianBlur(im.imag*1,(3,3),sigmaX)*1j
201/103: filtdata = cv2.GaussianBlur(im.real*1,(3,3),0) + cv2.GaussianBlur(im.imag*1,(3,3),0)*1j
201/104: filtdata.dtype
201/105: im.dtype
201/106: ph = np.conj(filtdata)/(abs(filtdata)+EPS)
201/107: im.imag
201/108: im.imag*1
201/109:
for i in range(len(dirs)):
        ph[i,:,:] = tf.matlab_style_gauss2D(im[i,:,:],shape=(5,5))
201/110: im = np.load(filename)
201/111:
for i in range(len(dirs)):
        ph[i,:,:] = tf.matlab_style_gauss2D(im[i,:,:],shape=(5,5))
201/112: ph.shape
201/113: ph = np.zeros(im.shape)*1j
201/114:
for i in range(len(dirs)):
        ph[i,:,:] = tf.matlab_style_gauss2D(im[i,:,:],shape=(5,5))
201/115: %paste
201/116: plt.imshow(im_scan[i,:,:].real)
201/117: plt.show()
201/118:
for i in range(N[0]):
    im[i,:,:] = np.fliplr(np.flipud(np.fft.ifft2(np.fft.fftshift(np.flipud(np.fliplr(np.fft.fft2(im[i,:,:]))))))
    
    )
    /
201/119:
for i in range(len(dirs)):
        ph[i,:,:] = tf.matlab_style_gauss2D(im[i,:,:],shape=(5,5))
201/120: %paste
201/121: plt.imshow(im_scan[i,:,:].real)
201/122: plt.show()
201/123: plt.imshow(im[i,:,:].real)
201/124: plt.show()
201/125: plt.imshow(ph[i,:,:])
201/126: plt.imshow(ph[i,:,:].real)
201/127: plt.show()
201/128: np.save(filename,im)
201/129: plt.imshow(ph[i,:,:].real)
201/130: plt.show()
201/131: plt.imshow(im_scan[i,:,:].real)
201/132: plt.show()
202/1: %paste
202/2: pdf = samp.genPDF(N, P, pctg, radius=radius, cyl=[0])
202/3: pdf = samp.genPDF(N, 2, pctg, radius=radius, cyl=[0])
202/4: pdf = samp.genPDF(N, 3, pctg, radius=radius, cyl=[0])
202/5: pdf = samp.genPDF(N, 2.5, pctg, radius=radius, cyl=[0])
202/6: pdf = samp.genPDF(N, 2.2, pctg, radius=radius, cyl=[0])
202/7: pdf = samp.genPDF(N, 2.1, pctg, radius=radius, cyl=[0])
202/8: pdf = samp.genPDF(N, 2.05, pctg, radius=radius, cyl=[0])
202/9: pdf = samp.genPDF(N, 2.01, pctg, radius=radius, cyl=[0])
202/10: pdf = samp.genPDF(N, 2.03, pctg, radius=radius, cyl=[0])
202/11: %paste
202/12: plt.show()
202/13: plt.imshow(abs(im_res),clim=(minval,maxval))
202/14: plt.title("Reconstructed Image with %.2f%% Sampling and im_dc==" % pctg + imdcs)
202/15: plt.figure()
202/16: plt.imshow(im,clim=(minval,maxval))
202/17: plt.show()
202/18: plt.imshow(abs(im_res),clim=(minval,maxval))
202/19: plt.title("Reconstructed Image with %2f%% Sampling and im_dc==" % (pctg*100) + imdcs)
202/20: plt.show()
202/21: plt.imshow(abs(im_res),clim=(minval,maxval))
202/22: plt.title("Reconstructed Image with %f%% Sampling and im_dc==" % (pctg*100) + imdcs)
202/23: plt.show()
202/24: plt.title("Reconstructed Image with %d%% Sampling and im_dc==" % (pctg*100) + imdcs)
202/25: plt.show()
202/26: #saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/P2_radial_us_" + imdcs)
202/27: plt.imshow(abs(im_res),clim=(minval,maxval))
202/28: plt.title("Reconstructed Image with %d%% Sampling and im_dc==" % (pctg*100) + imdcs)
202/29: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/P2_radial_us_" + imdcs)
202/30: %paste
202/31: im_dc = im_res.copy()
202/32: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.02_XFM_0.02" + imdcs)
202/33: TVWeight = 0.001
202/34: XFMWeight = 0.001
202/35: np.save('brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.02_XFM_0.02.npy',im_res)
202/36: %paste
202/37: np.save('brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.001_XFM_0.001.npy',im_res)
202/38: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.001_XFM_0.001_" + imdcs)
202/39: plt.imshow(abs(im_res),clim=(minval,maxval))
202/40: plt.show()
203/1: %paste
203/2: N = im.shape
203/3: minval = np.min(im)
203/4: maxval = np.max(im)
203/5: pctg = 0.25
203/6: %paste
203/7: fig = plt.figure(figsize=(15,10))
203/8: ax1 = fig.add_subplot(2,3,1)
203/9: plt.imshow(im, clim=(minval,maxval))
203/10: ax1.set_title('Original Image')
203/11: ax2 = fig.add_subplot(2,3,2)
203/12: im_datfull = np.load("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/0.25per_result_im_dc_imFull.npy')
203/13: im_datfull = np.load("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/0.25per_result_im_dc_imFull.npy")
203/14: im_dc = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/0.25per_result_im_dc_densCorr.npy')
203/15: np.save('brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.001_XFM_0.001.npy',im_res)
203/16: %paste
203/17: %paste
203/18: plt.show()
203/19: %paste
203/20: plt.show()
203/21: %paste
203/22: plt.show()
203/23: %paste
203/24: plt.show()
203/25: %paste
203/26: plt.show()
203/27: %paste
203/28: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/dynamicCS")
203/29: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/dynamicCS")
203/30: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/figs/dynamicCS")
204/1: %paste
204/2: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/figs/TV%.2f_XFM%.2f_%.2fper_result_uniform_im_dc_" % (TVWeight, XFMWeight, pctg) + imdcs)
204/3: %paste
204/4: plt.title('Recon Image with 1/R^2.05 PDF')
204/5: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/figs/TV_0.005_XFM0.005_0.25per_result_P_2.05_im_dc_" + imdcs)
200/106: [x,y] = np.meshgrid(np.linspace(-1,1,N[1]),np.linspace(-1,1,N[1]))
200/107: r = np.sqrt(x**2+y**2)
200/108: idx = np.where(r < radius)
200/109: idx
200/110: len(idx)
200/111: idx.shape
200/112: len(idx[0])
201/133: reload(samp)
201/134: pdf = samp.genPDF(N, 1, pctg, radius=0.1, cyl=[0])
201/135: plt.imshow(pdf)
201/136: plt.show()
201/137: N
201/138: pdf = samp.genPDF(N[-2:], 1, pctg, radius=0.1, cyl=[0])
201/139: plt.imshow(pdf)
201/140: plt.show()
201/141: pdf = samp.genPDF(N[-2:], 1, pctg, radius=0.1, cyl=[1, 256, 256])
201/142: plt.imshow(pdf)
201/143: plt.show()
201/144: reload(samp)
201/145: pdf = samp.genPDF(N[-2:], 1, pctg, radius=0.1, cyl=[1, 256, 256])
201/146: reload(samp)
201/147: pdf = samp.genPDF(N[-2:], 1, pctg, radius=0.1, cyl=[1, 256, 256])
201/148: reload(samp)
201/149: pdf = samp.genPDF(N[-2:], 1, pctg, radius=0.1, cyl=[1, 256, 256])
201/150: plt.imshow(pdf)
201/151: plt.show()
201/152: pdf
201/153: pdf = samp.genPDF(N[-2:], 0.5, pctg, radius=0.1, cyl=[1, 256, 256])
201/154: plt.imshow(pdf)
201/155: plt.show()
201/156: P=0.125
201/157: str(P)
205/1: %paste
206/1: %paste
207/1: %paste
207/2: %paste
207/3: saveFig.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/figs/dynamicCS.png")
207/4: pctg = 0.25
207/5: im = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/fullySampledBrain.npy')
207/6: N = im.shape
207/7: minval = np.min(im)
207/8: maxval = np.max(im)
207/9: lrLoc = int(np.ceil((N[0]-np.ceil(N[0]/np.sqrt(1/pctg)))/2))
207/10: im_lr = tf.fft2c(np.fft.fftshift(np.fft.fftshift(tf.ifft2c(im,np.ones(im.shape)))[lrLoc:-lrLoc,lrLoc:-lrLoc]),np.ones(im[lrLoc:-lrLoc,lrLoc:-lrLoc].shape))
207/11: fig = plt.figure(figsize=(15,10))
207/12: # Original Image
207/13: ax1 = fig.add_subplot(2,3,1)
207/14: plt.imshow(im, clim=(minval,maxval))
207/15: ax1.set_title('Original Image')
207/16: # im_full as starting point
207/17: ax2 = fig.add_subplot(2,3,2)
207/18: im_datfull = np.load("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/0.25per_result_im_dc_imFull.npy")
207/19: plt.imshow(abs(im_datfull), clim=(minval,maxval))
207/20: ax2.set_title('One Run Recon im_dc=im')
207/21: # Lo Resolution
207/22: ax3 = fig.add_subplot(2,3,3)
207/23: plt.imshow(abs(im_lr))
207/24: ax3.set_title('LoRes')
207/25: # im_dc after one run -- TV=XFM=0.005
207/26: ax4 = fig.add_subplot(2,3,4)
207/27: im_dc = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/0.25per_result_im_dc_densCorr.npy')
207/28: plt.imshow(abs(im_dc), clim=(minval,maxval))
207/29: ax4.set_title('1 Recon im_dc=DC XFM=TV=0.005')
207/30: # im_dc after two runs -- TV=XFM=0.002
207/31: ax5 = fig.add_subplot(2,3,5)
207/32: im_dc2 = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.02_XFM_0.02.npy')
207/33: plt.imshow(abs(im_dc2), clim=(minval,maxval))
207/34: ax5.set_title('2 Recon im_dc=DC XFM=TV=0.002')
207/35: # im_dc after three runs -- TV=XFM=0.001
207/36: ax6 = fig.add_subplot(2,3,6)
207/37: im_dc3 = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.001_XFM_0.001.npy')
207/38: plt.imshow(abs(im_dc3), clim=(minval,maxval))
207/39: ax6.set_title('3 Recon im_dc=DC XFM=TV=0.001')
207/40: plt.show()
208/1: %paste
206/2: Ps = [0:5:.5]
206/3: Ps = [0::5:.5]
206/4: Ps = [0:5::.5]
206/5: Ps = range(0,5,.5)
206/6: Ps = np.arange(0,5,.5)
206/7: Ps
206/8: Ps = np.arange(0,5.1,.5)
206/9: Ps
209/1: %paste
209/2: plt.rcParams['image.interpolation'] = 'none'
210/1: %paste
210/2: %paste
210/3: fullImData.shape
210/4: fullImData[:,:,1].shape
210/5: np.save('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/fullBrain.npy',fullImData)
210/6: reload(samp)
210/7: pdf = samp.genPDF(N, 3, pctg, radius=radius, cyl=[0])
210/8: N = [294,294]
210/9: pdf = samp.genPDF(N, 3, pctg, radius=radius, cyl=[0])
210/10: pctg = .25
210/11: pdf = samp.genPDF(N, 3, pctg, radius=radius, cyl=[0])
210/12: reload(samp)
210/13: pdf = samp.genPDF(N, 3, pctg, radius=radius, cyl=[0])
210/14: k = samp.genSampling(pdf, 50, 2)[0].astype(int)
210/15: plt.imshow(k)
210/16: plt.show()
210/17: k = samp.genSampling(pdf, 50, 2)[0].astype(int)
210/18: pdf = samp.genPDF(N, 5, pctg, radius=radius, cyl=[0])
210/19: k = samp.genSampling(pdf, 50, 2)[0].astype(int)
210/20: np.save('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/samplingScheme.npy',k)
210/21: im = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/fullBrain.npy')
210/22: im
210/23: im.shape
210/24: im = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/fullBrain.npy')[:,:,190]
210/25: im.shape
211/1: import optimize
211/2: optimize.__version__
211/3: optimize
211/4: import scipy
211/5: scipy
211/6: scipy.__version__
211/7: import matplotlib
211/8: matplotlib.__version__
211/9: matplotlib.__version__numpy__
211/10: import numpy
211/11: numpy
211/12: numpy.__version__
212/1: %paste
212/2: im = np.load('/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/fullBrain.npy')
212/3: im.shape
212/4: %paste
213/1: %paste
213/2: %paste
213/3: %paste
214/1: %paste
214/2: %paste
214/3: %paste
214/4: a = 10.0
215/1: %paste
216/1: %paste
216/2: %paste
217/1: %paste
218/1: %paste
219/1: %paste
219/2: %paste
220/1: %paste
221/1: %paste
221/2: %paste
221/3: %paste
221/4: import py_minc
221/5: py_minc
222/1: %paste
222/2: %paste
222/3: %paste
220/2: im_res.shape
220/3: im_recon.shape
220/4: np.amx(im_recon)
220/5: np.max(im_recon)
220/6: np.max(im_recon[:,:,203])
220/7: np.max(im_recon[:,:,204])
220/8: sliceChoice = 204
220/9: im_testHold = im_recon.copy()
220/10: im = np.load('/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/fullBrain.npy')[:,:,sliceChoice]
220/11: data = np.fft.ifftshift(k) * tf.fft2c(im, ph=ph)
220/12: im_scan = tf.ifft2c(data, ph=ph)
220/13: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
220/14: args = (N, TV1, XFM1, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
220/15:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                        options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 0, 'alpha_0': 0.1, 'c': 0.6, 'xtol': xtol1, 'TVWeight': TV1, 'XFMWeight': XFM1, 'N': N})
220/16:     im_dc = im_result['x'].reshape(N)
220/17: im_dc = im_result['x'].reshape(N)
220/18: args = (N, TV2, XFM2, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
220/19:     im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
220/20:                         options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 0, 'alpha_0': 0.1, 'c': 0.6, 'xtol': xtol2, 'TVWeight': TV2, 'XFMWeight': XFM2, 'N': N})
220/21: args = (N, TV2, XFM2, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
220/22:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                        options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 0, 'alpha_0': 0.1, 'c': 0.6, 'xtol': xtol2, 'TVWeight': TV2, 'XFMWeight': XFM2, 'N': N})
220/23: args = (N, TV3, XFM3, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
220/24: im_dc = im_result['x'].reshape(N)
220/25:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                        options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 0, 'alpha_0': 0.1, 'c': 0.6, 'xtol': xtol3, 'TVWeight': TV3, 'XFMWeight': XFM3, 'N': N})
220/26: im_res = im_result['x'].reshape(N)
220/27: sliceChoice
220/28: np.max(im_recon[:,:,sliceChoice])
220/29: im_recon[:,:,sliceChoice] = im_res
220/30: import pyminc
220/31: from pyminc.volumes.factory import *
220/32: outfile = volumeLikeFile('/hpf/largeprojects/MICe/segan/exercise_irradiation/bruker_data/running_C/P14/20160607_124310_Running_C_1_1/study_data/imgrecon.3.mnc','/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/25per_reconBrain.mnc')
220/33: outfile.data = im_recon
220/34: outfile.writeFile()
220/35: outfile.closeVolume()
220/36: np.max(im_recon)
220/37: np.isnan(im_recon)
220/38: np.where(np.isnan(im_recon))
220/39: im_recon[:,:,204]
220/40: im_dc
220/41: im_scan
220/42: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
220/43: %paste
220/44: im_dc
220/45: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
220/46: %paste
220/47: np.isnan(im_dc)
220/48: np.where(np.isnan(im_dc))
220/49: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
220/50: np.where(np.isnan(im_dc))
220/51: %paste
220/52: np.where(np.isnan(im_dc))
220/53: np.where(np.isnan(im_res))
220/54: im_res.shape
220/55: im_recon[:,:,sliceChoice] = im_res
220/56: np.where(np.isnan(im_recon))
220/57: outfile = volumeLikeFile('/hpf/largeprojects/MICe/segan/exercise_irradiation/bruker_data/running_C/P14/20160607_124310_Running_C_1_1/study_data/imgrecon.3.mnc','/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/25per_reconBrain.mnc')
220/58: outfile.data = im_recon
220/59: outfile.writeFile()
220/60: outfile.closeVolume()
220/61: TV1
220/62: plt.imshow(pdf)
220/63: plt.show()
220/64: xtol1
220/65: xtol2
220/66: xtol3
220/67: xtol1 = 1e-4
220/68: sliceChoice = 190
220/69: im = np.load('/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/fullBrain.npy')[:,:,sliceChoice]
220/70: data = np.fft.ifftshift(k) * tf.fft2c(im, ph=ph)
220/71: %paste
220/72: fig = plt.figure(figsize=(15,10))
220/73: ax = fig.add_subplot(1,2,1)
220/74: plt.imshow(im_dc)
220/75: ax = fig.add_subplot(1,2,2)
220/76: plt.imshow(im_recon[:,:,sliceChoice])
220/77: plt.show()
220/78: fig = plt.figure(figsize=(15,10))
220/79: ax = fig.add_subplot(1,2,1)
220/80: plt.imshow(im_recon[:,:,sliceChoice],interpolation='trilinear')
220/81: plt.imshow(im_recon[:,:,sliceChoice],interpolation='tri')
220/82: plt.imshow(im_recon[:,:,sliceChoice],interpolation='hanning')
220/83: ax = fig.add_subplot(1,2,2)
220/84: plt.imshow(im_dc,interpolation='hanning')
220/85: plt.show()
220/86: a = im_dc-im_recon[:,:,sliceChoice]
220/87: a
220/88: plt.imshow(a)
220/89: plt.show()
220/90: %paste
220/91: a = 10.
220/92: %paste
220/93: plt.imshow(im_res)
220/94: plt.show()
220/95: plt.imshow(im_res,interpolation='hanning')
220/96: plt.imshow(im_res)
220/97: plt.show()
220/98: plt.imshow(im_res)
220/99: plt.show()
220/100: plt.imshow(im_res,clim=(minval,maxval))
220/101: plt.show()
221/6: plt
221/7: plt.rcdefaults['interpolation']
221/8: plt.rcdefaults
221/9: plt.rcdefaults('interpolation')
221/10: plt.rcdefaults()
221/11: plt.rcParamsDefault
220/102: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
220/103: plt.show()
220/104: test = np.load('/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.02_XFM_0.02.npy')
220/105: np.all(test == im_res)
220/106: np.max(test - im_res)
220/107: plt.imshow(test)
220/108: plt.show()
220/109: test1 = np.load('/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.001_XFM_0.001.npy')
220/110: np.all(test1 == im_res)
220/111: np.max(test1 - im_res)
220/112: sliceChoice
220/113: np.max(test - im_dc)
220/114: xtol1 = 1e-4
220/115: %paste
220/116: np.max(test - im_dc)
220/117: np.max(test1 - im_dc)
220/118: xtol1 = 1e-3
220/119: %paste
220/120: np.max(test1 - im_dc)
220/121: np.max(test - im_dc)
220/122: xtol1 = 1e-5
220/123: %paste
220/124: np.max(test - im_dc)
220/125: np.max(test1 - im_dc)
220/126: test = np.load('/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.02_XFM_0.02.npy')
220/127: plt.imshow(test1 - im_dc)
220/128: plt.show()
220/129: plt.imshow(test - im_dc)
220/130: plt.show()
220/131: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
223/1: %paste
223/2: %paste
223/3: %paste
223/4: %paste
223/5: sliceChoice
223/6: sliceChoice = 190
223/7: %paste
223/8: im.shape
223/9: %paste
223/10: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
223/11: args = (N, TV1, XFM1, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
223/12:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                    options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 0, 'alpha_0': 0.1, 'c': 0.6, 'xtol': xtol1, 'TVWeight': TV1, 'XFMWeight': XFM1, 'N': N})
223/13: im_dc = im_result['x'].reshape(N)
223/14: %paste
223/15: a = 10.0
223/16: %paste
223/17: im_dc = im_result['x'].reshape(N)
223/18: test = np.load('/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/0.25per_result_im_dc_densCorr.npy')
223/19: np.all(test == im_dc)
223/20: np.max(test == im_dc)
223/21: np.max(test - im_dc)
223/22: TV1
223/23: TV1 = 0.002
223/24: XFM1 = 0.002
223/25: xtol1
223/26: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
223/27: #----------------#
223/28: #     Step 1     #
223/29: #----------------#
223/30: args = (N, TV1, XFM1, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
223/31:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                    options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 0, 'alpha_0': 0.1, 'c': 0.6, 'xtol': xtol1, 'TVWeight': TV1, 'XFMWeight': XFM1, 'N': N})
223/32: im_dc = im_result['x'].reshape(N)
223/33: np.max(test - im_dc)
223/34: np.max(test1 - im_dc)
223/35: test1 = np.load('/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.001_XFM_0.001.npy')
223/36: np.max(test1 - im_dc)
223/37: TVWeight
223/38: xtol1 = 1e-3
223/39:
im_result = pt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                    options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 0, 'alpha_0': 0.1, 'c': 0.6, 'xtol': xtol1, 'TVWeight': TV1, 'XFMWeight': XFM1, 'N': N})
223/40: TV1
223/41: TV1 = 0.05
223/42: XFM1 = 0.05
223/43: XFM1 = 0.005
223/44: TV1 = 0.005
223/45: args = (N, TV1, XFM1, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
223/46: a
223/47: im
223/48:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                    options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 0, 'alpha_0': 0.1, 'c': 0.6, 'xtol': xtol1, 'TVWeight': TV1, 'XFMWeight': XFM1, 'N': N})
223/49: im_dc = im_result['x'].reshape(N)
223/50: np.max(test1 - im_dc)
223/51: np.max(test - im_dc)
223/52:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                    options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 0, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TV1, 'XFMWeight': XFM1, 'N': N})
223/53: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
223/54:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                    options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 0, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TV1, 'XFMWeight': XFM1, 'N': N})
223/55: im_dc = im_result['x'].reshape(N)
223/56: np.max(test - im_dc)
223/57: np.max(test1 - im_dc)
223/58: TV1
223/59: im
223/60: %paste
223/61: %paste
223/62: im.dtype
223/63: fullImData
223/64: fullImData
223/65: fullImData[:,:,190]
223/66: fullImData[:,:,190] == im
223/67: np.all(fullImData[:,:,190] == im)
223/68: pdf = samp.genPDF(N, P, pctg, radius=radius, cyl=[0])
223/69: k
223/70: k1 = k.copy()
223/71: k = samp.genSampling(pdf, 50, 2)[0].astype(int)
223/72: data = np.fft.ifftshift(k) * tf.fft2c(im, ph=ph)
223/73: np.all(data == data)
223/74: k == k1
223/75: im_scan = tf.ifft2c(data, ph=ph)
223/76: im_res = im_dc
223/77: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
223/78: a = 10.0
223/79: args = (N, TVWeight, XFMWeight, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
223/80: TVWeight = .005
223/81: im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun, options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
223/82: XFMWeight = 0.005
223/83: im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun, options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 5e-3, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
223/84: im_test = im_result['x'].reshape(N)
223/85: im_dc = tf.ifft2c(data / np.fft.ifftshift(pdf), ph=ph).real.flatten().copy()
223/86: np.max(im_test - im_res)
223/87: np.max(im_test - test)
224/1: %paste
224/2: %paste
224/3: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
224/4: import matplotlib.pyplot as plt
224/5: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
224/6: plt.show()
224/7: plt.rcParams['image.cmap'] = 'gray'
224/8: plt.show()
224/9: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
224/10: plt.show()
224/11: test = np.load('/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.001_XFM_0.001.npy')
224/12: fig = plt.figure(figsize=(15,10))
224/13: ax = fig.add_subplot(1,2,1)
224/14: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
224/15: ax = fig.add_subplot(1,2,2)
224/16: plt.imshow(test,clim=(minval,maxval),interpolation='bilinear')
224/17: plt.show()
225/1: test = np.load('/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/0.25per_result_im_dc_densCorr.npy')
225/2: %paste
225/3: %paste
225/4: %paste
225/5: test = np.load('/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/0.25per_result_im_dc_densCorr.npy')
225/6: plt.show()
225/7: plt.imshow(abs(im_res),clim=(minval,maxval),interpolation='bilinear')
225/8: plt.show()
225/9: test-im_res
225/10: plt.imshow(abs(im_res),clim=(minval,maxval),interpolation='bilinear')
225/11: fig = plt.figure(figsize=(15,10))
225/12: ax = fig.add_subplot(1,2,1)
225/13: plt.imshow(abs(im_res),clim=(minval,maxval),interpolation='bilinear')
225/14: ax = fig.add_subplot(1,2,2)
225/15: plt.imshow(abs(test),clim=(minval,maxval),interpolation='bilinear')
225/16: plt.show()
225/17: test = np.load('/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.02_XFM_0.02.npy')
225/18: fig = plt.figure(figsize=(15,10))
225/19: ax = fig.add_subplot(1,2,1)
225/20: plt.imshow(abs(im_res),clim=(minval,maxval),interpolation='bilinear')
225/21: ax = fig.add_subplot(1,2,2)
225/22: plt.imshow(abs(test),clim=(minval,maxval),interpolation='bilinear')
225/23: plt.show()
225/24: im_hold = im_res.copy()
225/25: test = np.load('/hpf/largeprojects/MICe/asalerno/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.02_XFM_0.02.npy')
225/26: im_dc = im_res
225/27: TVWeight = 0.002
225/28: XFMWeight = 0.002
225/29: args = (N, TVWeight, XFMWeight, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
225/30:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                            options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 1e-4, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight,'N': N})
225/31: im_res = im_result['x'].reshape(N)
225/32: fig = plt.figure(figsize=(15,10))
225/33: ax = fig.add_subplot(1,2,1)
225/34: plt.imshow(abs(test),clim=(minval,maxval),interpolation='bilinear')
225/35: ax = fig.add_subplot(1,2,2)
225/36: plt.imshow(abs(im_res),clim=(minval,maxval),interpolation='bilinear')
225/37: plt.show()
225/38: im_dc = im_res
225/39: xtol = 1e-4
225/40:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                            options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 1e-4, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight,'N': N})
225/41: plt.imshow(abs(im_res),clim=(minval,maxval),interpolation='bilinear')
225/42: plt.show()
226/1: %paste
226/2: plt.imshow(im_scan)
226/3: plt.imshow(abs(im_scan))
226/4: plt.show()
226/5: plt.imshow(abs(im_dc).reshape(N))
226/6: plt.show()
226/7:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                            options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 1e-4, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
226/8: im_result['x']
226/9: plt.imshow(abs(im_res).reshape(N))
226/10: plt.show()
226/11: ItnLim = 400
226/12:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                            options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 1e-4, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
226/13: im_res = im_result['x'].reshape(N)
226/14: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
226/15: plt.show()
226/16: np.random.seed(2000)
226/17:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                            options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.05, 'c': 0.6, 'xtol': 1e-4, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
226/18: im_res2 = im_result['x'].reshape(N)
226/19: fig = plt.figure(figsize=(15,10))
226/20: ax = fig.add_subplot(1,2,1)
226/21: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
226/22: ax = fig.add_subplot(1,2,2)
226/23: plt.imshow(im_res2,clim=(minval,maxval),interpolation='bilinear')
226/24: plt.show()
226/25:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                            options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.2, 'c': 0.6, 'xtol': 1e-4, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
226/26: im_result
226/27: im_res3 = im_result['x'].reshape(N)
226/28: plt.imshow(im_res3,clim=(minval,maxval),interpolation='bilinear')
226/29: plt.show()
226/30: %paste
226/31: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
226/32: plt.show()
226/33: im_firstRun = im_res
226/34: im_firstRun = im_res.copy()
226/35: im_dc = im_res
226/36:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                            options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1.6, 'xtol': 1e-4, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
228/1: %paste
229/1: %paste
229/2: im_firstRun = im_res
229/3: im_firstRun = im_res.copy()
229/4: im_dc = im_res.copy()
229/5: TVWeight = 0.002
229/6: XFMWeight = 0.002
229/7: args = (N, TVWeight, XFMWeight, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
229/8:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                            options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': 0.1, 'c': 0.6, 'xtol': 1e-4, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
229/9: im_res = im_result['x'].reshape(N)
229/10: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
229/11: np.min(im_res)
229/12: plt.title("Reconstructed Image with %d%% Sampling and im_dc==" % (pctg*100) + imdcs)
229/13: imdcs = 'densCorr_Completed'
229/14: plt.title("Reconstructed Image with %d%% Sampling and im_dc==" % (pctg*100) + imdcs)
229/15: plt.show()
230/1: %paste
230/2: TVWeight
230/3: %paste
231/1: %paste
231/2: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
231/3: plt.show()
231/4: %paste
231/5: %paste
231/6: np.save("brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/replicate/%.2fper_firstRun_im_dc_" % (pctg*100) + imdcs,im_res)
231/7: im_dc = im_res
231/8: imdcs = 'densCorr_Completed'
231/9: %paste
231/10: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
231/11: plt.show()
231/12: alpha_0 = 0.05
231/13: %paste
231/14: im_res = im_result['x'].reshape(N)
231/15: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
231/16: plt.show()
231/17: im_result['all']
231/18: im_result.keys
231/19: im_result.keys()
232/1: %paste
232/2: im_result.keys
232/3: im_result.keys()
232/4: im_result['alpha_k']
232/5: alpha_0 = im_result['alpha_k']
232/6: TVWeight
232/7: TVWeight = XFMWeight = 0.002
232/8: XFMWeight
232/9: plt.imshow(im_res)
232/10: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
232/11: plt.show()
232/12: im_dc = im_res
232/13: args = (N, TVWeight, XFMWeight, data, k, strtag, ph, dirWeight, dirs, M, nmins, wavelet, mode, a)
232/14: alpha_0
232/15:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                            options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': alpha_0, 'c': 0.6, 'xtol': 1e-4, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
232/16: im_res = im_result['x'].reshape(N)
232/17: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
232/18: plt.show()
232/19:
im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun,
                            options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': alpha_0*0.1, 'c': 0.6, 'xtol': 1e-4, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
232/20: im_res = im_result['x'].reshape(N)
232/21: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
232/22: plt.show()
232/23: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
232/24: plt.show()
233/1: %paste
233/2: im_result['alpha_k']
233/3: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
233/4: plt.show()
233/5: %paste
233/6: im_hold = im_res
233/7: plt.imshow(im_hold)
233/8: plt.show()
233/9: %paste
233/10: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
233/11: plt.show()
233/12: TVWeight = XFMWeight = 0.005
233/13: %paste
233/14: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
233/15: plt.show()
233/16: plt.imshow(k)
233/17: plt.show()
233/18: [x,y] = np.meshgrid(np.linspace([-1,1,256]),np.linspace([-1,1,256]))
233/19: [x,y] = np.meshgrid(np.linspace(-1,1,256),np.linspace(-1,1,256)))
233/20: [x,y] = np.meshgrid(np.linspace(-1,1,256),np.linspace(-1,1,256))
233/21: r = sqrt(x**2+y**2)
233/22: r = np.sqrt(x**2+y**2)
233/23: r
233/24: r[k]
233/25: r[k].shape
233/26: [x,y] = np.meshgrid(np.linspace(-1,1,294),np.linspace(-1,1,294))
233/27: r = np.sqrt(x**2+y**2)
233/28: r[k]
233/29: r[k].shape
233/30: r *= k
233/31: r
233/32: radhist = np.hist(r,20)
233/33: radhist = np.histogram(r,20)
233/34: plt.hist(r)
233/35: plt.show()
233/36: radhist = np.histogram(r.flat(),20)
233/37: radhist = np.histogram(r.flat,20)
233/38: radhist = np.histogram(r.flat,20)
233/39: plt.hist(r.flat)
233/40: plt.show()
233/41: plt.hist(r.flat,bins=100)
233/42: plt.show()
233/43: plt.hist(r.flat,bins=50)
233/44: plt.hist(r.flat,bins=50,ylim=(0,1e3))
233/45: plt.hist(r.flat,bins=50,clim=(0,1e3))
233/46: plt.hist(r.flat,bins=50)
233/47: plt.ylim(0,1e3)
233/48:
plt.show()(
plt.show()
))
233/49: plt.show()
233/50: alpha_0
233/51: alpha_k
233/52: im_result['alpha_k']
233/53: a = plt.hist(r.flat,bins=50,clim=(0,1e3))
233/54: a = plt.hist(r.flat,bins=50)
233/55: a
233/56: a.count
233/57: a.count()
233/58: a.count{1)
233/59: a.count(1)
233/60: a[1]
233/61: a[0]
233/62: plt.show()
233/63: %paste
233/64: %paste
233/65: %paste
233/66: radialHistogram(k)
233/67: import pdb
233/68: pdb.pm()
233/69: pdb.pm()
233/70: pdb.pm()
233/71: %paste
233/72: radialHistogram(k)
234/1: %paste
234/2: rmax = np.sqrt(2)
234/3: bins = 50
234/4: maxxy = (rmax**2)/2
234/5: maxxy
234/6: [x,y] = np.meshgrid(np.linspace(-maxxy,maxxy,k.shape[0]), np.linspace(-maxxy,maxxy,k.shape[1]))
234/7: r = np.sqrt(x**2+y**2)
234/8: r
234/9: r *= k
234/10: r
234/11: cnts = plt.hist(r.flat,bins=bins)
234/12: cnts
234/13: cnts[0]
234/14: a = np.sort(cnts[0])
234/15: a
234/16: a = np.sort(cnts[0])[-2]
234/17: a
234/18: ymax = np.sort(cnts[0])[-2]*1.1
234/19: ymax
234/20: plt.ylim(0,ymax)
234/21: plt.title('Radial Histogram')
234/22: plt.show()
234/23:
def radialHistogram(k,rmax=np.sqrt(2),bins='auto'):
        
        maxxy = (rmax**2)/2
        [x,y] = np.meshgrid(np.linspace(-maxxy,maxxy,k.shape[0]), np.linspace(-maxxy,maxxy,k.shape[1]))
        r = np.sqrt(x**2+y**2)
        r *= k
        cnts = plt.hist(r.flat,bins=bins)
        ymax = np.sort(cnts[0])[-2]*1.1
        plt.ylim(0,ymax)
        plt.title('Radial Histogram')
        plt.xlabel('Radius')
        plt.ylabel('Counts')
        plt.show()
234/24: radialHistogram(k)
234/25: k
234/26: cnts = plt.hist(r.flat,bins=bins)
234/27: bins
234/28: bins='auto'
234/29: cnts = plt.hist(r.flat,bins=bins)
234/30: cnts
234/31: %paste
234/32: radialHistogram(k)
234/33: radialHistogram(k)
234/34: radialHistogram(k)
234/35: radialHistogram(k)
234/36: %paste
234/37: radialHistogram(k)
235/1: %paste
235/2: test = im_dc
235/3: im_dc = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/0.25per_result_im_dc_densCorr.npy')
235/4: test
235/5: test == im_dc
235/6: np.mean(test - im_dc)
235/7: np.median(test - im_dc)
235/8: plt.hist(test - im_dc)
235/9: plt.show()
235/10: plt.hist((test - im_dc).flat)
235/11: plt.show()
235/12: plt.hist((test - im_dc).flat,bins=100)
235/13: plt.show()
235/14: plt.imshow(pdf)
235/15: plt.show()
235/16: TVWeight
235/17: im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun, options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': alpha_0, 'c': 0.6, 'xtol': xtol, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
235/18: im_res = im_result['x'].reshape(N)
235/19: xtol
235/20: plt.imshow(im_res)
235/21: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
235/22: plt.show()
236/1: %paste
236/2: im_hold = np.load('brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/postComps/rerun1_TV_0.02_XFM_0.02.npy')
236/3: plt.imshow(im_hold,clim=(minval,maxval),interpolation='bilinear')
236/4: plt.show()
236/5: fig = plt.figure(figsize=(15,10))
236/6: ax = fig.add_subplot(1,2,1)
236/7: plt.imshow(im_hold,clim=(minval,maxval),interpolation='bilinear')
236/8: plt.title('Old')
236/9: ax = fig.add_subplot(1,2,2)
236/10: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
236/11: plt.title('New')
236/12: plt.show()
236/13: im_dc = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/0.25per_result_im_dc_densCorr.npy')
236/14: xtol
236/15: xtol = 1e-4
236/16: im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun, options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': alpha_0, 'c': 0.6, 'xtol': xtol, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
236/17: np.max(abs(im_result['jac']))
236/18: np.min(abs(im_result['jac']))
236/19: np.mean(abs(im_result['jac']))
236/20: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
236/21: im_res = im_result['x'].reshape(N)
236/22: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
236/23: plt.show()
236/24: %paste
236/25: %paste
236/26: plt.imshow(pdf)
236/27: plt.show()
236/28: plt.plot(pdf[294/2,:])
236/29: plt.show()
236/30: np.sum(pdf)
236/31: .25*294*294
236/32: k
236/33: np.sum(k)
236/34: wavelet
229/16: ls
229/17: k
229/18: np.random.seed(2000)
229/19: %paste
229/20: np.save('testk.npy',k)
237/1: %paste
237/2: khold = np.load('testk.npy')
237/3: khold == k
237/4: np.all(khold == k)
236/35: %dhist
236/36: %history
236/37: %history -g -f history.txt
236/38: %history -g -f -t history.txt
238/1: %paste
238/2: %paste
238/3: P
238/4: plt.imshow(pdf)
238/5: plt.show()
238/6: samp.radialHistogram(k)
238/7: r
238/8: rmax=np.sqrt(2),bins=50
238/9: rmax=np.sqrt(2) ; bins=50
238/10: maxxy = (rmax**2)/2
238/11: [x,y] = np.meshgrid(np.linspace(-maxxy,maxxy,k.shape[0]), np.linspace(-maxxy,maxxy,k.shape[1]))
238/12: r = np.sqrt(x**2+y**2)
238/13: plt.imshow(r[147,:])
238/14: plt.plot(r[147,:])
238/15: plt.show()
238/16: plt.plot(r[147,:])
238/17: plt.show()
238/18: plt.plot(k[147,:])
238/19: plt.show()
238/20: r *= k
238/21: r = np.sqrt(x**2+y**2)
238/22: r = r*k
238/23: r
238/24: k
238/25: plt.imshow(k)
238/26: plt.show()
238/27: plt.imshow(r)
238/28: plt.show()
238/29: bins = 20
238/30: %paste
238/31: r = np.sqrt(x**2+y**2)
238/32: a = np.where(r <= 0.1)
238/33: a
238/34: k[a]
238/35: r[a]
238/36: r = np.sqrt(x**2+y**2)
238/37: np.where(abs(r-0.1) < 0.1)
238/38: a = np.where(abs(r-0.1) < 0.1)
238/39: k[a]
238/40: np.sum(k[a])
238/41: np.sum(k[a])/k[a].size
238/42: np.where(r < 0.1)
239/1: %paste
239/2: im_test = im_res
239/3: im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun, options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': alpha_0, 'c': 0.6, 'xtol': xtol*0.1, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
239/4: im_res = im_result['x'].reshape(N)
239/5: plt.imshow(im_res)
239/6: plt.show()
239/7: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
239/8: plt.imshow()
239/9: plt.show()
239/10: fig = plt.figure(figsize=(15,10))
239/11: ax = fig.add_subplot(1,2,1)
239/12: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
239/13: plt.title('xtol=1e-4')
239/14: ax = fig.add_subplot(1,2,2)
239/15: plt.imshow(im_test,clim=(minval,maxval),interpolation='bilinear')
239/16: plt.title('xtol=1e-3')
239/17: plt.show()
239/18: im_dc = np.load('/home/asalerno/Documents/pyDirectionCompSense/brainData/exercise_irradiation/bruker_data/running_C/P14/rad_0.1/TV0.005_XFM0.005/0.25per_result_im_dc_densCorr.npy')
239/19: im_result = opt.minimize(optfun, im_dc, args=args, method=method, jac=derivative_fun, options={'maxiter': ItnLim, 'gtol': 0.01, 'disp': 1, 'alpha_0': alpha_0, 'c': 0.6, 'xtol': xtol, 'TVWeight': TVWeight, 'XFMWeight': XFMWeight, 'N': N})
239/20: im_res = im_result['x'].reshape(N)
239/21:     plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
239/22:     plt.title("Reconstructed Image with %d%% Sampling and im_dc==" % (pctg*100) + imdcs)
239/23:     plt.show()
239/24: %paste
239/25: plt.imshow(im_res,clim=(minval,maxval),interpolation='bilinear')
239/26: plt.title("Reconstructed Image with %d%% Sampling and im_dc==" % (pctg*100) + imdcs)
239/27: plt.imshow(im_test,clim=(minval,maxval),interpolation='bilinear')
239/28: plt.title("Reconstructed Image with %d%% Sampling and im_dc==" % (pctg*100) + imdcs)
239/29: plt.show()
239/30: im_dc = im_test
239/31: TVWeight = XFMWeight = 0.001
239/32: xtol
239/33: %paste
239/34: xtol = 1e-5
239/35: %paste
240/1: %paste
240/2: %paste
240/3: %paste
   1:  %history -g -f -t history.txt
   2: %history -g -f -t history.txt
   3: img_sz = [294,294]
   4: p =3
   5: pctg = .25
   6: l_norm = 2
   7: radius = 0.1
   8: %history -g -f history.txt
